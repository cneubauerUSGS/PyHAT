<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8">
    
    <title>pandas.core.generic &mdash; PySAT</title>
    
    <link rel="stylesheet" type="text/css" href="../../../_static/css/spc-bootstrap.css">
    <link rel="stylesheet" type="text/css" href="../../../_static/css/spc-extend.css">
    <link rel="stylesheet" href="../../../_static/scipy.css" type="text/css" >
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" >
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../../../_static/js/copybutton.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" >
    <link rel="search" title="Search" href="../../../search.html" >
    <link rel="top" title="PySAT" href="../../../index.html" >
    <link rel="up" title="Module code" href="../../index.html" > 
  </head>
  <body>

  <div class="container">
    <div class="header">
    </div>
  </div>


    <div class="container">
      <div class="main">
        
	<div class="row-fluid">
	  <div class="span12">
	    <div class="spc-navbar">
              
    <ul class="nav nav-pills pull-left">
	
        <li class="active"><a href="../../../index.html">PySAT</a></li>
	
          <li class="active"><a href="../../index.html" accesskey="U">Module code</a></li> 
    </ul>
              
              
    <ul class="nav nav-pills pull-right">
      <li class="active">
        <a href="../../../genindex.html" title="General Index"
           accesskey="I">index</a>
      </li>
      <li class="active">
        <a href="../../../py-modindex.html" title="Python Module Index"
           >modules</a>
      </li>
    </ul>
              
	    </div>
	  </div>
	</div>
        

	<div class="row-fluid">
      <div class="spc-rightsidebar span3">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/favicon.png" alt="Logo">
            </a></p>

        </div>
      </div>
          <div class="span9">
            
        <div class="bodywrapper">
          <div class="body" id="spc-section-body">
            
  <h1>Source code for pandas.core.generic</h1><div class="highlight"><pre>
<span></span><span class="c1"># pylint: disable=W0231,E1101</span>
<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">import</span> <span class="nn">weakref</span>
<span class="kn">import</span> <span class="nn">gc</span>
<span class="kn">import</span> <span class="nn">json</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>

<span class="kn">from</span> <span class="nn">pandas._libs</span> <span class="k">import</span> <span class="n">tslib</span><span class="p">,</span> <span class="n">lib</span><span class="p">,</span> <span class="n">properties</span>
<span class="kn">from</span> <span class="nn">pandas.core.dtypes.common</span> <span class="k">import</span> <span class="p">(</span>
    <span class="n">_ensure_int64</span><span class="p">,</span>
    <span class="n">_ensure_object</span><span class="p">,</span>
    <span class="n">is_scalar</span><span class="p">,</span>
    <span class="n">is_number</span><span class="p">,</span>
    <span class="n">is_integer</span><span class="p">,</span> <span class="n">is_bool</span><span class="p">,</span>
    <span class="n">is_bool_dtype</span><span class="p">,</span>
    <span class="n">is_numeric_dtype</span><span class="p">,</span>
    <span class="n">is_datetime64_dtype</span><span class="p">,</span>
    <span class="n">is_timedelta64_dtype</span><span class="p">,</span>
    <span class="n">is_datetime64tz_dtype</span><span class="p">,</span>
    <span class="n">is_list_like</span><span class="p">,</span>
    <span class="n">is_dict_like</span><span class="p">,</span>
    <span class="n">is_re_compilable</span><span class="p">,</span>
    <span class="n">pandas_dtype</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.core.dtypes.cast</span> <span class="k">import</span> <span class="n">maybe_promote</span><span class="p">,</span> <span class="n">maybe_upcast_putmask</span>
<span class="kn">from</span> <span class="nn">pandas.core.dtypes.missing</span> <span class="k">import</span> <span class="n">isna</span><span class="p">,</span> <span class="n">notna</span>
<span class="kn">from</span> <span class="nn">pandas.core.dtypes.generic</span> <span class="k">import</span> <span class="n">ABCSeries</span><span class="p">,</span> <span class="n">ABCPanel</span><span class="p">,</span> <span class="n">ABCDataFrame</span>
<span class="kn">from</span> <span class="nn">pandas.core.common</span> <span class="k">import</span> <span class="p">(</span><span class="n">_count_not_none</span><span class="p">,</span>
                                <span class="n">_maybe_box_datetimelike</span><span class="p">,</span> <span class="n">_values_from_object</span><span class="p">,</span>
                                <span class="n">AbstractMethodError</span><span class="p">,</span> <span class="n">SettingWithCopyError</span><span class="p">,</span>
                                <span class="n">SettingWithCopyWarning</span><span class="p">)</span>

<span class="kn">from</span> <span class="nn">pandas.core.base</span> <span class="k">import</span> <span class="n">PandasObject</span><span class="p">,</span> <span class="n">SelectionMixin</span>
<span class="kn">from</span> <span class="nn">pandas.core.index</span> <span class="k">import</span> <span class="p">(</span><span class="n">Index</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">,</span> <span class="n">_ensure_index</span><span class="p">,</span>
                               <span class="n">InvalidIndexError</span><span class="p">)</span>
<span class="kn">import</span> <span class="nn">pandas.core.indexing</span> <span class="k">as</span> <span class="nn">indexing</span>
<span class="kn">from</span> <span class="nn">pandas.core.indexing</span> <span class="k">import</span> <span class="n">maybe_convert_indices</span>
<span class="kn">from</span> <span class="nn">pandas.core.indexes.datetimes</span> <span class="k">import</span> <span class="n">DatetimeIndex</span>
<span class="kn">from</span> <span class="nn">pandas.core.indexes.period</span> <span class="k">import</span> <span class="n">PeriodIndex</span><span class="p">,</span> <span class="n">Period</span>
<span class="kn">from</span> <span class="nn">pandas.core.internals</span> <span class="k">import</span> <span class="n">BlockManager</span>
<span class="kn">import</span> <span class="nn">pandas.core.algorithms</span> <span class="k">as</span> <span class="nn">algos</span>
<span class="kn">import</span> <span class="nn">pandas.core.common</span> <span class="k">as</span> <span class="nn">com</span>
<span class="kn">import</span> <span class="nn">pandas.core.missing</span> <span class="k">as</span> <span class="nn">missing</span>
<span class="kn">from</span> <span class="nn">pandas.io.formats.printing</span> <span class="k">import</span> <span class="n">pprint_thing</span>
<span class="kn">from</span> <span class="nn">pandas.io.formats.format</span> <span class="k">import</span> <span class="n">format_percentiles</span><span class="p">,</span> <span class="n">DataFrameFormatter</span>
<span class="kn">from</span> <span class="nn">pandas.tseries.frequencies</span> <span class="k">import</span> <span class="n">to_offset</span>
<span class="kn">from</span> <span class="nn">pandas</span> <span class="k">import</span> <span class="n">compat</span>
<span class="kn">from</span> <span class="nn">pandas.compat.numpy</span> <span class="k">import</span> <span class="n">function</span> <span class="k">as</span> <span class="n">nv</span>
<span class="kn">from</span> <span class="nn">pandas.compat</span> <span class="k">import</span> <span class="p">(</span><span class="nb">map</span><span class="p">,</span> <span class="nb">zip</span><span class="p">,</span> <span class="n">lzip</span><span class="p">,</span> <span class="n">lrange</span><span class="p">,</span> <span class="n">string_types</span><span class="p">,</span> <span class="n">to_str</span><span class="p">,</span>
                           <span class="n">isidentifier</span><span class="p">,</span> <span class="n">set_function_name</span><span class="p">,</span> <span class="n">cPickle</span> <span class="k">as</span> <span class="n">pkl</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.core.ops</span> <span class="k">import</span> <span class="n">_align_method_FRAME</span>
<span class="kn">import</span> <span class="nn">pandas.core.nanops</span> <span class="k">as</span> <span class="nn">nanops</span>
<span class="kn">from</span> <span class="nn">pandas.util._decorators</span> <span class="k">import</span> <span class="p">(</span><span class="n">Appender</span><span class="p">,</span> <span class="n">Substitution</span><span class="p">,</span>
                                     <span class="n">deprecate_kwarg</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.util._validators</span> <span class="k">import</span> <span class="n">validate_bool_kwarg</span>
<span class="kn">from</span> <span class="nn">pandas.core</span> <span class="k">import</span> <span class="n">config</span>

<span class="c1"># goal is to be able to define the docs close to function, while still being</span>
<span class="c1"># able to share</span>
<span class="n">_shared_docs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
<span class="n">_shared_doc_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
    <span class="n">axes</span><span class="o">=</span><span class="s1">&#39;keywords for axes&#39;</span><span class="p">,</span> <span class="n">klass</span><span class="o">=</span><span class="s1">&#39;NDFrame&#39;</span><span class="p">,</span>
    <span class="n">axes_single_arg</span><span class="o">=</span><span class="s1">&#39;int or labels for object&#39;</span><span class="p">,</span>
    <span class="n">args_transpose</span><span class="o">=</span><span class="s1">&#39;axes to permute (int or label for object)&#39;</span><span class="p">,</span>
    <span class="n">optional_by</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        by : str or list of str</span>
<span class="s2">            Name or list of names which refer to the axis items.&quot;&quot;&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_single_replace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">to_replace</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">inplace</span><span class="p">,</span> <span class="n">limit</span><span class="p">):</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;cannot replace </span><span class="si">{0}</span><span class="s1"> with method </span><span class="si">{1}</span><span class="s1"> on a </span><span class="si">{2}</span><span class="s1">&#39;</span>
                        <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">to_replace</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>

    <span class="n">orig_dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span>
    <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span> <span class="k">if</span> <span class="n">inplace</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">fill_f</span> <span class="o">=</span> <span class="n">missing</span><span class="o">.</span><span class="n">get_fill_func</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>

    <span class="n">mask</span> <span class="o">=</span> <span class="n">missing</span><span class="o">.</span><span class="n">mask_missing</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">to_replace</span><span class="p">)</span>
    <span class="n">values</span> <span class="o">=</span> <span class="n">fill_f</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">values</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">orig_dtype</span> <span class="ow">and</span> <span class="n">inplace</span><span class="p">:</span>
        <span class="k">return</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span>
                       <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_inplace</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span>
        <span class="k">return</span>

    <span class="k">return</span> <span class="n">result</span>


<span class="k">class</span> <span class="nc">NDFrame</span><span class="p">(</span><span class="n">PandasObject</span><span class="p">,</span> <span class="n">SelectionMixin</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    N-dimensional analogue of DataFrame. Store multi-dimensional in a</span>
<span class="sd">    size-mutable, labeled data structure</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : BlockManager</span>
<span class="sd">    axes : list</span>
<span class="sd">    copy : boolean, default False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_internal_names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;_data&#39;</span><span class="p">,</span> <span class="s1">&#39;_cacher&#39;</span><span class="p">,</span> <span class="s1">&#39;_item_cache&#39;</span><span class="p">,</span> <span class="s1">&#39;_cache&#39;</span><span class="p">,</span> <span class="s1">&#39;is_copy&#39;</span><span class="p">,</span>
                       <span class="s1">&#39;_subtyp&#39;</span><span class="p">,</span> <span class="s1">&#39;_name&#39;</span><span class="p">,</span> <span class="s1">&#39;_index&#39;</span><span class="p">,</span> <span class="s1">&#39;_default_kind&#39;</span><span class="p">,</span>
                       <span class="s1">&#39;_default_fill_value&#39;</span><span class="p">,</span> <span class="s1">&#39;_metadata&#39;</span><span class="p">,</span> <span class="s1">&#39;__array_struct__&#39;</span><span class="p">,</span>
                       <span class="s1">&#39;__array_interface__&#39;</span><span class="p">]</span>
    <span class="n">_internal_names_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">_internal_names</span><span class="p">)</span>
    <span class="n">_accessors</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">([])</span>
    <span class="n">_deprecations</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">([</span><span class="s1">&#39;as_blocks&#39;</span><span class="p">,</span> <span class="s1">&#39;blocks&#39;</span><span class="p">,</span>
                               <span class="s1">&#39;consolidate&#39;</span><span class="p">,</span> <span class="s1">&#39;convert_objects&#39;</span><span class="p">])</span>
    <span class="n">_metadata</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">is_copy</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">fastpath</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">fastpath</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">copy</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">axes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">axes</span><span class="p">):</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">reindex_axis</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>

        <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;is_copy&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_data&#39;</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
        <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_item_cache&#39;</span><span class="p">,</span> <span class="p">{})</span>

    <span class="k">def</span> <span class="nf">_repr_data_resource_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Not a real Jupyter special repr method, but we use the same</span>
<span class="sd">        naming convention.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">config</span><span class="o">.</span><span class="n">get_option</span><span class="p">(</span><span class="s2">&quot;display.html.table_schema&quot;</span><span class="p">):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">get_option</span><span class="p">(</span><span class="s1">&#39;display.max_rows&#39;</span><span class="p">))</span>
            <span class="n">payload</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">to_json</span><span class="p">(</span><span class="n">orient</span><span class="o">=</span><span class="s1">&#39;table&#39;</span><span class="p">),</span>
                                 <span class="n">object_pairs_hook</span><span class="o">=</span><span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">payload</span>

    <span class="k">def</span> <span class="nf">_validate_dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; validate the passed dtype &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="n">pandas_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>

            <span class="c1"># a compound dtype</span>
            <span class="k">if</span> <span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;V&#39;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;compound dtypes are not implemented&quot;</span>
                                          <span class="s2">&quot; in the </span><span class="si">{0}</span><span class="s2"> constructor&quot;</span>
                                          <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">dtype</span>

    <span class="k">def</span> <span class="nf">_init_mgr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mgr</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; passed a manager and a axes dict &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">axe</span> <span class="ow">in</span> <span class="n">axes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">axe</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">mgr</span> <span class="o">=</span> <span class="n">mgr</span><span class="o">.</span><span class="n">reindex_axis</span><span class="p">(</span><span class="n">axe</span><span class="p">,</span>
                                       <span class="n">axis</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_block_manager_axis</span><span class="p">(</span><span class="n">a</span><span class="p">),</span>
                                       <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># make a copy if explicitly requested</span>
        <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
            <span class="n">mgr</span> <span class="o">=</span> <span class="n">mgr</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># avoid further copies if we can</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mgr</span><span class="o">.</span><span class="n">blocks</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">mgr</span><span class="o">.</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">dtype</span><span class="p">:</span>
                <span class="n">mgr</span> <span class="o">=</span> <span class="n">mgr</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mgr</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># Construction</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_constructor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Used when a manipulation result has the same dimensions as the</span>
<span class="sd">        original.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="n">AbstractMethodError</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__unicode__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># unicode representation based upon iterating over self</span>
        <span class="c1"># (since, by definition, `PandasContainers` are iterable)</span>
        <span class="n">prepr</span> <span class="o">=</span> <span class="s1">&#39;[</span><span class="si">%s</span><span class="s1">]&#39;</span> <span class="o">%</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">pprint_thing</span><span class="p">,</span> <span class="bp">self</span><span class="p">))</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">(</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">prepr</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_dir_additions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; add the string-like attributes from the info_axis &quot;&quot;&quot;</span>
        <span class="n">additions</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_info_axis</span>
                         <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">string_types</span><span class="p">)</span> <span class="ow">and</span> <span class="n">isidentifier</span><span class="p">(</span><span class="n">c</span><span class="p">)])</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">NDFrame</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_dir_additions</span><span class="p">()</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">additions</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_constructor_sliced</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Used when a manipulation result has one lower dimension(s) as the</span>
<span class="sd">        original, such as DataFrame single columns slicing.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="n">AbstractMethodError</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_constructor_expanddim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Used when a manipulation result has one higher dimension as the</span>
<span class="sd">        original, such as Series.to_frame() and DataFrame.to_panel()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># Axis</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_setup_axes</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="n">info_axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stat_axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">aliases</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">slicers</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axes_are_reversed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">build_axes</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">ns</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Provide axes setup for the major PandasObjects.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axes : the names of the axes in order (lowest to highest)</span>
<span class="sd">        info_axis_num : the axis of the selector dimension (int)</span>
<span class="sd">        stat_axis_num : the number of axis for the default stats (int)</span>
<span class="sd">        aliases : other names for a single axis (dict)</span>
<span class="sd">        slicers : how axes slice to others (dict)</span>
<span class="sd">        axes_are_reversed : boolean whether to treat passed axes as</span>
<span class="sd">            reversed (DataFrame)</span>
<span class="sd">        build_axes : setup the axis properties (default True)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">cls</span><span class="o">.</span><span class="n">_AXIS_ORDERS</span> <span class="o">=</span> <span class="n">axes</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_AXIS_NUMBERS</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">axes</span><span class="p">))</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_AXIS_LEN</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_AXIS_ALIASES</span> <span class="o">=</span> <span class="n">aliases</span> <span class="ow">or</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_AXIS_IALIASES</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">v</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_AXIS_ALIASES</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_AXIS_NAMES</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">axes</span><span class="p">))</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_AXIS_SLICEMAP</span> <span class="o">=</span> <span class="n">slicers</span> <span class="ow">or</span> <span class="kc">None</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_AXIS_REVERSED</span> <span class="o">=</span> <span class="n">axes_are_reversed</span>

        <span class="c1"># typ</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s1">&#39;_typ&#39;</span><span class="p">,</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="o">.</span><span class="n">lower</span><span class="p">())</span>

        <span class="c1"># indexing support</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_ix</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">info_axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">_info_axis_number</span> <span class="o">=</span> <span class="n">info_axis</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">_info_axis_name</span> <span class="o">=</span> <span class="n">axes</span><span class="p">[</span><span class="n">info_axis</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">stat_axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">_stat_axis_number</span> <span class="o">=</span> <span class="n">stat_axis</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">_stat_axis_name</span> <span class="o">=</span> <span class="n">axes</span><span class="p">[</span><span class="n">stat_axis</span><span class="p">]</span>

        <span class="c1"># setup the actual axis</span>
        <span class="k">if</span> <span class="n">build_axes</span><span class="p">:</span>

            <span class="k">def</span> <span class="nf">set_axis</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">properties</span><span class="o">.</span><span class="n">AxisProperty</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
                <span class="bp">cls</span><span class="o">.</span><span class="n">_internal_names_set</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">axes_are_reversed</span><span class="p">:</span>
                <span class="n">m</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_AXIS_LEN</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_AXIS_NAMES</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">set_axis</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">m</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_AXIS_NAMES</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">set_axis</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>

        <span class="c1"># addtl parms</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ns</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">ns</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_construct_axes_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return an axes dictionary for myself.&quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">a</span><span class="p">))</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="p">(</span><span class="n">axes</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_ORDERS</span><span class="p">)])</span>
        <span class="n">d</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">d</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_construct_axes_dict_from</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return an axes dictionary for the passed axes.&quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">a</span><span class="p">,</span> <span class="n">ax</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_ORDERS</span><span class="p">,</span> <span class="n">axes</span><span class="p">)])</span>
        <span class="n">d</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">d</span>

    <span class="k">def</span> <span class="nf">_construct_axes_dict_for_slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return an axes dictionary for myself.&quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_SLICEMAP</span><span class="p">[</span><span class="n">a</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
                  <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="p">(</span><span class="n">axes</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_ORDERS</span><span class="p">)])</span>
        <span class="n">d</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">d</span>

    <span class="k">def</span> <span class="nf">_construct_axes_from_arguments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="n">require_all</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Construct and returns axes if supplied in args/kwargs.</span>

<span class="sd">        If require_all, raise if all axis arguments are not supplied</span>
<span class="sd">        return a tuple of (axes, kwargs).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># construct the args</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_ORDERS</span><span class="p">:</span>

            <span class="c1"># if we have an alias for this axis</span>
            <span class="n">alias</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_IALIASES</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">alias</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">alias</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;arguments are mutually exclusive &quot;</span>
                                        <span class="s2">&quot;for [</span><span class="si">%s</span><span class="s2">,</span><span class="si">%s</span><span class="s2">]&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">alias</span><span class="p">))</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="n">alias</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                    <span class="n">kwargs</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">alias</span><span class="p">)</span>
                    <span class="k">continue</span>

            <span class="c1"># look for a argument by position</span>
            <span class="k">if</span> <span class="n">a</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">kwargs</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">require_all</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;not enough/duplicate arguments &quot;</span>
                                        <span class="s2">&quot;specified!&quot;</span><span class="p">)</span>

        <span class="n">axes</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">a</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_ORDERS</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">axes</span><span class="p">,</span> <span class="n">kwargs</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_from_axes</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># for construction from BlockManager</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">BlockManager</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_AXIS_REVERSED</span><span class="p">:</span>
                <span class="n">axes</span> <span class="o">=</span> <span class="n">axes</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">d</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_construct_axes_dict_from</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">d</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">**</span><span class="n">d</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_axis_number</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_ALIASES</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">is_integer</span><span class="p">(</span><span class="n">axis</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">axis</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_NAMES</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">axis</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_NUMBERS</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;No axis named </span><span class="si">{0}</span><span class="s1"> for object type </span><span class="si">{1}</span><span class="s1">&#39;</span>
                         <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)))</span>

    <span class="k">def</span> <span class="nf">_get_axis_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_ALIASES</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">axis</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_NUMBERS</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">axis</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_NAMES</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;No axis named </span><span class="si">{0}</span><span class="s1"> for object type </span><span class="si">{1}</span><span class="s1">&#39;</span>
                         <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)))</span>

    <span class="k">def</span> <span class="nf">_get_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
        <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_name</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_block_manager_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Map the axis to the block_manager axis.&quot;&quot;&quot;</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_REVERSED</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_LEN</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="n">m</span> <span class="o">-</span> <span class="n">axis</span>
        <span class="k">return</span> <span class="n">axis</span>

    <span class="k">def</span> <span class="nf">_get_axis_resolvers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
        <span class="c1"># index or columns</span>
        <span class="n">axis_index</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">prefix</span> <span class="o">=</span> <span class="n">axis</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">axis_index</span><span class="o">.</span><span class="n">names</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">key</span> <span class="o">=</span> <span class="n">level</span> <span class="o">=</span> <span class="n">name</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># prefix with &#39;i&#39; or &#39;c&#39; depending on the input axis</span>
                <span class="c1"># e.g., you must do ilevel_0 for the 0th level of an unnamed</span>
                <span class="c1"># multiiindex</span>
                <span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{prefix}</span><span class="s1">level_</span><span class="si">{i}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">prefix</span><span class="o">=</span><span class="n">prefix</span><span class="p">,</span> <span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>
                <span class="n">level</span> <span class="o">=</span> <span class="n">i</span>

            <span class="n">level_values</span> <span class="o">=</span> <span class="n">axis_index</span><span class="o">.</span><span class="n">get_level_values</span><span class="p">(</span><span class="n">level</span><span class="p">)</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">level_values</span><span class="o">.</span><span class="n">to_series</span><span class="p">()</span>
            <span class="n">s</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">axis_index</span>
            <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span>

        <span class="c1"># put the index/columns itself in the dict</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axis_index</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">):</span>
            <span class="n">dindex</span> <span class="o">=</span> <span class="n">axis_index</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dindex</span> <span class="o">=</span> <span class="n">axis_index</span><span class="o">.</span><span class="n">to_series</span><span class="p">()</span>

        <span class="n">d</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">dindex</span>
        <span class="k">return</span> <span class="n">d</span>

    <span class="k">def</span> <span class="nf">_get_index_resolvers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">d</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">axis_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_ORDERS</span><span class="p">:</span>
            <span class="n">d</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_resolvers</span><span class="p">(</span><span class="n">axis_name</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">d</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_info_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_info_axis_name</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_stat_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stat_axis_name</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a tuple of axis dimensions&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">a</span><span class="p">))</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_ORDERS</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">axes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return index label(s) of the internal NDFrame&quot;&quot;&quot;</span>
        <span class="c1"># we do it this way because if we have reversed axes, then</span>
        <span class="c1"># the block manager shows then reversed</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_ORDERS</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ndim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of axes / array dimensions&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">ndim</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;number of elements in the NDFrame&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_selected_obj</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; internal compat with SelectionMixin &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_obj_with_exclusions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; internal compat with SelectionMixin &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_expand_axes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="n">new_axes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ax</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">!=</span> <span class="n">ax</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">:</span>
                    <span class="n">ax</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;O&#39;</span><span class="p">)</span>
                <span class="n">new_axes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ax</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ax</span><span class="p">),</span> <span class="n">k</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_axes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">new_axes</span>

    <span class="n">_shared_docs</span><span class="p">[</span><span class="s1">&#39;set_axis&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;Assign desired index to given axis</span>

<span class="s2">        Parameters</span>
<span class="s2">        ----------</span>
<span class="s2">        labels: list-like or Index</span>
<span class="s2">            The values for the new index</span>
<span class="s2">        axis : int or string, default 0</span>
<span class="s2">        inplace : boolean, default None</span>
<span class="s2">            Whether to return a new </span><span class="si">%(klass)s</span><span class="s2"> instance.</span>

<span class="s2">            WARNING: inplace=None currently falls back to to True, but</span>
<span class="s2">            in a future version, will default to False.  Use inplace=True</span>
<span class="s2">            explicitly rather than relying on the default.</span>

<span class="s2">        .. versionadded:: 0.21.0</span>
<span class="s2">            The signature is make consistent to the rest of the API.</span>
<span class="s2">            Previously, the &quot;axis&quot; and &quot;labels&quot; arguments were respectively</span>
<span class="s2">            the first and second positional arguments.</span>

<span class="s2">        Returns</span>
<span class="s2">        -------</span>
<span class="s2">        renamed : </span><span class="si">%(klass)s</span><span class="s2"> or None</span>
<span class="s2">            An object of same type as caller if inplace=False, None otherwise.</span>

<span class="s2">        See Also</span>
<span class="s2">        --------</span>
<span class="s2">        pandas.NDFrame.rename</span>

<span class="s2">        Examples</span>
<span class="s2">        --------</span>
<span class="s2">        &gt;&gt;&gt; s = pd.Series([1, 2, 3])</span>
<span class="s2">        &gt;&gt;&gt; s</span>
<span class="s2">        0    1</span>
<span class="s2">        1    2</span>
<span class="s2">        2    3</span>
<span class="s2">        dtype: int64</span>
<span class="s2">        &gt;&gt;&gt; s.set_axis([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], axis=0, inplace=False)</span>
<span class="s2">        a    1</span>
<span class="s2">        b    2</span>
<span class="s2">        c    3</span>
<span class="s2">        dtype: int64</span>
<span class="s2">        &gt;&gt;&gt; df = pd.DataFrame({&quot;A&quot;: [1, 2, 3], &quot;B&quot;: [4, 5, 6]})</span>
<span class="s2">        &gt;&gt;&gt; df.set_axis([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], axis=0, inplace=False)</span>
<span class="s2">           A  B</span>
<span class="s2">        a  1  4</span>
<span class="s2">        b  2  5</span>
<span class="s2">        c  3  6</span>
<span class="s2">        &gt;&gt;&gt; df.set_axis([&#39;I&#39;, &#39;II&#39;], axis=1, inplace=False)</span>
<span class="s2">           I  II</span>
<span class="s2">        0  1   4</span>
<span class="s2">        1  2   5</span>
<span class="s2">        2  3   6</span>
<span class="s2">        &gt;&gt;&gt; df.set_axis([&#39;i&#39;, &#39;ii&#39;], axis=1, inplace=True)</span>
<span class="s2">        &gt;&gt;&gt; df</span>
<span class="s2">           i  ii</span>
<span class="s2">        0  1   4</span>
<span class="s2">        1  2   5</span>
<span class="s2">        2  3   6</span>

<span class="s2">        &quot;&quot;&quot;</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s1">&#39;set_axis&#39;</span><span class="p">]</span> <span class="o">%</span> <span class="nb">dict</span><span class="p">(</span><span class="n">klass</span><span class="o">=</span><span class="s1">&#39;NDFrame&#39;</span><span class="p">))</span>
    <span class="k">def</span> <span class="nf">set_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">is_scalar</span><span class="p">(</span><span class="n">labels</span><span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s1">&#39;set_axis now takes &quot;labels&quot; as first argument, and &#39;</span>
                <span class="s1">&#39;&quot;axis&quot; as named parameter. The old form, with &quot;axis&quot; as &#39;</span>
                <span class="s1">&#39;first parameter and </span><span class="se">\&quot;</span><span class="s1">labels</span><span class="se">\&quot;</span><span class="s1"> as second, is still supported &#39;</span>
                <span class="s1">&#39;but will be deprecated in a future version of pandas.&#39;</span><span class="p">,</span>
                <span class="ne">FutureWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">labels</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="n">axis</span><span class="p">,</span> <span class="n">labels</span>

        <span class="k">if</span> <span class="n">inplace</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s1">&#39;set_axis currently defaults to operating inplace.</span><span class="se">\n</span><span class="s1">This &#39;</span>
                <span class="s1">&#39;will change in a future version of pandas, use &#39;</span>
                <span class="s1">&#39;inplace=True to avoid this warning.&#39;</span><span class="p">,</span>
                <span class="ne">FutureWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">inplace</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_name</span><span class="p">(</span><span class="n">axis</span><span class="p">),</span> <span class="n">labels</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">set_axis</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">obj</span>

    <span class="k">def</span> <span class="nf">_set_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">labels</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">set_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_clear_item_cache</span><span class="p">()</span>

    <span class="n">_shared_docs</span><span class="p">[</span><span class="s1">&#39;transpose&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        Permute the dimensions of the </span><span class="si">%(klass)s</span><span class="s2"></span>

<span class="s2">        Parameters</span>
<span class="s2">        ----------</span>
<span class="s2">        args : </span><span class="si">%(args_transpose)s</span><span class="s2"></span>
<span class="s2">        copy : boolean, default False</span>
<span class="s2">            Make a copy of the underlying data. Mixed-dtype data will</span>
<span class="s2">            always result in a copy</span>

<span class="s2">        Examples</span>
<span class="s2">        --------</span>
<span class="s2">        &gt;&gt;&gt; p.transpose(2, 0, 1)</span>
<span class="s2">        &gt;&gt;&gt; p.transpose(2, 0, 1, copy=True)</span>

<span class="s2">        Returns</span>
<span class="s2">        -------</span>
<span class="s2">        y : same as input</span>
<span class="s2">        &quot;&quot;&quot;</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s1">&#39;transpose&#39;</span><span class="p">]</span> <span class="o">%</span> <span class="n">_shared_doc_kwargs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">transpose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

        <span class="c1"># construct the args</span>
        <span class="n">axes</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_construct_axes_from_arguments</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span>
                                                           <span class="n">require_all</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">axes_names</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_name</span><span class="p">(</span><span class="n">axes</span><span class="p">[</span><span class="n">a</span><span class="p">])</span>
                            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_ORDERS</span><span class="p">])</span>
        <span class="n">axes_numbers</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axes</span><span class="p">[</span><span class="n">a</span><span class="p">])</span>
                              <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_ORDERS</span><span class="p">])</span>

        <span class="c1"># we must have unique axes</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">axes</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Must specify </span><span class="si">%s</span><span class="s1"> unique axes&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_LEN</span><span class="p">)</span>

        <span class="n">new_axes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_construct_axes_dict_from</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                                                         <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">axes_names</span><span class="p">])</span>
        <span class="n">new_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">axes_numbers</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;copy&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="ow">and</span> <span class="n">args</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">new_values</span> <span class="o">=</span> <span class="n">new_values</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">nv</span><span class="o">.</span><span class="n">validate_transpose_for_generic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">new_values</span><span class="p">,</span> <span class="o">**</span><span class="n">new_axes</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">swapaxes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis1</span><span class="p">,</span> <span class="n">axis2</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Interchange axes and swap values axes appropriately</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        y : same as input</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis1</span><span class="p">)</span>
        <span class="n">j</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis2</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="n">mapping</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="n">i</span><span class="p">}</span>

        <span class="n">new_axes</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">mapping</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">))</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_LEN</span><span class="p">))</span>
        <span class="n">new_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
            <span class="n">new_values</span> <span class="o">=</span> <span class="n">new_values</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">new_values</span><span class="p">,</span> <span class="o">*</span><span class="n">new_axes</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return item and drop from frame. Raise KeyError if not found.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        item : str</span>
<span class="sd">            Column label to be popped</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        popped : Series</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame([(&#39;falcon&#39;, &#39;bird&#39;,    389.0),</span>
<span class="sd">        ...                    (&#39;parrot&#39;, &#39;bird&#39;,     24.0),</span>
<span class="sd">        ...                    (&#39;lion&#39;,   &#39;mammal&#39;,   80.5),</span>
<span class="sd">        ...                    (&#39;monkey&#39;, &#39;mammal&#39;, np.nan)],</span>
<span class="sd">        ...                   columns=(&#39;name&#39;, &#39;class&#39;, &#39;max_speed&#39;))</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">             name   class  max_speed</span>
<span class="sd">        0  falcon    bird      389.0</span>
<span class="sd">        1  parrot    bird       24.0</span>
<span class="sd">        2    lion  mammal       80.5</span>
<span class="sd">        3  monkey  mammal        NaN</span>

<span class="sd">        &gt;&gt;&gt; df.pop(&#39;class&#39;)</span>
<span class="sd">        0      bird</span>
<span class="sd">        1      bird</span>
<span class="sd">        2    mammal</span>
<span class="sd">        3    mammal</span>
<span class="sd">        Name: class, dtype: object</span>

<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">             name  max_speed</span>
<span class="sd">        0  falcon      389.0</span>
<span class="sd">        1  parrot       24.0</span>
<span class="sd">        2    lion       80.5</span>
<span class="sd">        3  monkey        NaN</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">item</span><span class="p">]</span>
        <span class="k">del</span> <span class="bp">self</span><span class="p">[</span><span class="n">item</span><span class="p">]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">_reset_cacher</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">squeeze</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Squeeze length 1 dimensions.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis : None, integer or string axis name, optional</span>
<span class="sd">            The axis to squeeze if 1-sized.</span>

<span class="sd">            .. versionadded:: 0.20.0</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        scalar if 1-sized, else original object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_NAMES</span> <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">),))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span>
                <span class="nb">tuple</span><span class="p">([</span><span class="mi">0</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">axis</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                       <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">)])]</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">swaplevel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="o">=-</span><span class="mi">2</span><span class="p">,</span> <span class="n">j</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Swap levels i and j in a MultiIndex on a particular axis</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        i, j : int, string (can be mixed)</span>
<span class="sd">            Level of index to be swapped. Can pass level name as string.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        swapped : type of caller (new object)</span>

<span class="sd">        .. versionchanged:: 0.18.1</span>

<span class="sd">           The indexes ``i`` and ``j`` are now optional, and default to</span>
<span class="sd">           the two innermost levels of the index.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
        <span class="n">result</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">set_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">labels</span><span class="o">.</span><span class="n">swaplevel</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># Rename</span>

    <span class="c1"># TODO: define separate funcs for DataFrame, Series and Panel so you can</span>
    <span class="c1"># get completion on keyword arguments.</span>
    <span class="n">_shared_docs</span><span class="p">[</span><span class="s1">&#39;rename&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        Alter axes input function or functions. Function / dict values must be</span>
<span class="s2">        unique (1-to-1). Labels not contained in a dict / Series will be left</span>
<span class="s2">        as-is. Extra labels listed don&#39;t throw an error. Alternatively, change</span>
<span class="s2">        ``Series.name`` with a scalar value (Series only).</span>

<span class="s2">        Parameters</span>
<span class="s2">        ----------</span>
<span class="s2">        </span><span class="si">%(optional_mapper)s</span><span class="s2"></span>
<span class="s2">        </span><span class="si">%(axes)s</span><span class="s2"> : scalar, list-like, dict-like or function, optional</span>
<span class="s2">            Scalar or list-like will alter the ``Series.name`` attribute,</span>
<span class="s2">            and raise on DataFrame or Panel.</span>
<span class="s2">            dict-like or functions are transformations to apply to</span>
<span class="s2">            that axis&#39; values</span>
<span class="s2">        </span><span class="si">%(optional_axis)s</span><span class="s2"></span>
<span class="s2">        copy : boolean, default True</span>
<span class="s2">            Also copy underlying data</span>
<span class="s2">        inplace : boolean, default False</span>
<span class="s2">            Whether to return a new </span><span class="si">%(klass)s</span><span class="s2">. If True then value of copy is</span>
<span class="s2">            ignored.</span>
<span class="s2">        level : int or level name, default None</span>
<span class="s2">            In case of a MultiIndex, only rename labels in the specified</span>
<span class="s2">            level.</span>

<span class="s2">        Returns</span>
<span class="s2">        -------</span>
<span class="s2">        renamed : </span><span class="si">%(klass)s</span><span class="s2"> (new object)</span>

<span class="s2">        See Also</span>
<span class="s2">        --------</span>
<span class="s2">        pandas.NDFrame.rename_axis</span>

<span class="s2">        Examples</span>
<span class="s2">        --------</span>

<span class="s2">        &gt;&gt;&gt; s = pd.Series([1, 2, 3])</span>
<span class="s2">        &gt;&gt;&gt; s</span>
<span class="s2">        0    1</span>
<span class="s2">        1    2</span>
<span class="s2">        2    3</span>
<span class="s2">        dtype: int64</span>
<span class="s2">        &gt;&gt;&gt; s.rename(&quot;my_name&quot;) # scalar, changes Series.name</span>
<span class="s2">        0    1</span>
<span class="s2">        1    2</span>
<span class="s2">        2    3</span>
<span class="s2">        Name: my_name, dtype: int64</span>
<span class="s2">        &gt;&gt;&gt; s.rename(lambda x: x ** 2)  # function, changes labels</span>
<span class="s2">        0    1</span>
<span class="s2">        1    2</span>
<span class="s2">        4    3</span>
<span class="s2">        dtype: int64</span>
<span class="s2">        &gt;&gt;&gt; s.rename({1: 3, 2: 5})  # mapping, changes labels</span>
<span class="s2">        0    1</span>
<span class="s2">        3    2</span>
<span class="s2">        5    3</span>
<span class="s2">        dtype: int64</span>

<span class="s2">        Since ``DataFrame`` doesn&#39;t have a ``.name`` attribute,</span>
<span class="s2">        only mapping-type arguments are allowed.</span>

<span class="s2">        &gt;&gt;&gt; df = pd.DataFrame({&quot;A&quot;: [1, 2, 3], &quot;B&quot;: [4, 5, 6]})</span>
<span class="s2">        &gt;&gt;&gt; df.rename(2)</span>
<span class="s2">        Traceback (most recent call last):</span>
<span class="s2">        ...</span>
<span class="s2">        TypeError: &#39;int&#39; object is not callable</span>

<span class="s2">        ``DataFrame.rename`` supports two calling conventions</span>

<span class="s2">        * ``(index=index_mapper, columns=columns_mapper, ...)``</span>
<span class="s2">        * ``(mapper, axis={&#39;index&#39;, &#39;columns&#39;}, ...)``</span>

<span class="s2">        We *highly* recommend using keyword arguments to clarify your</span>
<span class="s2">        intent.</span>

<span class="s2">        &gt;&gt;&gt; df.rename(index=str, columns={&quot;A&quot;: &quot;a&quot;, &quot;B&quot;: &quot;c&quot;})</span>
<span class="s2">           a  c</span>
<span class="s2">        0  1  4</span>
<span class="s2">        1  2  5</span>
<span class="s2">        2  3  6</span>

<span class="s2">        &gt;&gt;&gt; df.rename(index=str, columns={&quot;A&quot;: &quot;a&quot;, &quot;C&quot;: &quot;c&quot;})</span>
<span class="s2">           a  B</span>
<span class="s2">        0  1  4</span>
<span class="s2">        1  2  5</span>
<span class="s2">        2  3  6</span>

<span class="s2">        Using axis-style parameters</span>

<span class="s2">        &gt;&gt;&gt; df.rename(str.lower, axis=&#39;columns&#39;)</span>
<span class="s2">           a  b</span>
<span class="s2">        0  1  4</span>
<span class="s2">        1  2  5</span>
<span class="s2">        2  3  6</span>

<span class="s2">        &gt;&gt;&gt; df.rename({1: 2, 2: 4}, axis=&#39;index&#39;)</span>
<span class="s2">           A  B</span>
<span class="s2">        0  1  4</span>
<span class="s2">        2  2  5</span>
<span class="s2">        4  3  6</span>

<span class="s2">        See the :ref:`user guide &lt;basics.rename&gt;` for more.</span>
<span class="s2">        &quot;&quot;&quot;</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s1">&#39;rename&#39;</span><span class="p">]</span> <span class="o">%</span> <span class="nb">dict</span><span class="p">(</span><span class="n">axes</span><span class="o">=</span><span class="s1">&#39;axes keywords for this&#39;</span>
                                            <span class="s1">&#39; object&#39;</span><span class="p">,</span> <span class="n">klass</span><span class="o">=</span><span class="s1">&#39;NDFrame&#39;</span><span class="p">,</span>
                                            <span class="n">optional_mapper</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span>
                                            <span class="n">optional_axis</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">))</span>
    <span class="k">def</span> <span class="nf">rename</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">axes</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_construct_axes_from_arguments</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="n">copy</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;copy&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">inplace</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;inplace&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">level</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;level&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;rename() got an unexpected keyword &#39;</span>
                            <span class="s1">&#39;argument &quot;</span><span class="si">{0}</span><span class="s1">&quot;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">]))</span>

        <span class="k">if</span> <span class="n">com</span><span class="o">.</span><span class="n">_count_not_none</span><span class="p">(</span><span class="o">*</span><span class="n">axes</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;must pass an index to rename&#39;</span><span class="p">)</span>

        <span class="c1"># renamer function if passed a dict</span>
        <span class="k">def</span> <span class="nf">_get_rename_function</span><span class="p">(</span><span class="n">mapper</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mapper</span><span class="p">,</span> <span class="p">(</span><span class="nb">dict</span><span class="p">,</span> <span class="n">ABCSeries</span><span class="p">)):</span>

                <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">mapper</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">mapper</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">x</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">f</span> <span class="o">=</span> <span class="n">mapper</span>

            <span class="k">return</span> <span class="n">f</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_consolidate_inplace</span><span class="p">()</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span> <span class="k">if</span> <span class="n">inplace</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>

        <span class="c1"># start in the axis order to eliminate too many copies</span>
        <span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="n">lrange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_LEN</span><span class="p">):</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">axes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_NAMES</span><span class="p">[</span><span class="n">axis</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">_get_rename_function</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

            <span class="n">baxis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_block_manager_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">level</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">level</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span><span class="o">.</span><span class="n">_get_level_number</span><span class="p">(</span><span class="n">level</span><span class="p">)</span>
            <span class="n">result</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">rename_axis</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">baxis</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span>
                                                    <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">)</span>
            <span class="n">result</span><span class="o">.</span><span class="n">_clear_item_cache</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_inplace</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="n">rename</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">_shared_docs</span><span class="p">[</span><span class="s1">&#39;rename&#39;</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">rename_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mapper</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Alter the name of the index or columns.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mapper : scalar, list-like, optional</span>
<span class="sd">            Value to set the axis name attribute.</span>
<span class="sd">        axis : int or string, default 0</span>
<span class="sd">        copy : boolean, default True</span>
<span class="sd">            Also copy underlying data</span>
<span class="sd">        inplace : boolean, default False</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        renamed : type of caller or None if inplace=True</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Prior to version 0.21.0, ``rename_axis`` could also be used to change</span>
<span class="sd">        the axis *labels* by passing a mapping or scalar. This behavior is</span>
<span class="sd">        deprecated and will be removed in a future version. Use ``rename``</span>
<span class="sd">        instead.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        pandas.Series.rename, pandas.DataFrame.rename</span>
<span class="sd">        pandas.Index.rename</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&quot;A&quot;: [1, 2, 3], &quot;B&quot;: [4, 5, 6]})</span>
<span class="sd">        &gt;&gt;&gt; df.rename_axis(&quot;foo&quot;)</span>
<span class="sd">             A  B</span>
<span class="sd">        foo</span>
<span class="sd">        0    1  4</span>
<span class="sd">        1    2  5</span>
<span class="sd">        2    3  6</span>

<span class="sd">        &gt;&gt;&gt; df.rename_axis(&quot;bar&quot;, axis=&quot;columns&quot;)</span>
<span class="sd">        bar  A  B</span>
<span class="sd">        0    1  4</span>
<span class="sd">        1    2  5</span>
<span class="sd">        2    3  6</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">inplace</span> <span class="o">=</span> <span class="n">validate_bool_kwarg</span><span class="p">(</span><span class="n">inplace</span><span class="p">,</span> <span class="s1">&#39;inplace&#39;</span><span class="p">)</span>
        <span class="n">non_mapper</span> <span class="o">=</span> <span class="n">is_scalar</span><span class="p">(</span><span class="n">mapper</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">is_list_like</span><span class="p">(</span><span class="n">mapper</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span>
                                           <span class="n">is_dict_like</span><span class="p">(</span><span class="n">mapper</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">non_mapper</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_axis_name</span><span class="p">(</span><span class="n">mapper</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Using &#39;rename_axis&#39; to alter labels is deprecated. &quot;</span>
                   <span class="s2">&quot;Use &#39;.rename&#39; instead&quot;</span><span class="p">)</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="ne">FutureWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_name</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
            <span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;copy&#39;</span><span class="p">:</span> <span class="n">copy</span><span class="p">,</span> <span class="s1">&#39;inplace&#39;</span><span class="p">:</span> <span class="n">inplace</span><span class="p">}</span>
            <span class="n">d</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapper</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="o">**</span><span class="n">d</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_axis_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Alter the name or names of the axis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name : str or list of str</span>
<span class="sd">            Name for the Index, or list of names for the MultiIndex</span>
<span class="sd">        axis : int or str</span>
<span class="sd">           0 or &#39;index&#39; for the index; 1 or &#39;columns&#39; for the columns</span>
<span class="sd">        inplace : bool</span>
<span class="sd">            whether to modify `self` directly or return a copy</span>

<span class="sd">            .. versionadded: 0.21.0</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        renamed : type of caller or None if inplace=True</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        pandas.DataFrame.rename</span>
<span class="sd">        pandas.Series.rename</span>
<span class="sd">        pandas.Index.rename</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df._set_axis_name(&quot;foo&quot;)</span>
<span class="sd">             A</span>
<span class="sd">        foo</span>
<span class="sd">        0    1</span>
<span class="sd">        1    2</span>
<span class="sd">        2    3</span>
<span class="sd">        &gt;&gt;&gt; df.index = pd.MultiIndex.from_product([[&#39;A&#39;], [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]])</span>
<span class="sd">        &gt;&gt;&gt; df._set_axis_name([&quot;bar&quot;, &quot;baz&quot;])</span>
<span class="sd">                 A</span>
<span class="sd">        bar baz</span>
<span class="sd">        A   a    1</span>
<span class="sd">            b    2</span>
<span class="sd">            c    3</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span><span class="o">.</span><span class="n">set_names</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

        <span class="n">inplace</span> <span class="o">=</span> <span class="n">validate_bool_kwarg</span><span class="p">(</span><span class="n">inplace</span><span class="p">,</span> <span class="s1">&#39;inplace&#39;</span><span class="p">)</span>
        <span class="n">renamed</span> <span class="o">=</span> <span class="bp">self</span> <span class="k">if</span> <span class="n">inplace</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">renamed</span><span class="o">.</span><span class="n">set_axis</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">renamed</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># Comparisons</span>

    <span class="k">def</span> <span class="nf">_indexed_same</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
                    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_ORDERS</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">__neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">_values_from_object</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">values</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">:</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">neg</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__array_wrap__</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__invert__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">_values_from_object</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__array_wrap__</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>

            <span class="c1"># inv fails with 0 len</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span>

            <span class="k">raise</span>

    <span class="k">def</span> <span class="nf">equals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines if two NDFrame objects contain the same elements. NaNs in</span>
<span class="sd">        the same location are considered equal.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># Iteration</span>

    <span class="k">def</span> <span class="nf">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{0!r}</span><span class="s1"> objects are mutable, thus they cannot be&#39;</span>
                        <span class="s1">&#39; hashed&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Iterate over infor axis&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_info_axis</span><span class="p">)</span>

    <span class="c1"># can we get a better explanation of this?</span>
    <span class="k">def</span> <span class="nf">keys</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the &#39;info axis&#39; (see Indexing for more)</span>

<span class="sd">        This is index for Series, columns for DataFrame and major_axis for</span>
<span class="sd">        Panel.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_info_axis</span>

    <span class="k">def</span> <span class="nf">iteritems</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Iterate over (label, values) on info axis</span>

<span class="sd">        This is index for Series, columns for DataFrame, major_axis for Panel,</span>
<span class="sd">        and so on.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_info_axis</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">h</span><span class="p">,</span> <span class="bp">self</span><span class="p">[</span><span class="n">h</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns length of info axis&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_info_axis</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if the key is in the info axis&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_info_axis</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">empty</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if NDFrame is entirely empty [no items], meaning any of the</span>
<span class="sd">        axes are of length 0.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If NDFrame contains only NaNs, it is still not considered empty. See</span>
<span class="sd">        the example below.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        An example of an actual empty DataFrame. Notice the index is empty:</span>

<span class="sd">        &gt;&gt;&gt; df_empty = pd.DataFrame({&#39;A&#39; : []})</span>
<span class="sd">        &gt;&gt;&gt; df_empty</span>
<span class="sd">        Empty DataFrame</span>
<span class="sd">        Columns: [A]</span>
<span class="sd">        Index: []</span>
<span class="sd">        &gt;&gt;&gt; df_empty.empty</span>
<span class="sd">        True</span>

<span class="sd">        If we only have NaNs in our DataFrame, it is not considered empty! We</span>
<span class="sd">        will need to drop the NaNs to make the DataFrame empty:</span>

<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;A&#39; : [np.nan]})</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">            A</span>
<span class="sd">        0 NaN</span>
<span class="sd">        &gt;&gt;&gt; df.empty</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; df.dropna().empty</span>
<span class="sd">        True</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        pandas.Series.dropna</span>
<span class="sd">        pandas.DataFrame.dropna</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">any</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">a</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_ORDERS</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__nonzero__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The truth value of a </span><span class="si">{0}</span><span class="s2"> is ambiguous. &quot;</span>
                         <span class="s2">&quot;Use a.empty, a.bool(), a.item(), a.any() or a.all().&quot;</span>
                         <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>

    <span class="fm">__bool__</span> <span class="o">=</span> <span class="n">__nonzero__</span>

    <span class="k">def</span> <span class="nf">bool</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the bool of a single element PandasObject.</span>

<span class="sd">        This must be a boolean scalar value, either True or False.  Raise a</span>
<span class="sd">        ValueError if the PandasObject does not have exactly 1 element, or that</span>
<span class="sd">        element is not boolean</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="p">(</span><span class="nb">bool</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">)):</span>
            <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">is_scalar</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;bool cannot act on a non-boolean single element &quot;</span>
                             <span class="s2">&quot;</span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__nonzero__</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__abs__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">abs</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__round__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">decimals</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">decimals</span><span class="p">)</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># Array Interface</span>

    <span class="k">def</span> <span class="nf">__array__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_values_from_object</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__array_wrap__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_construct_axes_dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_ORDERS</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="o">**</span><span class="n">d</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="c1"># ideally we would define this to avoid the getattr checks, but</span>
    <span class="c1"># is slower</span>
    <span class="c1"># @property</span>
    <span class="c1"># def __array_interface__(self):</span>
    <span class="c1">#    &quot;&quot;&quot; provide numpy array interface method &quot;&quot;&quot;</span>
    <span class="c1">#    values = self.values</span>
    <span class="c1">#    return dict(typestr=values.dtype.str,shape=values.shape,data=values)</span>

    <span class="k">def</span> <span class="nf">to_dense</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return dense representation of NDFrame (as opposed to sparse)&quot;&quot;&quot;</span>
        <span class="c1"># compat</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># Picklability</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">meta</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">k</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_metadata</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">_data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">_typ</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_typ</span><span class="p">,</span> <span class="n">_metadata</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_metadata</span><span class="p">,</span>
                    <span class="o">**</span><span class="n">meta</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">BlockManager</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">state</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">typ</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;_typ&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">typ</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

                <span class="c1"># set in the order of internal names</span>
                <span class="c1"># to avoid definitional recursion</span>
                <span class="c1"># e.g. say fill_value needing _data to be</span>
                <span class="c1"># defined</span>
                <span class="n">meta</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_internal_names</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_metadata</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">meta</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">state</span><span class="p">:</span>
                        <span class="n">v</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                        <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">state</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">meta</span><span class="p">:</span>
                        <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_unpickle_series_compat</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">state</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_unpickle_sparse_frame_compat</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_unpickle_frame_compat</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_unpickle_panel_compat</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_unpickle_series_compat</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
            <span class="c1"># old pickling format, for compatibility</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_unpickle_matrix_compat</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_item_cache</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># IO</span>

    <span class="k">def</span> <span class="nf">_repr_latex_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a LaTeX representation for a particular object.</span>
<span class="sd">        Mainly for use with nbconvert (jupyter notebook conversion to pdf).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">config</span><span class="o">.</span><span class="n">get_option</span><span class="p">(</span><span class="s1">&#39;display.latex.repr&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_latex</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># I/O Methods</span>

    <span class="n">_shared_docs</span><span class="p">[</span><span class="s1">&#39;to_excel&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    Write </span><span class="si">%(klass)s</span><span class="s2"> to an excel sheet</span>
<span class="s2">    </span><span class="si">%(versionadded_to_excel)s</span><span class="s2"></span>

<span class="s2">    Parameters</span>
<span class="s2">    ----------</span>
<span class="s2">    excel_writer : string or ExcelWriter object</span>
<span class="s2">        File path or existing ExcelWriter</span>
<span class="s2">    sheet_name : string, default &#39;Sheet1&#39;</span>
<span class="s2">        Name of sheet which will contain DataFrame</span>
<span class="s2">    na_rep : string, default &#39;&#39;</span>
<span class="s2">        Missing data representation</span>
<span class="s2">    float_format : string, default None</span>
<span class="s2">        Format string for floating point numbers</span>
<span class="s2">    columns : sequence, optional</span>
<span class="s2">        Columns to write</span>
<span class="s2">    header : boolean or list of string, default True</span>
<span class="s2">        Write out the column names. If a list of strings is given it is</span>
<span class="s2">        assumed to be aliases for the column names</span>
<span class="s2">    index : boolean, default True</span>
<span class="s2">        Write row names (index)</span>
<span class="s2">    index_label : string or sequence, default None</span>
<span class="s2">        Column label for index column(s) if desired. If None is given, and</span>
<span class="s2">        `header` and `index` are True, then the index names are used. A</span>
<span class="s2">        sequence should be given if the DataFrame uses MultiIndex.</span>
<span class="s2">    startrow :</span>
<span class="s2">        upper left cell row to dump data frame</span>
<span class="s2">    startcol :</span>
<span class="s2">        upper left cell column to dump data frame</span>
<span class="s2">    engine : string, default None</span>
<span class="s2">        write engine to use - you can also set this via the options</span>
<span class="s2">        ``io.excel.xlsx.writer``, ``io.excel.xls.writer``, and</span>
<span class="s2">        ``io.excel.xlsm.writer``.</span>
<span class="s2">    merge_cells : boolean, default True</span>
<span class="s2">        Write MultiIndex and Hierarchical Rows as merged cells.</span>
<span class="s2">    encoding: string, default None</span>
<span class="s2">        encoding of the resulting excel file. Only necessary for xlwt,</span>
<span class="s2">        other writers support unicode natively.</span>
<span class="s2">    inf_rep : string, default &#39;inf&#39;</span>
<span class="s2">        Representation for infinity (there is no native representation for</span>
<span class="s2">        infinity in Excel)</span>
<span class="s2">    freeze_panes : tuple of integer (length 2), default None</span>
<span class="s2">        Specifies the one-based bottommost row and rightmost column that</span>
<span class="s2">        is to be frozen</span>

<span class="s2">        .. versionadded:: 0.20.0</span>

<span class="s2">    Notes</span>
<span class="s2">    -----</span>
<span class="s2">    If passing an existing ExcelWriter object, then the sheet will be added</span>
<span class="s2">    to the existing workbook.  This can be used to save different</span>
<span class="s2">    DataFrames to one workbook:</span>

<span class="s2">    &gt;&gt;&gt; writer = pd.ExcelWriter(&#39;output.xlsx&#39;)</span>
<span class="s2">    &gt;&gt;&gt; df1.to_excel(writer,&#39;Sheet1&#39;)</span>
<span class="s2">    &gt;&gt;&gt; df2.to_excel(writer,&#39;Sheet2&#39;)</span>
<span class="s2">    &gt;&gt;&gt; writer.save()</span>

<span class="s2">    For compatibility with to_csv, to_excel serializes lists and dicts to</span>
<span class="s2">    strings before writing.</span>
<span class="s2">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">to_json</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path_or_buf</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">orient</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">date_format</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">double_precision</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">force_ascii</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">date_unit</span><span class="o">=</span><span class="s1">&#39;ms&#39;</span><span class="p">,</span>
                <span class="n">default_handler</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">lines</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">compression</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert the object to a JSON string.</span>

<span class="sd">        Note NaN&#39;s and None will be converted to null and datetime objects</span>
<span class="sd">        will be converted to UNIX timestamps.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path_or_buf : the path or buffer to write the result string</span>
<span class="sd">            if this is None, return the converted string</span>
<span class="sd">        orient : string</span>

<span class="sd">            * Series</span>

<span class="sd">              - default is &#39;index&#39;</span>
<span class="sd">              - allowed values are: {&#39;split&#39;,&#39;records&#39;,&#39;index&#39;}</span>

<span class="sd">            * DataFrame</span>

<span class="sd">              - default is &#39;columns&#39;</span>
<span class="sd">              - allowed values are:</span>
<span class="sd">                {&#39;split&#39;,&#39;records&#39;,&#39;index&#39;,&#39;columns&#39;,&#39;values&#39;}</span>

<span class="sd">            * The format of the JSON string</span>

<span class="sd">              - split : dict like</span>
<span class="sd">                {index -&gt; [index], columns -&gt; [columns], data -&gt; [values]}</span>
<span class="sd">              - records : list like</span>
<span class="sd">                [{column -&gt; value}, ... , {column -&gt; value}]</span>
<span class="sd">              - index : dict like {index -&gt; {column -&gt; value}}</span>
<span class="sd">              - columns : dict like {column -&gt; {index -&gt; value}}</span>
<span class="sd">              - values : just the values array</span>
<span class="sd">              - table : dict like {&#39;schema&#39;: {schema}, &#39;data&#39;: {data}}</span>
<span class="sd">                describing the data, and the data component is</span>
<span class="sd">                like ``orient=&#39;records&#39;``.</span>

<span class="sd">                .. versionchanged:: 0.20.0</span>

<span class="sd">        date_format : {None, &#39;epoch&#39;, &#39;iso&#39;}</span>
<span class="sd">            Type of date conversion. `epoch` = epoch milliseconds,</span>
<span class="sd">            `iso` = ISO8601. The default depends on the `orient`. For</span>
<span class="sd">            `orient=&#39;table&#39;`, the default is `&#39;iso&#39;`. For all other orients,</span>
<span class="sd">            the default is `&#39;epoch&#39;`.</span>
<span class="sd">        double_precision : The number of decimal places to use when encoding</span>
<span class="sd">            floating point values, default 10.</span>
<span class="sd">        force_ascii : force encoded string to be ASCII, default True.</span>
<span class="sd">        date_unit : string, default &#39;ms&#39; (milliseconds)</span>
<span class="sd">            The time unit to encode to, governs timestamp and ISO8601</span>
<span class="sd">            precision.  One of &#39;s&#39;, &#39;ms&#39;, &#39;us&#39;, &#39;ns&#39; for second, millisecond,</span>
<span class="sd">            microsecond, and nanosecond respectively.</span>
<span class="sd">        default_handler : callable, default None</span>
<span class="sd">            Handler to call if object cannot otherwise be converted to a</span>
<span class="sd">            suitable format for JSON. Should receive a single argument which is</span>
<span class="sd">            the object to convert and return a serialisable object.</span>
<span class="sd">        lines : boolean, default False</span>
<span class="sd">            If &#39;orient&#39; is &#39;records&#39; write out line delimited json format. Will</span>
<span class="sd">            throw ValueError if incorrect &#39;orient&#39; since others are not list</span>
<span class="sd">            like.</span>

<span class="sd">            .. versionadded:: 0.19.0</span>

<span class="sd">        compression : {None, &#39;gzip&#39;, &#39;bz2&#39;, &#39;xz&#39;}</span>
<span class="sd">            A string representing the compression to use in the output file,</span>
<span class="sd">            only used when the first argument is a filename</span>

<span class="sd">            .. versionadded:: 0.21.0</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        same type as input object with filtered info axis</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        pd.read_json</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame([[&#39;a&#39;, &#39;b&#39;], [&#39;c&#39;, &#39;d&#39;]],</span>
<span class="sd">        ...                   index=[&#39;row 1&#39;, &#39;row 2&#39;],</span>
<span class="sd">        ...                   columns=[&#39;col 1&#39;, &#39;col 2&#39;])</span>
<span class="sd">        &gt;&gt;&gt; df.to_json(orient=&#39;split&#39;)</span>
<span class="sd">        &#39;{&quot;columns&quot;:[&quot;col 1&quot;,&quot;col 2&quot;],</span>
<span class="sd">          &quot;index&quot;:[&quot;row 1&quot;,&quot;row 2&quot;],</span>
<span class="sd">          &quot;data&quot;:[[&quot;a&quot;,&quot;b&quot;],[&quot;c&quot;,&quot;d&quot;]]}&#39;</span>

<span class="sd">        Encoding/decoding a Dataframe using ``&#39;index&#39;`` formatted JSON:</span>

<span class="sd">        &gt;&gt;&gt; df.to_json(orient=&#39;index&#39;)</span>
<span class="sd">        &#39;{&quot;row 1&quot;:{&quot;col 1&quot;:&quot;a&quot;,&quot;col 2&quot;:&quot;b&quot;},&quot;row 2&quot;:{&quot;col 1&quot;:&quot;c&quot;,&quot;col 2&quot;:&quot;d&quot;}}&#39;</span>

<span class="sd">        Encoding/decoding a Dataframe using ``&#39;records&#39;`` formatted JSON.</span>
<span class="sd">        Note that index labels are not preserved with this encoding.</span>

<span class="sd">        &gt;&gt;&gt; df.to_json(orient=&#39;records&#39;)</span>
<span class="sd">        &#39;[{&quot;col 1&quot;:&quot;a&quot;,&quot;col 2&quot;:&quot;b&quot;},{&quot;col 1&quot;:&quot;c&quot;,&quot;col 2&quot;:&quot;d&quot;}]&#39;</span>

<span class="sd">        Encoding with Table Schema</span>

<span class="sd">        &gt;&gt;&gt; df.to_json(orient=&#39;table&#39;)</span>
<span class="sd">        &#39;{&quot;schema&quot;: {&quot;fields&quot;: [{&quot;name&quot;: &quot;index&quot;, &quot;type&quot;: &quot;string&quot;},</span>
<span class="sd">                                {&quot;name&quot;: &quot;col 1&quot;, &quot;type&quot;: &quot;string&quot;},</span>
<span class="sd">                                {&quot;name&quot;: &quot;col 2&quot;, &quot;type&quot;: &quot;string&quot;}],</span>
<span class="sd">                     &quot;primaryKey&quot;: &quot;index&quot;,</span>
<span class="sd">                     &quot;pandas_version&quot;: &quot;0.20.0&quot;},</span>
<span class="sd">          &quot;data&quot;: [{&quot;index&quot;: &quot;row 1&quot;, &quot;col 1&quot;: &quot;a&quot;, &quot;col 2&quot;: &quot;b&quot;},</span>
<span class="sd">                   {&quot;index&quot;: &quot;row 2&quot;, &quot;col 1&quot;: &quot;c&quot;, &quot;col 2&quot;: &quot;d&quot;}]}&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="kn">from</span> <span class="nn">pandas.io</span> <span class="k">import</span> <span class="n">json</span>
        <span class="k">if</span> <span class="n">date_format</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">orient</span> <span class="o">==</span> <span class="s1">&#39;table&#39;</span><span class="p">:</span>
            <span class="n">date_format</span> <span class="o">=</span> <span class="s1">&#39;iso&#39;</span>
        <span class="k">elif</span> <span class="n">date_format</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">date_format</span> <span class="o">=</span> <span class="s1">&#39;epoch&#39;</span>
        <span class="k">return</span> <span class="n">json</span><span class="o">.</span><span class="n">to_json</span><span class="p">(</span><span class="n">path_or_buf</span><span class="o">=</span><span class="n">path_or_buf</span><span class="p">,</span> <span class="n">obj</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">orient</span><span class="o">=</span><span class="n">orient</span><span class="p">,</span>
                            <span class="n">date_format</span><span class="o">=</span><span class="n">date_format</span><span class="p">,</span>
                            <span class="n">double_precision</span><span class="o">=</span><span class="n">double_precision</span><span class="p">,</span>
                            <span class="n">force_ascii</span><span class="o">=</span><span class="n">force_ascii</span><span class="p">,</span> <span class="n">date_unit</span><span class="o">=</span><span class="n">date_unit</span><span class="p">,</span>
                            <span class="n">default_handler</span><span class="o">=</span><span class="n">default_handler</span><span class="p">,</span>
                            <span class="n">lines</span><span class="o">=</span><span class="n">lines</span><span class="p">,</span> <span class="n">compression</span><span class="o">=</span><span class="n">compression</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_hdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path_or_buf</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Write the contained data to an HDF5 file using HDFStore.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path_or_buf : the path (string) or HDFStore object</span>
<span class="sd">        key : string</span>
<span class="sd">            identifier for the group in the store</span>
<span class="sd">        mode : optional, {&#39;a&#39;, &#39;w&#39;, &#39;r+&#39;}, default &#39;a&#39;</span>

<span class="sd">          ``&#39;w&#39;``</span>
<span class="sd">              Write; a new file is created (an existing file with the same</span>
<span class="sd">              name would be deleted).</span>
<span class="sd">          ``&#39;a&#39;``</span>
<span class="sd">              Append; an existing file is opened for reading and writing,</span>
<span class="sd">              and if the file does not exist it is created.</span>
<span class="sd">          ``&#39;r+&#39;``</span>
<span class="sd">              It is similar to ``&#39;a&#39;``, but the file must already exist.</span>
<span class="sd">        format : &#39;fixed(f)|table(t)&#39;, default is &#39;fixed&#39;</span>
<span class="sd">            fixed(f) : Fixed format</span>
<span class="sd">                       Fast writing/reading. Not-appendable, nor searchable</span>
<span class="sd">            table(t) : Table format</span>
<span class="sd">                       Write as a PyTables Table structure which may perform</span>
<span class="sd">                       worse but allow more flexible operations like searching</span>
<span class="sd">                       / selecting subsets of the data</span>
<span class="sd">        append : boolean, default False</span>
<span class="sd">            For Table formats, append the input data to the existing</span>
<span class="sd">        data_columns :  list of columns, or True, default None</span>
<span class="sd">            List of columns to create as indexed data columns for on-disk</span>
<span class="sd">            queries, or True to use all columns. By default only the axes</span>
<span class="sd">            of the object are indexed. See `here</span>
<span class="sd">            &lt;http://pandas.pydata.org/pandas-docs/stable/io.html#query-via-data-columns&gt;`__.</span>

<span class="sd">            Applicable only to format=&#39;table&#39;.</span>
<span class="sd">        complevel : int, 0-9, default None</span>
<span class="sd">            Specifies a compression level for data.</span>
<span class="sd">            A value of 0 disables compression.</span>
<span class="sd">        complib : {&#39;zlib&#39;, &#39;lzo&#39;, &#39;bzip2&#39;, &#39;blosc&#39;}, default &#39;zlib&#39;</span>
<span class="sd">            Specifies the compression library to be used.</span>
<span class="sd">            As of v0.20.2 these additional compressors for Blosc are supported</span>
<span class="sd">            (default if no compressor specified: &#39;blosc:blosclz&#39;):</span>
<span class="sd">            {&#39;blosc:blosclz&#39;, &#39;blosc:lz4&#39;, &#39;blosc:lz4hc&#39;, &#39;blosc:snappy&#39;,</span>
<span class="sd">            &#39;blosc:zlib&#39;, &#39;blosc:zstd&#39;}.</span>
<span class="sd">            Specifying a compression library which is not available issues</span>
<span class="sd">            a ValueError.</span>
<span class="sd">        fletcher32 : bool, default False</span>
<span class="sd">            If applying compression use the fletcher32 checksum</span>
<span class="sd">        dropna : boolean, default False.</span>
<span class="sd">            If true, ALL nan rows will not be written to store.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="kn">from</span> <span class="nn">pandas.io</span> <span class="k">import</span> <span class="n">pytables</span>
        <span class="k">return</span> <span class="n">pytables</span><span class="o">.</span><span class="n">to_hdf</span><span class="p">(</span><span class="n">path_or_buf</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_msgpack</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path_or_buf</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s1">&#39;utf-8&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        msgpack (serialize) object to input file path</span>

<span class="sd">        THIS IS AN EXPERIMENTAL LIBRARY and the storage format</span>
<span class="sd">        may not be stable until a future release.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path : string File path, buffer-like, or None</span>
<span class="sd">            if None, return generated string</span>
<span class="sd">        append : boolean whether to append to an existing msgpack</span>
<span class="sd">            (default is False)</span>
<span class="sd">        compress : type of compressor (zlib or blosc), default to None (no</span>
<span class="sd">            compression)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="kn">from</span> <span class="nn">pandas.io</span> <span class="k">import</span> <span class="n">packers</span>
        <span class="k">return</span> <span class="n">packers</span><span class="o">.</span><span class="n">to_msgpack</span><span class="p">(</span><span class="n">path_or_buf</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="n">encoding</span><span class="p">,</span>
                                  <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_sql</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">con</span><span class="p">,</span> <span class="n">flavor</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">schema</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">if_exists</span><span class="o">=</span><span class="s1">&#39;fail&#39;</span><span class="p">,</span>
               <span class="n">index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">index_label</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">chunksize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write records stored in a DataFrame to a SQL database.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name : string</span>
<span class="sd">            Name of SQL table</span>
<span class="sd">        con : SQLAlchemy engine or DBAPI2 connection (legacy mode)</span>
<span class="sd">            Using SQLAlchemy makes it possible to use any DB supported by that</span>
<span class="sd">            library. If a DBAPI2 object, only sqlite3 is supported.</span>
<span class="sd">        flavor : &#39;sqlite&#39;, default None</span>
<span class="sd">            .. deprecated:: 0.19.0</span>
<span class="sd">               &#39;sqlite&#39; is the only supported option if SQLAlchemy is not</span>
<span class="sd">               used.</span>
<span class="sd">        schema : string, default None</span>
<span class="sd">            Specify the schema (if database flavor supports this). If None, use</span>
<span class="sd">            default schema.</span>
<span class="sd">        if_exists : {&#39;fail&#39;, &#39;replace&#39;, &#39;append&#39;}, default &#39;fail&#39;</span>
<span class="sd">            - fail: If table exists, do nothing.</span>
<span class="sd">            - replace: If table exists, drop it, recreate it, and insert data.</span>
<span class="sd">            - append: If table exists, insert data. Create if does not exist.</span>
<span class="sd">        index : boolean, default True</span>
<span class="sd">            Write DataFrame index as a column.</span>
<span class="sd">        index_label : string or sequence, default None</span>
<span class="sd">            Column label for index column(s). If None is given (default) and</span>
<span class="sd">            `index` is True, then the index names are used.</span>
<span class="sd">            A sequence should be given if the DataFrame uses MultiIndex.</span>
<span class="sd">        chunksize : int, default None</span>
<span class="sd">            If not None, then rows will be written in batches of this size at a</span>
<span class="sd">            time.  If None, all rows will be written at once.</span>
<span class="sd">        dtype : dict of column name to SQL type, default None</span>
<span class="sd">            Optional specifying the datatype for columns. The SQL type should</span>
<span class="sd">            be a SQLAlchemy type, or a string for sqlite3 fallback connection.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas.io</span> <span class="k">import</span> <span class="n">sql</span>
        <span class="n">sql</span><span class="o">.</span><span class="n">to_sql</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">con</span><span class="p">,</span> <span class="n">flavor</span><span class="o">=</span><span class="n">flavor</span><span class="p">,</span> <span class="n">schema</span><span class="o">=</span><span class="n">schema</span><span class="p">,</span>
                   <span class="n">if_exists</span><span class="o">=</span><span class="n">if_exists</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">index_label</span><span class="o">=</span><span class="n">index_label</span><span class="p">,</span>
                   <span class="n">chunksize</span><span class="o">=</span><span class="n">chunksize</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_pickle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">compression</span><span class="o">=</span><span class="s1">&#39;infer&#39;</span><span class="p">,</span>
                  <span class="n">protocol</span><span class="o">=</span><span class="n">pkl</span><span class="o">.</span><span class="n">HIGHEST_PROTOCOL</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pickle (serialize) object to input file path.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path : string</span>
<span class="sd">            File path</span>
<span class="sd">        compression : {&#39;infer&#39;, &#39;gzip&#39;, &#39;bz2&#39;, &#39;xz&#39;, None}, default &#39;infer&#39;</span>
<span class="sd">            a string representing the compression to use in the output file</span>

<span class="sd">            .. versionadded:: 0.20.0</span>
<span class="sd">        protocol : int</span>
<span class="sd">            Int which indicates which protocol should be used by the pickler,</span>
<span class="sd">            default HIGHEST_PROTOCOL (see [1], paragraph 12.1.2). The possible</span>
<span class="sd">            values for this parameter depend on the version of Python. For</span>
<span class="sd">            Python 2.x, possible values are 0, 1, 2. For Python&gt;=3.0, 3 is a</span>
<span class="sd">            valid value. For Python &gt;= 3.4, 4 is a valid value.A negative value</span>
<span class="sd">            for the protocol parameter is equivalent to setting its value to</span>
<span class="sd">            HIGHEST_PROTOCOL.</span>

<span class="sd">            .. [1] https://docs.python.org/3/library/pickle.html</span>
<span class="sd">            .. versionadded:: 0.21.0</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas.io.pickle</span> <span class="k">import</span> <span class="n">to_pickle</span>
        <span class="k">return</span> <span class="n">to_pickle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">compression</span><span class="o">=</span><span class="n">compression</span><span class="p">,</span>
                         <span class="n">protocol</span><span class="o">=</span><span class="n">protocol</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_clipboard</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">excel</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Attempt to write text representation of object to the system clipboard</span>
<span class="sd">        This can be pasted into Excel, for example.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        excel : boolean, defaults to True</span>
<span class="sd">                if True, use the provided separator, writing in a csv</span>
<span class="sd">                format for allowing easy pasting into excel.</span>
<span class="sd">                if False, write a string representation of the object</span>
<span class="sd">                to the clipboard</span>
<span class="sd">        sep : optional, defaults to tab</span>
<span class="sd">        other keywords are passed to to_csv</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Requirements for your platform</span>
<span class="sd">          - Linux: xclip, or xsel (with gtk or PyQt4 modules)</span>
<span class="sd">          - Windows: none</span>
<span class="sd">          - OS X: none</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas.io</span> <span class="k">import</span> <span class="n">clipboards</span>
        <span class="n">clipboards</span><span class="o">.</span><span class="n">to_clipboard</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">excel</span><span class="o">=</span><span class="n">excel</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="n">sep</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_xarray</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an xarray object from the pandas object.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        a DataArray for a Series</span>
<span class="sd">        a Dataset for a DataFrame</span>
<span class="sd">        a DataArray for higher dims</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;A&#39; : [1, 1, 2],</span>
<span class="sd">                               &#39;B&#39; : [&#39;foo&#39;, &#39;bar&#39;, &#39;foo&#39;],</span>
<span class="sd">                               &#39;C&#39; : np.arange(4.,7)})</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">           A    B    C</span>
<span class="sd">        0  1  foo  4.0</span>
<span class="sd">        1  1  bar  5.0</span>
<span class="sd">        2  2  foo  6.0</span>

<span class="sd">        &gt;&gt;&gt; df.to_xarray()</span>
<span class="sd">        &lt;xarray.Dataset&gt;</span>
<span class="sd">        Dimensions:  (index: 3)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * index    (index) int64 0 1 2</span>
<span class="sd">        Data variables:</span>
<span class="sd">            A        (index) int64 1 1 2</span>
<span class="sd">            B        (index) object &#39;foo&#39; &#39;bar&#39; &#39;foo&#39;</span>
<span class="sd">            C        (index) float64 4.0 5.0 6.0</span>

<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;A&#39; : [1, 1, 2],</span>
<span class="sd">                               &#39;B&#39; : [&#39;foo&#39;, &#39;bar&#39;, &#39;foo&#39;],</span>
<span class="sd">                               &#39;C&#39; : np.arange(4.,7)}</span>
<span class="sd">                             ).set_index([&#39;B&#39;,&#39;A&#39;])</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">                 C</span>
<span class="sd">        B   A</span>
<span class="sd">        foo 1  4.0</span>
<span class="sd">        bar 1  5.0</span>
<span class="sd">        foo 2  6.0</span>

<span class="sd">        &gt;&gt;&gt; df.to_xarray()</span>
<span class="sd">        &lt;xarray.Dataset&gt;</span>
<span class="sd">        Dimensions:  (A: 2, B: 2)</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * B        (B) object &#39;bar&#39; &#39;foo&#39;</span>
<span class="sd">          * A        (A) int64 1 2</span>
<span class="sd">        Data variables:</span>
<span class="sd">            C        (B, A) float64 5.0 nan 4.0 6.0</span>

<span class="sd">        &gt;&gt;&gt; p = pd.Panel(np.arange(24).reshape(4,3,2),</span>
<span class="sd">                         items=list(&#39;ABCD&#39;),</span>
<span class="sd">                         major_axis=pd.date_range(&#39;20130101&#39;, periods=3),</span>
<span class="sd">                         minor_axis=[&#39;first&#39;, &#39;second&#39;])</span>
<span class="sd">        &gt;&gt;&gt; p</span>
<span class="sd">        &lt;class &#39;pandas.core.panel.Panel&#39;&gt;</span>
<span class="sd">        Dimensions: 4 (items) x 3 (major_axis) x 2 (minor_axis)</span>
<span class="sd">        Items axis: A to D</span>
<span class="sd">        Major_axis axis: 2013-01-01 00:00:00 to 2013-01-03 00:00:00</span>
<span class="sd">        Minor_axis axis: first to second</span>

<span class="sd">        &gt;&gt;&gt; p.to_xarray()</span>
<span class="sd">        &lt;xarray.DataArray (items: 4, major_axis: 3, minor_axis: 2)&gt;</span>
<span class="sd">        array([[[ 0,  1],</span>
<span class="sd">                [ 2,  3],</span>
<span class="sd">                [ 4,  5]],</span>
<span class="sd">               [[ 6,  7],</span>
<span class="sd">                [ 8,  9],</span>
<span class="sd">                [10, 11]],</span>
<span class="sd">               [[12, 13],</span>
<span class="sd">                [14, 15],</span>
<span class="sd">                [16, 17]],</span>
<span class="sd">               [[18, 19],</span>
<span class="sd">                [20, 21],</span>
<span class="sd">                [22, 23]]])</span>
<span class="sd">        Coordinates:</span>
<span class="sd">          * items       (items) object &#39;A&#39; &#39;B&#39; &#39;C&#39; &#39;D&#39;</span>
<span class="sd">          * major_axis  (major_axis) datetime64[ns] 2013-01-01 2013-01-02 2013-01-03  # noqa</span>
<span class="sd">          * minor_axis  (minor_axis) object &#39;first&#39; &#39;second&#39;</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        See the `xarray docs &lt;http://xarray.pydata.org/en/stable/&gt;`__</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">xarray</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
            <span class="c1"># Give a nice error message</span>
            <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s2">&quot;the xarray library is not installed</span><span class="se">\n</span><span class="s2">&quot;</span>
                              <span class="s2">&quot;you can install via conda</span><span class="se">\n</span><span class="s2">&quot;</span>
                              <span class="s2">&quot;conda install xarray</span><span class="se">\n</span><span class="s2">&quot;</span>
                              <span class="s2">&quot;or via pip</span><span class="se">\n</span><span class="s2">&quot;</span>
                              <span class="s2">&quot;pip install xarray</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">xarray</span><span class="o">.</span><span class="n">DataArray</span><span class="o">.</span><span class="n">from_series</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">xarray</span><span class="o">.</span><span class="n">Dataset</span><span class="o">.</span><span class="n">from_dataframe</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c1"># &gt; 2 dims</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="p">[(</span><span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">a</span><span class="p">))</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_ORDERS</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">xarray</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                <span class="n">coords</span><span class="o">=</span><span class="n">coords</span><span class="p">,</span>
                                <span class="p">)</span>

    <span class="n">_shared_docs</span><span class="p">[</span><span class="s1">&#39;to_latex&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        Render an object to a tabular environment table. You can splice</span>
<span class="s2">        this into a LaTeX document. Requires \\usepackage</span><span class="si">{booktabs}</span><span class="s2">.</span>

<span class="s2">        .. versionchanged:: 0.20.2</span>
<span class="s2">           Added to Series</span>

<span class="s2">        `to_latex`-specific options:</span>

<span class="s2">        bold_rows : boolean, default False</span>
<span class="s2">            Make the row labels bold in the output</span>
<span class="s2">        column_format : str, default None</span>
<span class="s2">            The columns format as specified in `LaTeX table format</span>
<span class="s2">            &lt;https://en.wikibooks.org/wiki/LaTeX/Tables&gt;`__ e.g &#39;rcl&#39; for 3</span>
<span class="s2">            columns</span>
<span class="s2">        longtable : boolean, default will be read from the pandas config module</span>
<span class="s2">            Default: False.</span>
<span class="s2">            Use a longtable environment instead of tabular. Requires adding</span>
<span class="s2">            a \\usepackage</span><span class="si">{longtable}</span><span class="s2"> to your LaTeX preamble.</span>
<span class="s2">        escape : boolean, default will be read from the pandas config module</span>
<span class="s2">            Default: True.</span>
<span class="s2">            When set to False prevents from escaping latex special</span>
<span class="s2">            characters in column names.</span>
<span class="s2">        encoding : str, default None</span>
<span class="s2">            A string representing the encoding to use in the output file,</span>
<span class="s2">            defaults to &#39;ascii&#39; on Python 2 and &#39;utf-8&#39; on Python 3.</span>
<span class="s2">        decimal : string, default &#39;.&#39;</span>
<span class="s2">            Character recognized as decimal separator, e.g. &#39;,&#39; in Europe.</span>

<span class="s2">            .. versionadded:: 0.18.0</span>

<span class="s2">        multicolumn : boolean, default True</span>
<span class="s2">            Use \multicolumn to enhance MultiIndex columns.</span>
<span class="s2">            The default will be read from the config module.</span>

<span class="s2">            .. versionadded:: 0.20.0</span>

<span class="s2">        multicolumn_format : str, default &#39;l&#39;</span>
<span class="s2">            The alignment for multicolumns, similar to `column_format`</span>
<span class="s2">            The default will be read from the config module.</span>

<span class="s2">            .. versionadded:: 0.20.0</span>

<span class="s2">        multirow : boolean, default False</span>
<span class="s2">            Use \multirow to enhance MultiIndex rows.</span>
<span class="s2">            Requires adding a \\usepackage</span><span class="si">{multirow}</span><span class="s2"> to your LaTeX preamble.</span>
<span class="s2">            Will print centered labels (instead of top-aligned)</span>
<span class="s2">            across the contained rows, separating groups via clines.</span>
<span class="s2">            The default will be read from the pandas config module.</span>

<span class="s2">            .. versionadded:: 0.20.0</span>
<span class="s2">            &quot;&quot;&quot;</span>

    <span class="nd">@Substitution</span><span class="p">(</span><span class="n">header</span><span class="o">=</span><span class="s1">&#39;Write out the column names. If a list of strings &#39;</span>
                         <span class="s1">&#39;is given, it is assumed to be aliases for the &#39;</span>
                         <span class="s1">&#39;column names.&#39;</span><span class="p">)</span>
    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s1">&#39;to_latex&#39;</span><span class="p">]</span> <span class="o">%</span> <span class="n">_shared_doc_kwargs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">to_latex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">buf</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">col_space</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">na_rep</span><span class="o">=</span><span class="s1">&#39;NaN&#39;</span><span class="p">,</span> <span class="n">formatters</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">float_format</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">sparsify</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">index_names</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">bold_rows</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">column_format</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">longtable</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">escape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">encoding</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">decimal</span><span class="o">=</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="n">multicolumn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">multicolumn_format</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">multirow</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># Get defaults from the pandas config</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_frame</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">longtable</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">longtable</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">get_option</span><span class="p">(</span><span class="s2">&quot;display.latex.longtable&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">escape</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">escape</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">get_option</span><span class="p">(</span><span class="s2">&quot;display.latex.escape&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">multicolumn</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">multicolumn</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">get_option</span><span class="p">(</span><span class="s2">&quot;display.latex.multicolumn&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">multicolumn_format</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">multicolumn_format</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">get_option</span><span class="p">(</span>
                <span class="s2">&quot;display.latex.multicolumn_format&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">multirow</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">multirow</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">get_option</span><span class="p">(</span><span class="s2">&quot;display.latex.multirow&quot;</span><span class="p">)</span>

        <span class="n">formatter</span> <span class="o">=</span> <span class="n">DataFrameFormatter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">buf</span><span class="o">=</span><span class="n">buf</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">,</span>
                                       <span class="n">col_space</span><span class="o">=</span><span class="n">col_space</span><span class="p">,</span> <span class="n">na_rep</span><span class="o">=</span><span class="n">na_rep</span><span class="p">,</span>
                                       <span class="n">header</span><span class="o">=</span><span class="n">header</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span>
                                       <span class="n">formatters</span><span class="o">=</span><span class="n">formatters</span><span class="p">,</span>
                                       <span class="n">float_format</span><span class="o">=</span><span class="n">float_format</span><span class="p">,</span>
                                       <span class="n">bold_rows</span><span class="o">=</span><span class="n">bold_rows</span><span class="p">,</span>
                                       <span class="n">sparsify</span><span class="o">=</span><span class="n">sparsify</span><span class="p">,</span>
                                       <span class="n">index_names</span><span class="o">=</span><span class="n">index_names</span><span class="p">,</span>
                                       <span class="n">escape</span><span class="o">=</span><span class="n">escape</span><span class="p">,</span> <span class="n">decimal</span><span class="o">=</span><span class="n">decimal</span><span class="p">)</span>
        <span class="n">formatter</span><span class="o">.</span><span class="n">to_latex</span><span class="p">(</span><span class="n">column_format</span><span class="o">=</span><span class="n">column_format</span><span class="p">,</span> <span class="n">longtable</span><span class="o">=</span><span class="n">longtable</span><span class="p">,</span>
                           <span class="n">encoding</span><span class="o">=</span><span class="n">encoding</span><span class="p">,</span> <span class="n">multicolumn</span><span class="o">=</span><span class="n">multicolumn</span><span class="p">,</span>
                           <span class="n">multicolumn_format</span><span class="o">=</span><span class="n">multicolumn_format</span><span class="p">,</span>
                           <span class="n">multirow</span><span class="o">=</span><span class="n">multirow</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">buf</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">formatter</span><span class="o">.</span><span class="n">buf</span><span class="o">.</span><span class="n">getvalue</span><span class="p">()</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># Fancy Indexing</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_create_indexer</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">indexer</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create an indexer like _name in the class.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">iname</span> <span class="o">=</span> <span class="s1">&#39;_</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">name</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">iname</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

            <span class="k">def</span> <span class="nf">_indexer</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="n">i</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iname</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">i</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">i</span> <span class="o">=</span> <span class="n">indexer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
                    <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iname</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">i</span>

            <span class="nb">setattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="nb">property</span><span class="p">(</span><span class="n">_indexer</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="n">indexer</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">))</span>

            <span class="c1"># add to our internal names set</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">_internal_names_set</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">iname</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get item from object for given key (DataFrame column, Panel slice,</span>
<span class="sd">        etc.). Returns default value if not found.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        key : object</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        value : type of items contained in object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">KeyError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">,</span> <span class="ne">IndexError</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">default</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_item_cache</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_item_cache</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the cached item, item represents a label indexer.&quot;&quot;&quot;</span>
        <span class="n">cache</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_item_cache</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">cache</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">res</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
            <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_box_item_values</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
            <span class="n">cache</span><span class="p">[</span><span class="n">item</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span>
            <span class="n">res</span><span class="o">.</span><span class="n">_set_as_cached</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

            <span class="c1"># for a chain</span>
            <span class="n">res</span><span class="o">.</span><span class="n">is_copy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_copy</span>
        <span class="k">return</span> <span class="n">res</span>

    <span class="k">def</span> <span class="nf">_set_as_cached</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">cacher</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the _cacher attribute on the calling object with a weakref to</span>
<span class="sd">        cacher.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cacher</span> <span class="o">=</span> <span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">weakref</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="n">cacher</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_reset_cacher</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Reset the cacher.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_cacher&#39;</span><span class="p">):</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cacher</span>

    <span class="k">def</span> <span class="nf">_iget_item_cache</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the cached item, item represents a positional indexer.&quot;&quot;&quot;</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_info_axis</span>
        <span class="k">if</span> <span class="n">ax</span><span class="o">.</span><span class="n">is_unique</span><span class="p">:</span>
            <span class="n">lower</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_item_cache</span><span class="p">(</span><span class="n">ax</span><span class="p">[</span><span class="n">item</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lower</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_take</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_info_axis_number</span><span class="p">,</span>
                               <span class="n">convert</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">lower</span>

    <span class="k">def</span> <span class="nf">_box_item_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">AbstractMethodError</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_maybe_cache_changed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The object has called back to us saying maybe it has changed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_is_cached</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return boolean indicating if self is cached or not.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_cacher&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_get_cacher</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;return my cacher or None&quot;&quot;&quot;</span>
        <span class="n">cacher</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_cacher&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cacher</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cacher</span> <span class="o">=</span> <span class="n">cacher</span><span class="p">[</span><span class="mi">1</span><span class="p">]()</span>
        <span class="k">return</span> <span class="n">cacher</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_is_view</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return boolean indicating if self is view of another array &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">is_view</span>

    <span class="k">def</span> <span class="nf">_maybe_update_cacher</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clear</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">verify_is_copy</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        See if we need to update our parent cacher if clear, then clear our</span>
<span class="sd">        cache.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        clear : boolean, default False</span>
<span class="sd">            clear the item cache</span>
<span class="sd">        verify_is_copy : boolean, default True</span>
<span class="sd">            provide is_copy checks</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">cacher</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_cacher&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cacher</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ref</span> <span class="o">=</span> <span class="n">cacher</span><span class="p">[</span><span class="mi">1</span><span class="p">]()</span>

            <span class="c1"># we are trying to reference a dead referant, hence</span>
            <span class="c1"># a copy</span>
            <span class="k">if</span> <span class="n">ref</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cacher</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">ref</span><span class="o">.</span><span class="n">_maybe_cache_changed</span><span class="p">(</span><span class="n">cacher</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="p">)</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="k">pass</span>

        <span class="k">if</span> <span class="n">verify_is_copy</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_setitem_copy</span><span class="p">(</span><span class="n">stacklevel</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="s1">&#39;referant&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">clear</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_clear_item_cache</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_clear_item_cache</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_item_cache</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_item_cache</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">slobj</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a slice of this container.</span>

<span class="sd">        kind parameter is maintained for compatibility with Series slicing.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_block_manager_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">get_slice</span><span class="p">(</span><span class="n">slobj</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">))</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c1"># this could be a view</span>
        <span class="c1"># but only in a single-dtyped view slicable case</span>
        <span class="n">is_copy</span> <span class="o">=</span> <span class="n">axis</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">result</span><span class="o">.</span><span class="n">_is_view</span>
        <span class="n">result</span><span class="o">.</span><span class="n">_set_is_copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">is_copy</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">_set_item</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_clear_item_cache</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_set_is_copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ref</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">copy</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">is_copy</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ref</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">is_copy</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="n">ref</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">is_copy</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_check_is_chained_assignment_possible</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if we are a view, have a cacher, and are of mixed type.</span>
<span class="sd">        If so, then force a setitem_copy check.</span>

<span class="sd">        Should be called just near setting a value</span>

<span class="sd">        Will return a boolean if it we are a view and are cached, but a</span>
<span class="sd">        single-dtype meaning that the cacher should be updated following</span>
<span class="sd">        setting.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_view</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_cached</span><span class="p">:</span>
            <span class="n">ref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_cacher</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">ref</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">ref</span><span class="o">.</span><span class="n">_is_mixed_type</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_check_setitem_copy</span><span class="p">(</span><span class="n">stacklevel</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="s1">&#39;referant&#39;</span><span class="p">,</span>
                                         <span class="n">force</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_copy</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_setitem_copy</span><span class="p">(</span><span class="n">stacklevel</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="s1">&#39;referant&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_check_setitem_copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="s1">&#39;setting&#39;</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        stacklevel : integer, default 4</span>
<span class="sd">           the level to show of the stack when the error is output</span>
<span class="sd">        t : string, the type of setting error</span>
<span class="sd">        force : boolean, default False</span>
<span class="sd">           if True, then force showing an error</span>

<span class="sd">        validate if we are doing a settitem on a chained copy.</span>

<span class="sd">        If you call this function, be sure to set the stacklevel such that the</span>
<span class="sd">        user will see the error *at the level of setting*</span>

<span class="sd">        It is technically possible to figure out that we are setting on</span>
<span class="sd">        a copy even WITH a multi-dtyped pandas object. In other words, some</span>
<span class="sd">        blocks may be views while other are not. Currently _is_view will ALWAYS</span>
<span class="sd">        return False for multi-blocks to avoid having to handle this case.</span>

<span class="sd">        df = DataFrame(np.arange(0,9), columns=[&#39;count&#39;])</span>
<span class="sd">        df[&#39;group&#39;] = &#39;b&#39;</span>

<span class="sd">        # This technically need not raise SettingWithCopy if both are view</span>
<span class="sd">        # (which is not # generally guaranteed but is usually True.  However,</span>
<span class="sd">        # this is in general not a good practice and we recommend using .loc.</span>
<span class="sd">        df.iloc[0:5][&#39;group&#39;] = &#39;a&#39;</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">force</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_copy</span><span class="p">:</span>

            <span class="n">value</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">get_option</span><span class="p">(</span><span class="s1">&#39;mode.chained_assignment&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span>

            <span class="c1"># see if the copy is not actually refererd; if so, then disolve</span>
            <span class="c1"># the copy weakref</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">gc</span><span class="o">.</span><span class="n">collect</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">gc</span><span class="o">.</span><span class="n">get_referents</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">is_copy</span><span class="p">()):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">is_copy</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="k">return</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span>

            <span class="c1"># we might be a false positive</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_copy</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">is_copy</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="k">return</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span>

            <span class="c1"># a custom message</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">is_copy</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
                <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_copy</span>

            <span class="k">elif</span> <span class="n">t</span> <span class="o">==</span> <span class="s1">&#39;referant&#39;</span><span class="p">:</span>
                <span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
                     <span class="s2">&quot;A value is trying to be set on a copy of a slice from a &quot;</span>
                     <span class="s2">&quot;DataFrame</span><span class="se">\n\n</span><span class="s2">&quot;</span>
                     <span class="s2">&quot;See the caveats in the documentation: &quot;</span>
                     <span class="s2">&quot;http://pandas.pydata.org/pandas-docs/stable/&quot;</span>
                     <span class="s2">&quot;indexing.html#indexing-view-versus-copy&quot;</span>
                     <span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
                     <span class="s2">&quot;A value is trying to be set on a copy of a slice from a &quot;</span>
                     <span class="s2">&quot;DataFrame.</span><span class="se">\n</span><span class="s2">&quot;</span>
                     <span class="s2">&quot;Try using .loc[row_indexer,col_indexer] = value &quot;</span>
                     <span class="s2">&quot;instead</span><span class="se">\n\n</span><span class="s2">See the caveats in the documentation: &quot;</span>
                     <span class="s2">&quot;http://pandas.pydata.org/pandas-docs/stable/&quot;</span>
                     <span class="s2">&quot;indexing.html#indexing-view-versus-copy&quot;</span>
                     <span class="p">)</span>

            <span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="s1">&#39;raise&#39;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">SettingWithCopyError</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">value</span> <span class="o">==</span> <span class="s1">&#39;warn&#39;</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">SettingWithCopyWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="n">stacklevel</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Delete item</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">deleted</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="n">maybe_shortcut</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;columns&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">maybe_shortcut</span> <span class="o">=</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">_engine</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="k">pass</span>

        <span class="k">if</span> <span class="n">maybe_shortcut</span><span class="p">:</span>
            <span class="c1"># Allow shorthand to delete all columns whose first len(key)</span>
            <span class="c1"># elements match key:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="p">)</span>
            <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="n">col</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)]</span> <span class="o">==</span> <span class="n">key</span><span class="p">:</span>
                    <span class="k">del</span> <span class="bp">self</span><span class="p">[</span><span class="n">col</span><span class="p">]</span>
                    <span class="n">deleted</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">deleted</span><span class="p">:</span>
            <span class="c1"># If the above loop ran and didn&#39;t delete anything because</span>
            <span class="c1"># there was no match, this call should raise the appropriate</span>
            <span class="c1"># exception:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="c1"># delete from the caches</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_item_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">pass</span>

    <span class="n">_shared_docs</span><span class="p">[</span><span class="s1">&#39;_take&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        Return the elements in the given *positional* indices along an axis.</span>

<span class="s2">        This means that we are not indexing according to actual values in</span>
<span class="s2">        the index attribute of the object. We are indexing according to the</span>
<span class="s2">        actual position of the element in the object.</span>

<span class="s2">        This is the internal version of ``.take()`` and will contain a wider</span>
<span class="s2">        selection of parameters useful for internal use but not as suitable</span>
<span class="s2">        for public usage.</span>

<span class="s2">        Parameters</span>
<span class="s2">        ----------</span>
<span class="s2">        indices : array-like</span>
<span class="s2">            An array of ints indicating which positions to take.</span>
<span class="s2">        axis : int, default 0</span>
<span class="s2">            The axis on which to select elements. &quot;0&quot; means that we are</span>
<span class="s2">            selecting rows, &quot;1&quot; means that we are selecting columns, etc.</span>
<span class="s2">        convert : bool, default True</span>
<span class="s2">            Whether to convert negative indices into positive ones.</span>
<span class="s2">            For example, ``-1`` would map to the ``len(axis) - 1``.</span>
<span class="s2">            The conversions are similar to the behavior of indexing a</span>
<span class="s2">            regular Python list.</span>
<span class="s2">        is_copy : bool, default True</span>
<span class="s2">            Whether to return a copy of the original object or not.</span>

<span class="s2">        Returns</span>
<span class="s2">        -------</span>
<span class="s2">        taken : type of caller</span>
<span class="s2">            An array-like containing the elements taken from the object.</span>

<span class="s2">        See Also</span>
<span class="s2">        --------</span>
<span class="s2">        numpy.ndarray.take</span>
<span class="s2">        numpy.take</span>
<span class="s2">        &quot;&quot;&quot;</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s1">&#39;_take&#39;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">_take</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">convert</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">is_copy</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_consolidate_inplace</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">convert</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">maybe_convert_indices</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)))</span>

        <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span>
                                   <span class="n">axis</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_block_manager_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">),</span>
                                   <span class="n">verify</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">new_data</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c1"># Maybe set copy if we didn&#39;t actually change the index.</span>
        <span class="k">if</span> <span class="n">is_copy</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)):</span>
                <span class="n">result</span><span class="o">.</span><span class="n">_set_is_copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="n">_shared_docs</span><span class="p">[</span><span class="s1">&#39;take&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        Return the elements in the given *positional* indices along an axis.</span>

<span class="s2">        This means that we are not indexing according to actual values in</span>
<span class="s2">        the index attribute of the object. We are indexing according to the</span>
<span class="s2">        actual position of the element in the object.</span>

<span class="s2">        Parameters</span>
<span class="s2">        ----------</span>
<span class="s2">        indices : array-like</span>
<span class="s2">            An array of ints indicating which positions to take.</span>
<span class="s2">        axis : int, default 0</span>
<span class="s2">            The axis on which to select elements. &quot;0&quot; means that we are</span>
<span class="s2">            selecting rows, &quot;1&quot; means that we are selecting columns, etc.</span>
<span class="s2">        convert : bool, default True</span>
<span class="s2">            .. deprecated:: 0.21.0</span>
<span class="s2">               In the future, negative indices will always be converted.</span>

<span class="s2">            Whether to convert negative indices into positive ones.</span>
<span class="s2">            For example, ``-1`` would map to the ``len(axis) - 1``.</span>
<span class="s2">            The conversions are similar to the behavior of indexing a</span>
<span class="s2">            regular Python list.</span>
<span class="s2">        is_copy : bool, default True</span>
<span class="s2">            Whether to return a copy of the original object or not.</span>

<span class="s2">        Examples</span>
<span class="s2">        --------</span>
<span class="s2">        &gt;&gt;&gt; df = pd.DataFrame([(&#39;falcon&#39;, &#39;bird&#39;,    389.0),</span>
<span class="s2">                               (&#39;parrot&#39;, &#39;bird&#39;,     24.0),</span>
<span class="s2">                               (&#39;lion&#39;,   &#39;mammal&#39;,   80.5),</span>
<span class="s2">                               (&#39;monkey&#39;, &#39;mammal&#39;, np.nan)],</span>
<span class="s2">                              columns=(&#39;name&#39;, &#39;class&#39;, &#39;max_speed&#39;),</span>
<span class="s2">                              index=[0, 2, 3, 1])</span>
<span class="s2">        &gt;&gt;&gt; df</span>
<span class="s2">             name   class  max_speed</span>
<span class="s2">        0  falcon    bird      389.0</span>
<span class="s2">        2  parrot    bird       24.0</span>
<span class="s2">        3    lion  mammal       80.5</span>
<span class="s2">        1  monkey  mammal        NaN</span>

<span class="s2">        Take elements at positions 0 and 3 along the axis 0 (default).</span>

<span class="s2">        Note how the actual indices selected (0 and 1) do not correspond to</span>
<span class="s2">        our selected indices 0 and 3. That&#39;s because we are selecting the 0th</span>
<span class="s2">        and 3rd rows, not rows whose indices equal 0 and 3.</span>

<span class="s2">        &gt;&gt;&gt; df.take([0, 3])</span>
<span class="s2">        0  falcon    bird      389.0</span>
<span class="s2">        1  monkey  mammal        NaN</span>

<span class="s2">        Take elements at indices 1 and 2 along the axis 1 (column selection).</span>

<span class="s2">        &gt;&gt;&gt; df.take([1, 2], axis=1)</span>
<span class="s2">            class  max_speed</span>
<span class="s2">        0    bird      389.0</span>
<span class="s2">        2    bird       24.0</span>
<span class="s2">        3  mammal       80.5</span>
<span class="s2">        1  mammal        NaN</span>

<span class="s2">        We may take elements using negative integers for positive indices,</span>
<span class="s2">        starting from the end of the object, just like with Python lists.</span>

<span class="s2">        &gt;&gt;&gt; df.take([-1, -2])</span>
<span class="s2">             name   class  max_speed</span>
<span class="s2">        1  monkey  mammal        NaN</span>
<span class="s2">        3    lion  mammal       80.5</span>

<span class="s2">        Returns</span>
<span class="s2">        -------</span>
<span class="s2">        taken : type of caller</span>
<span class="s2">            An array-like containing the elements taken from the object.</span>

<span class="s2">        See Also</span>
<span class="s2">        --------</span>
<span class="s2">        numpy.ndarray.take</span>
<span class="s2">        numpy.take</span>
<span class="s2">        &quot;&quot;&quot;</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s1">&#39;take&#39;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">take</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">convert</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">is_copy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">convert</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;The &#39;convert&#39; parameter is deprecated &quot;</span>
                   <span class="s2">&quot;and will be removed in a future version.&quot;</span><span class="p">)</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="ne">FutureWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">convert</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="n">convert</span> <span class="o">=</span> <span class="n">nv</span><span class="o">.</span><span class="n">validate_take</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(),</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_take</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">convert</span><span class="o">=</span><span class="n">convert</span><span class="p">,</span> <span class="n">is_copy</span><span class="o">=</span><span class="n">is_copy</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">xs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">drop_level</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a cross-section (row(s) or column(s)) from the</span>
<span class="sd">        Series/DataFrame. Defaults to cross-section on the rows (axis=0).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        key : object</span>
<span class="sd">            Some label contained in the index, or partially in a MultiIndex</span>
<span class="sd">        axis : int, default 0</span>
<span class="sd">            Axis to retrieve cross-section on</span>
<span class="sd">        level : object, defaults to first n levels (n=1 or len(key))</span>
<span class="sd">            In case of a key partially contained in a MultiIndex, indicate</span>
<span class="sd">            which levels are used. Levels can be referred by label or position.</span>
<span class="sd">        drop_level : boolean, default True</span>
<span class="sd">            If False, returns object with same levels as self.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">           A  B  C</span>
<span class="sd">        a  4  5  2</span>
<span class="sd">        b  4  0  9</span>
<span class="sd">        c  9  7  3</span>
<span class="sd">        &gt;&gt;&gt; df.xs(&#39;a&#39;)</span>
<span class="sd">        A    4</span>
<span class="sd">        B    5</span>
<span class="sd">        C    2</span>
<span class="sd">        Name: a</span>
<span class="sd">        &gt;&gt;&gt; df.xs(&#39;C&#39;, axis=1)</span>
<span class="sd">        a    2</span>
<span class="sd">        b    9</span>
<span class="sd">        c    3</span>
<span class="sd">        Name: C</span>

<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">                            A  B  C  D</span>
<span class="sd">        first second third</span>
<span class="sd">        bar   one    1      4  1  8  9</span>
<span class="sd">              two    1      7  5  5  0</span>
<span class="sd">        baz   one    1      6  6  8  0</span>
<span class="sd">              three  2      5  3  5  3</span>
<span class="sd">        &gt;&gt;&gt; df.xs((&#39;baz&#39;, &#39;three&#39;))</span>
<span class="sd">               A  B  C  D</span>
<span class="sd">        third</span>
<span class="sd">        2      5  3  5  3</span>
<span class="sd">        &gt;&gt;&gt; df.xs(&#39;one&#39;, level=1)</span>
<span class="sd">                     A  B  C  D</span>
<span class="sd">        first third</span>
<span class="sd">        bar   1      4  1  8  9</span>
<span class="sd">        baz   1      6  6  8  0</span>
<span class="sd">        &gt;&gt;&gt; df.xs((&#39;baz&#39;, 2), level=[0, &#39;third&#39;])</span>
<span class="sd">                A  B  C  D</span>
<span class="sd">        second</span>
<span class="sd">        three   5  3  5  3</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        xs : Series or DataFrame</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        xs is only for getting, not setting values.</span>

<span class="sd">        MultiIndex Slicers is a generic way to get/set values on any level or</span>
<span class="sd">        levels.  It is a superset of xs functionality, see</span>
<span class="sd">        :ref:`MultiIndex Slicers &lt;advanced.mi_slicers&gt;`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">level</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">loc</span><span class="p">,</span> <span class="n">new_ax</span> <span class="o">=</span> <span class="n">labels</span><span class="o">.</span><span class="n">get_loc_level</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span>
                                               <span class="n">drop_level</span><span class="o">=</span><span class="n">drop_level</span><span class="p">)</span>

            <span class="c1"># create the tuple of the indexer</span>
            <span class="n">indexer</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span>
            <span class="n">indexer</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">loc</span>
            <span class="n">indexer</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">indexer</span><span class="p">)</span>

            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">indexer</span><span class="p">]</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">_get_axis_name</span><span class="p">(</span><span class="n">axis</span><span class="p">),</span> <span class="n">new_ax</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">result</span>

        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_consolidate_inplace</span><span class="p">()</span>

        <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">):</span>
            <span class="n">loc</span><span class="p">,</span> <span class="n">new_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_loc_level</span><span class="p">(</span><span class="n">key</span><span class="p">,</span>
                                                      <span class="n">drop_level</span><span class="o">=</span><span class="n">drop_level</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">loc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">loc</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">:</span>
                    <span class="n">inds</span><span class="p">,</span> <span class="o">=</span> <span class="n">loc</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_take</span><span class="p">(</span><span class="n">inds</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">convert</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_take</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">convert</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_scalar</span><span class="p">(</span><span class="n">loc</span><span class="p">):</span>
                <span class="n">new_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">is_scalar</span><span class="p">(</span><span class="n">loc</span><span class="p">):</span>
            <span class="n">new_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">fast_xs</span><span class="p">(</span><span class="n">loc</span><span class="p">)</span>

            <span class="c1"># may need to box a datelike-scalar</span>
            <span class="c1">#</span>
            <span class="c1"># if we encounter an array-like and we only have 1 dim</span>
            <span class="c1"># that means that their are list/ndarrays inside the Series!</span>
            <span class="c1"># so just return them (GH 6394)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">new_values</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">_maybe_box_datetimelike</span><span class="p">(</span><span class="n">new_values</span><span class="p">)</span>

            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor_sliced</span><span class="p">(</span>
                <span class="n">new_values</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span>
                <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">loc</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">new_values</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span>
            <span class="n">result</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">new_index</span>

        <span class="c1"># this could be a view</span>
        <span class="c1"># but only in a single-dtyped view slicable case</span>
        <span class="n">result</span><span class="o">.</span><span class="n">_set_is_copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="ow">not</span> <span class="n">result</span><span class="o">.</span><span class="n">_is_view</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="n">_xs</span> <span class="o">=</span> <span class="n">xs</span>

    <span class="k">def</span> <span class="nf">select</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">crit</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return data corresponding to axis labels matching criteria</span>

<span class="sd">        DEPRECATED: use df.loc[df.index.map(crit)] to select via labels</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        crit : function</span>
<span class="sd">            To be called on each index (label). Should return True or False</span>
<span class="sd">        axis : int</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        selection : type of caller</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;&#39;select&#39; is deprecated and will be removed in a &quot;</span>
                      <span class="s2">&quot;future release. You can use &quot;</span>
                      <span class="s2">&quot;.loc[labels.map(crit)] as a replacement&quot;</span><span class="p">,</span>
                      <span class="ne">FutureWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">axis_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_name</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">axis_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">axis_values</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">new_axis</span> <span class="o">=</span> <span class="n">axis_values</span><span class="p">[</span>
                <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="nb">bool</span><span class="p">(</span><span class="n">crit</span><span class="p">(</span><span class="n">label</span><span class="p">))</span> <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">axis_values</span><span class="p">])]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_axis</span> <span class="o">=</span> <span class="n">axis_values</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">axis_name</span><span class="p">:</span> <span class="n">new_axis</span><span class="p">})</span>

    <span class="k">def</span> <span class="nf">reindex_like</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">tolerance</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return an object with matching indices to myself.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Object</span>
<span class="sd">        method : string or None</span>
<span class="sd">        copy : boolean, default True</span>
<span class="sd">        limit : int, default None</span>
<span class="sd">            Maximum number of consecutive labels to fill for inexact matches.</span>
<span class="sd">        tolerance : optional</span>
<span class="sd">            Maximum distance between labels of the other object and this</span>
<span class="sd">            object for inexact matches. Can be list-like.</span>

<span class="sd">            .. versionadded:: 0.17.0</span>
<span class="sd">            .. versionadded:: 0.21.0 (list-like tolerance)</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Like calling s.reindex(index=other.index, columns=other.columns,</span>
<span class="sd">                               method=...)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        reindexed : same as input</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_construct_axes_dict</span><span class="p">(</span><span class="n">axes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_ORDERS</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
                                       <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span>
                                       <span class="n">tolerance</span><span class="o">=</span><span class="n">tolerance</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="o">**</span><span class="n">d</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">drop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="s1">&#39;raise&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return new object with labels in requested axis removed.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        labels : single label or list-like</span>
<span class="sd">            Index or column labels to drop.</span>
<span class="sd">        axis : int or axis name</span>
<span class="sd">            Whether to drop labels from the index (0 / &#39;index&#39;) or</span>
<span class="sd">            columns (1 / &#39;columns&#39;).</span>
<span class="sd">        index, columns : single label or list-like</span>
<span class="sd">            Alternative to specifying `axis` (``labels, axis=1`` is</span>
<span class="sd">            equivalent to ``columns=labels``).</span>

<span class="sd">            .. versionadded:: 0.21.0</span>
<span class="sd">        level : int or level name, default None</span>
<span class="sd">            For MultiIndex</span>
<span class="sd">        inplace : bool, default False</span>
<span class="sd">            If True, do operation inplace and return None.</span>
<span class="sd">        errors : {&#39;ignore&#39;, &#39;raise&#39;}, default &#39;raise&#39;</span>
<span class="sd">            If &#39;ignore&#39;, suppress error and existing labels are dropped.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dropped : type of caller</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame(np.arange(12).reshape(3,4),</span>
<span class="sd">                              columns=[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;])</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">           A  B   C   D</span>
<span class="sd">        0  0  1   2   3</span>
<span class="sd">        1  4  5   6   7</span>
<span class="sd">        2  8  9  10  11</span>

<span class="sd">        Drop columns</span>

<span class="sd">        &gt;&gt;&gt; df.drop([&#39;B&#39;, &#39;C&#39;], axis=1)</span>
<span class="sd">           A   D</span>
<span class="sd">        0  0   3</span>
<span class="sd">        1  4   7</span>
<span class="sd">        2  8  11</span>

<span class="sd">        &gt;&gt;&gt; df.drop(columns=[&#39;B&#39;, &#39;C&#39;])</span>
<span class="sd">           A   D</span>
<span class="sd">        0  0   3</span>
<span class="sd">        1  4   7</span>
<span class="sd">        2  8  11</span>

<span class="sd">        Drop a row by index</span>

<span class="sd">        &gt;&gt;&gt; df.drop([0, 1])</span>
<span class="sd">           A  B   C   D</span>
<span class="sd">        2  8  9  10  11</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Specifying both `labels` and `index` or `columns` will raise a</span>
<span class="sd">        ValueError.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">inplace</span> <span class="o">=</span> <span class="n">validate_bool_kwarg</span><span class="p">(</span><span class="n">inplace</span><span class="p">,</span> <span class="s1">&#39;inplace&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">labels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">columns</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot specify both &#39;labels&#39; and &quot;</span>
                                 <span class="s2">&quot;&#39;index&#39;/&#39;columns&#39;&quot;</span><span class="p">)</span>
            <span class="n">axis_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_name</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
            <span class="n">axes</span> <span class="o">=</span> <span class="p">{</span><span class="n">axis_name</span><span class="p">:</span> <span class="n">labels</span><span class="p">}</span>
        <span class="k">elif</span> <span class="n">index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">columns</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axes</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_construct_axes_from_arguments</span><span class="p">((</span><span class="n">index</span><span class="p">,</span> <span class="n">columns</span><span class="p">),</span> <span class="p">{})</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Need to specify at least one of &#39;labels&#39;, &quot;</span>
                             <span class="s2">&quot;&#39;index&#39; or &#39;columns&#39;&quot;</span><span class="p">)</span>

        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="k">for</span> <span class="n">axis</span><span class="p">,</span> <span class="n">labels</span> <span class="ow">in</span> <span class="n">axes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">labels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">obj</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">_drop_axis</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="n">errors</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_inplace</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">obj</span>

    <span class="k">def</span> <span class="nf">_drop_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="s1">&#39;raise&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Drop labels from specified axis. Used in the ``drop`` method</span>
<span class="sd">        internally.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        labels : single label or list-like</span>
<span class="sd">        axis : int or axis name</span>
<span class="sd">        level : int or level name, default None</span>
<span class="sd">            For MultiIndex</span>
<span class="sd">        errors : {&#39;ignore&#39;, &#39;raise&#39;}, default &#39;raise&#39;</span>
<span class="sd">            If &#39;ignore&#39;, suppress error and existing labels are dropped.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">axis_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_name</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">axis</span><span class="p">,</span> <span class="n">axis_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">),</span> <span class="n">axis</span>

        <span class="k">if</span> <span class="n">axis</span><span class="o">.</span><span class="n">is_unique</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">level</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s1">&#39;axis must be a MultiIndex&#39;</span><span class="p">)</span>
                <span class="n">new_axis</span> <span class="o">=</span> <span class="n">axis</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="n">errors</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_axis</span> <span class="o">=</span> <span class="n">axis</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="n">errors</span><span class="p">)</span>
            <span class="n">dropped</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">axis_name</span><span class="p">:</span> <span class="n">new_axis</span><span class="p">})</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">dropped</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">axis_</span><span class="p">]</span><span class="o">.</span><span class="n">set_names</span><span class="p">(</span><span class="n">axis</span><span class="o">.</span><span class="n">names</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">dropped</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="n">_ensure_object</span><span class="p">(</span><span class="n">com</span><span class="o">.</span><span class="n">_index_labels_to_array</span><span class="p">(</span><span class="n">labels</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">level</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s1">&#39;axis must be a MultiIndex&#39;</span><span class="p">)</span>
                <span class="n">indexer</span> <span class="o">=</span> <span class="o">~</span><span class="n">axis</span><span class="o">.</span><span class="n">get_level_values</span><span class="p">(</span><span class="n">level</span><span class="p">)</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">indexer</span> <span class="o">=</span> <span class="o">~</span><span class="n">axis</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>

            <span class="n">slicer</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span>
            <span class="n">slicer</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis_name</span><span class="p">)]</span> <span class="o">=</span> <span class="n">indexer</span>

            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slicer</span><span class="p">)]</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">_update_inplace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">verify_is_copy</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Replace self internals with result.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        verify_is_copy : boolean, default True</span>
<span class="sd">            provide is_copy checks</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># NOTE: This does *not* call __finalize__ and that&#39;s an explicit</span>
        <span class="c1"># decision that we may revisit in the future.</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_reset_cache</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_clear_item_cache</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="s1">&#39;_data&#39;</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_maybe_update_cacher</span><span class="p">(</span><span class="n">verify_is_copy</span><span class="o">=</span><span class="n">verify_is_copy</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add_prefix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prefix</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Concatenate prefix string with panel items names.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        prefix : string</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        with_prefix : type of caller</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">add_prefix</span><span class="p">(</span><span class="n">prefix</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">new_data</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add_suffix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">suffix</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Concatenate suffix string with panel items names.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        suffix : string</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        with_suffix : type of caller</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">add_suffix</span><span class="p">(</span><span class="n">suffix</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">new_data</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="n">_shared_docs</span><span class="p">[</span><span class="s1">&#39;sort_values&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        Sort by the values along either axis</span>

<span class="s2">        .. versionadded:: 0.17.0</span>

<span class="s2">        Parameters</span>
<span class="s2">        ----------</span><span class="si">%(optional_by)s</span><span class="s2"></span>
<span class="s2">        axis : </span><span class="si">%(axes_single_arg)s</span><span class="s2">, default 0</span>
<span class="s2">            Axis to direct sorting</span>
<span class="s2">        ascending : bool or list of bool, default True</span>
<span class="s2">             Sort ascending vs. descending. Specify list for multiple sort</span>
<span class="s2">             orders.  If this is a list of bools, must match the length of</span>
<span class="s2">             the by.</span>
<span class="s2">        inplace : bool, default False</span>
<span class="s2">             if True, perform operation in-place</span>
<span class="s2">        kind : {&#39;quicksort&#39;, &#39;mergesort&#39;, &#39;heapsort&#39;}, default &#39;quicksort&#39;</span>
<span class="s2">             Choice of sorting algorithm. See also ndarray.np.sort for more</span>
<span class="s2">             information.  `mergesort` is the only stable algorithm. For</span>
<span class="s2">             DataFrames, this option is only applied when sorting on a single</span>
<span class="s2">             column or label.</span>
<span class="s2">        na_position : {&#39;first&#39;, &#39;last&#39;}, default &#39;last&#39;</span>
<span class="s2">             `first` puts NaNs at the beginning, `last` puts NaNs at the end</span>

<span class="s2">        Returns</span>
<span class="s2">        -------</span>
<span class="s2">        sorted_obj : </span><span class="si">%(klass)s</span><span class="s2"></span>

<span class="s2">        Examples</span>
<span class="s2">        --------</span>
<span class="s2">        &gt;&gt;&gt; df = pd.DataFrame({</span>
<span class="s2">        ...     &#39;col1&#39; : [&#39;A&#39;, &#39;A&#39;, &#39;B&#39;, np.nan, &#39;D&#39;, &#39;C&#39;],</span>
<span class="s2">        ...     &#39;col2&#39; : [2, 1, 9, 8, 7, 4],</span>
<span class="s2">        ...     &#39;col3&#39;: [0, 1, 9, 4, 2, 3],</span>
<span class="s2">        ... })</span>
<span class="s2">        &gt;&gt;&gt; df</span>
<span class="s2">            col1 col2 col3</span>
<span class="s2">        0   A    2    0</span>
<span class="s2">        1   A    1    1</span>
<span class="s2">        2   B    9    9</span>
<span class="s2">        3   NaN  8    4</span>
<span class="s2">        4   D    7    2</span>
<span class="s2">        5   C    4    3</span>

<span class="s2">        Sort by col1</span>

<span class="s2">        &gt;&gt;&gt; df.sort_values(by=[&#39;col1&#39;])</span>
<span class="s2">            col1 col2 col3</span>
<span class="s2">        0   A    2    0</span>
<span class="s2">        1   A    1    1</span>
<span class="s2">        2   B    9    9</span>
<span class="s2">        5   C    4    3</span>
<span class="s2">        4   D    7    2</span>
<span class="s2">        3   NaN  8    4</span>

<span class="s2">        Sort by multiple columns</span>

<span class="s2">        &gt;&gt;&gt; df.sort_values(by=[&#39;col1&#39;, &#39;col2&#39;])</span>
<span class="s2">            col1 col2 col3</span>
<span class="s2">        1   A    1    1</span>
<span class="s2">        0   A    2    0</span>
<span class="s2">        2   B    9    9</span>
<span class="s2">        5   C    4    3</span>
<span class="s2">        4   D    7    2</span>
<span class="s2">        3   NaN  8    4</span>

<span class="s2">        Sort Descending</span>

<span class="s2">        &gt;&gt;&gt; df.sort_values(by=&#39;col1&#39;, ascending=False)</span>
<span class="s2">            col1 col2 col3</span>
<span class="s2">        4   D    7    2</span>
<span class="s2">        5   C    4    3</span>
<span class="s2">        2   B    9    9</span>
<span class="s2">        0   A    2    0</span>
<span class="s2">        1   A    1    1</span>
<span class="s2">        3   NaN  8    4</span>

<span class="s2">        Putting NAs first</span>

<span class="s2">        &gt;&gt;&gt; df.sort_values(by=&#39;col1&#39;, ascending=False, na_position=&#39;first&#39;)</span>
<span class="s2">            col1 col2 col3</span>
<span class="s2">        3   NaN  8    4</span>
<span class="s2">        4   D    7    2</span>
<span class="s2">        5   C    4    3</span>
<span class="s2">        2   B    9    9</span>
<span class="s2">        0   A    2    0</span>
<span class="s2">        1   A    1    1</span>
<span class="s2">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">sort_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">by</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;quicksort&#39;</span><span class="p">,</span> <span class="n">na_position</span><span class="o">=</span><span class="s1">&#39;last&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        NOT IMPLEMENTED: do not call this method, as sorting values is not</span>
<span class="sd">        supported for Panel objects and will raise an error.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;sort_values has not been implemented &quot;</span>
                                  <span class="s2">&quot;on Panel or Panel4D objects.&quot;</span><span class="p">)</span>

    <span class="n">_shared_docs</span><span class="p">[</span><span class="s1">&#39;sort_index&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        Sort object by labels (along an axis)</span>

<span class="s2">        Parameters</span>
<span class="s2">        ----------</span>
<span class="s2">        axis : </span><span class="si">%(axes)s</span><span class="s2"> to direct sorting</span>
<span class="s2">        level : int or level name or list of ints or list of level names</span>
<span class="s2">            if not None, sort on values in specified index level(s)</span>
<span class="s2">        ascending : boolean, default True</span>
<span class="s2">            Sort ascending vs. descending</span>
<span class="s2">        inplace : bool, default False</span>
<span class="s2">            if True, perform operation in-place</span>
<span class="s2">        kind : {&#39;quicksort&#39;, &#39;mergesort&#39;, &#39;heapsort&#39;}, default &#39;quicksort&#39;</span>
<span class="s2">             Choice of sorting algorithm. See also ndarray.np.sort for more</span>
<span class="s2">             information.  `mergesort` is the only stable algorithm. For</span>
<span class="s2">             DataFrames, this option is only applied when sorting on a single</span>
<span class="s2">             column or label.</span>
<span class="s2">        na_position : {&#39;first&#39;, &#39;last&#39;}, default &#39;last&#39;</span>
<span class="s2">             `first` puts NaNs at the beginning, `last` puts NaNs at the end.</span>
<span class="s2">             Not implemented for MultiIndex.</span>
<span class="s2">        sort_remaining : bool, default True</span>
<span class="s2">            if true and sorting by level and index is multilevel, sort by other</span>
<span class="s2">            levels too (in order) after sorting by specified level</span>

<span class="s2">        Returns</span>
<span class="s2">        -------</span>
<span class="s2">        sorted_obj : </span><span class="si">%(klass)s</span><span class="s2"></span>
<span class="s2">        &quot;&quot;&quot;</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s1">&#39;sort_index&#39;</span><span class="p">]</span> <span class="o">%</span> <span class="nb">dict</span><span class="p">(</span><span class="n">axes</span><span class="o">=</span><span class="s2">&quot;axes&quot;</span><span class="p">,</span> <span class="n">klass</span><span class="o">=</span><span class="s2">&quot;NDFrame&quot;</span><span class="p">))</span>
    <span class="k">def</span> <span class="nf">sort_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                   <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;quicksort&#39;</span><span class="p">,</span> <span class="n">na_position</span><span class="o">=</span><span class="s1">&#39;last&#39;</span><span class="p">,</span> <span class="n">sort_remaining</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">inplace</span> <span class="o">=</span> <span class="n">validate_bool_kwarg</span><span class="p">(</span><span class="n">inplace</span><span class="p">,</span> <span class="s1">&#39;inplace&#39;</span><span class="p">)</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">axis_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_name</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">level</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;level is not implemented&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;inplace is not implemented&quot;</span><span class="p">)</span>

        <span class="n">sort_index</span> <span class="o">=</span> <span class="n">labels</span><span class="o">.</span><span class="n">argsort</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ascending</span><span class="p">:</span>
            <span class="n">sort_index</span> <span class="o">=</span> <span class="n">sort_index</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">new_axis</span> <span class="o">=</span> <span class="n">labels</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">sort_index</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">axis_name</span><span class="p">:</span> <span class="n">new_axis</span><span class="p">})</span>

    <span class="n">_shared_docs</span><span class="p">[</span><span class="s1">&#39;reindex&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        Conform </span><span class="si">%(klass)s</span><span class="s2"> to new index with optional filling logic, placing</span>
<span class="s2">        NA/NaN in locations having no value in the previous index. A new object</span>
<span class="s2">        is produced unless the new index is equivalent to the current one and</span>
<span class="s2">        copy=False</span>

<span class="s2">        Parameters</span>
<span class="s2">        ----------</span>
<span class="s2">        </span><span class="si">%(optional_labels)s</span><span class="s2"></span>
<span class="s2">        </span><span class="si">%(axes)s</span><span class="s2"> : array-like, optional (should be specified using keywords)</span>
<span class="s2">            New labels / index to conform to. Preferably an Index object to</span>
<span class="s2">            avoid duplicating data</span>
<span class="s2">        </span><span class="si">%(optional_axis)s</span><span class="s2"></span>
<span class="s2">        method : {None, &#39;backfill&#39;/&#39;bfill&#39;, &#39;pad&#39;/&#39;ffill&#39;, &#39;nearest&#39;}, optional</span>
<span class="s2">            method to use for filling holes in reindexed DataFrame.</span>
<span class="s2">            Please note: this is only  applicable to DataFrames/Series with a</span>
<span class="s2">            monotonically increasing/decreasing index.</span>

<span class="s2">            * default: don&#39;t fill gaps</span>
<span class="s2">            * pad / ffill: propagate last valid observation forward to next</span>
<span class="s2">              valid</span>
<span class="s2">            * backfill / bfill: use next valid observation to fill gap</span>
<span class="s2">            * nearest: use nearest valid observations to fill gap</span>

<span class="s2">        copy : boolean, default True</span>
<span class="s2">            Return a new object, even if the passed indexes are the same</span>
<span class="s2">        level : int or name</span>
<span class="s2">            Broadcast across a level, matching Index values on the</span>
<span class="s2">            passed MultiIndex level</span>
<span class="s2">        fill_value : scalar, default np.NaN</span>
<span class="s2">            Value to use for missing values. Defaults to NaN, but can be any</span>
<span class="s2">            &quot;compatible&quot; value</span>
<span class="s2">        limit : int, default None</span>
<span class="s2">            Maximum number of consecutive elements to forward or backward fill</span>
<span class="s2">        tolerance : optional</span>
<span class="s2">            Maximum distance between original and new labels for inexact</span>
<span class="s2">            matches. The values of the index at the matching locations most</span>
<span class="s2">            satisfy the equation ``abs(index[indexer] - target) &lt;= tolerance``.</span>

<span class="s2">            Tolerance may be a scalar value, which applies the same tolerance</span>
<span class="s2">            to all values, or list-like, which applies variable tolerance per</span>
<span class="s2">            element. List-like includes list, tuple, array, Series, and must be</span>
<span class="s2">            the same size as the index and its dtype must exactly match the</span>
<span class="s2">            index&#39;s type.</span>

<span class="s2">            .. versionadded:: 0.17.0</span>
<span class="s2">            .. versionadded:: 0.21.0 (list-like tolerance)</span>

<span class="s2">        Examples</span>
<span class="s2">        --------</span>

<span class="s2">        ``DataFrame.reindex`` supports two calling conventions</span>

<span class="s2">        * ``(index=index_labels, columns=column_labels, ...)``</span>
<span class="s2">        * ``(labels, axis={&#39;index&#39;, &#39;columns&#39;}, ...)``</span>

<span class="s2">        We *highly* recommend using keyword arguments to clarify your</span>
<span class="s2">        intent.</span>

<span class="s2">        Create a dataframe with some fictional data.</span>

<span class="s2">        &gt;&gt;&gt; index = [&#39;Firefox&#39;, &#39;Chrome&#39;, &#39;Safari&#39;, &#39;IE10&#39;, &#39;Konqueror&#39;]</span>
<span class="s2">        &gt;&gt;&gt; df = pd.DataFrame({</span>
<span class="s2">        ...      &#39;http_status&#39;: [200,200,404,404,301],</span>
<span class="s2">        ...      &#39;response_time&#39;: [0.04, 0.02, 0.07, 0.08, 1.0]},</span>
<span class="s2">        ...       index=index)</span>
<span class="s2">        &gt;&gt;&gt; df</span>
<span class="s2">                   http_status  response_time</span>
<span class="s2">        Firefox            200           0.04</span>
<span class="s2">        Chrome             200           0.02</span>
<span class="s2">        Safari             404           0.07</span>
<span class="s2">        IE10               404           0.08</span>
<span class="s2">        Konqueror          301           1.00</span>

<span class="s2">        Create a new index and reindex the dataframe. By default</span>
<span class="s2">        values in the new index that do not have corresponding</span>
<span class="s2">        records in the dataframe are assigned ``NaN``.</span>

<span class="s2">        &gt;&gt;&gt; new_index= [&#39;Safari&#39;, &#39;Iceweasel&#39;, &#39;Comodo Dragon&#39;, &#39;IE10&#39;,</span>
<span class="s2">        ...             &#39;Chrome&#39;]</span>
<span class="s2">        &gt;&gt;&gt; df.reindex(new_index)</span>
<span class="s2">                       http_status  response_time</span>
<span class="s2">        Safari               404.0           0.07</span>
<span class="s2">        Iceweasel              NaN            NaN</span>
<span class="s2">        Comodo Dragon          NaN            NaN</span>
<span class="s2">        IE10                 404.0           0.08</span>
<span class="s2">        Chrome               200.0           0.02</span>

<span class="s2">        We can fill in the missing values by passing a value to</span>
<span class="s2">        the keyword ``fill_value``. Because the index is not monotonically</span>
<span class="s2">        increasing or decreasing, we cannot use arguments to the keyword</span>
<span class="s2">        ``method`` to fill the ``NaN`` values.</span>

<span class="s2">        &gt;&gt;&gt; df.reindex(new_index, fill_value=0)</span>
<span class="s2">                       http_status  response_time</span>
<span class="s2">        Safari                 404           0.07</span>
<span class="s2">        Iceweasel                0           0.00</span>
<span class="s2">        Comodo Dragon            0           0.00</span>
<span class="s2">        IE10                   404           0.08</span>
<span class="s2">        Chrome                 200           0.02</span>

<span class="s2">        &gt;&gt;&gt; df.reindex(new_index, fill_value=&#39;missing&#39;)</span>
<span class="s2">                      http_status response_time</span>
<span class="s2">        Safari                404          0.07</span>
<span class="s2">        Iceweasel         missing       missing</span>
<span class="s2">        Comodo Dragon     missing       missing</span>
<span class="s2">        IE10                  404          0.08</span>
<span class="s2">        Chrome                200          0.02</span>

<span class="s2">        We can also reindex the columns.</span>

<span class="s2">        &gt;&gt;&gt; df.reindex(columns=[&#39;http_status&#39;, &#39;user_agent&#39;])</span>
<span class="s2">                   http_status  user_agent</span>
<span class="s2">        Firefox            200         NaN</span>
<span class="s2">        Chrome             200         NaN</span>
<span class="s2">        Safari             404         NaN</span>
<span class="s2">        IE10               404         NaN</span>
<span class="s2">        Konqueror          301         NaN</span>

<span class="s2">        Or we can use &quot;axis-style&quot; keyword arguments</span>

<span class="s2">        &gt;&gt;&gt; df.reindex([&#39;http_status&#39;, &#39;user_agent&#39;], axis=&quot;columns&quot;)</span>
<span class="s2">                   http_status  user_agent</span>
<span class="s2">        Firefox            200         NaN</span>
<span class="s2">        Chrome             200         NaN</span>
<span class="s2">        Safari             404         NaN</span>
<span class="s2">        IE10               404         NaN</span>
<span class="s2">        Konqueror          301         NaN</span>

<span class="s2">        To further illustrate the filling functionality in</span>
<span class="s2">        ``reindex``, we will create a dataframe with a</span>
<span class="s2">        monotonically increasing index (for example, a sequence</span>
<span class="s2">        of dates).</span>

<span class="s2">        &gt;&gt;&gt; date_index = pd.date_range(&#39;1/1/2010&#39;, periods=6, freq=&#39;D&#39;)</span>
<span class="s2">        &gt;&gt;&gt; df2 = pd.DataFrame({&quot;prices&quot;: [100, 101, np.nan, 100, 89, 88]},</span>
<span class="s2">        ...                    index=date_index)</span>
<span class="s2">        &gt;&gt;&gt; df2</span>
<span class="s2">                    prices</span>
<span class="s2">        2010-01-01     100</span>
<span class="s2">        2010-01-02     101</span>
<span class="s2">        2010-01-03     NaN</span>
<span class="s2">        2010-01-04     100</span>
<span class="s2">        2010-01-05      89</span>
<span class="s2">        2010-01-06      88</span>

<span class="s2">        Suppose we decide to expand the dataframe to cover a wider</span>
<span class="s2">        date range.</span>

<span class="s2">        &gt;&gt;&gt; date_index2 = pd.date_range(&#39;12/29/2009&#39;, periods=10, freq=&#39;D&#39;)</span>
<span class="s2">        &gt;&gt;&gt; df2.reindex(date_index2)</span>
<span class="s2">                    prices</span>
<span class="s2">        2009-12-29     NaN</span>
<span class="s2">        2009-12-30     NaN</span>
<span class="s2">        2009-12-31     NaN</span>
<span class="s2">        2010-01-01     100</span>
<span class="s2">        2010-01-02     101</span>
<span class="s2">        2010-01-03     NaN</span>
<span class="s2">        2010-01-04     100</span>
<span class="s2">        2010-01-05      89</span>
<span class="s2">        2010-01-06      88</span>
<span class="s2">        2010-01-07     NaN</span>

<span class="s2">        The index entries that did not have a value in the original data frame</span>
<span class="s2">        (for example, &#39;2009-12-29&#39;) are by default filled with ``NaN``.</span>
<span class="s2">        If desired, we can fill in the missing values using one of several</span>
<span class="s2">        options.</span>

<span class="s2">        For example, to backpropagate the last valid value to fill the ``NaN``</span>
<span class="s2">        values, pass ``bfill`` as an argument to the ``method`` keyword.</span>

<span class="s2">        &gt;&gt;&gt; df2.reindex(date_index2, method=&#39;bfill&#39;)</span>
<span class="s2">                    prices</span>
<span class="s2">        2009-12-29     100</span>
<span class="s2">        2009-12-30     100</span>
<span class="s2">        2009-12-31     100</span>
<span class="s2">        2010-01-01     100</span>
<span class="s2">        2010-01-02     101</span>
<span class="s2">        2010-01-03     NaN</span>
<span class="s2">        2010-01-04     100</span>
<span class="s2">        2010-01-05      89</span>
<span class="s2">        2010-01-06      88</span>
<span class="s2">        2010-01-07     NaN</span>

<span class="s2">        Please note that the ``NaN`` value present in the original dataframe</span>
<span class="s2">        (at index value 2010-01-03) will not be filled by any of the</span>
<span class="s2">        value propagation schemes. This is because filling while reindexing</span>
<span class="s2">        does not look at dataframe values, but only compares the original and</span>
<span class="s2">        desired indexes. If you do want to fill in the ``NaN`` values present</span>
<span class="s2">        in the original dataframe, use the ``fillna()`` method.</span>

<span class="s2">        See the :ref:`user guide &lt;basics.reindexing&gt;` for more.</span>

<span class="s2">        Returns</span>
<span class="s2">        -------</span>
<span class="s2">        reindexed : </span><span class="si">%(klass)s</span><span class="s2"></span>
<span class="s2">        &quot;&quot;&quot;</span>

    <span class="c1"># TODO: Decide if we care about having different examples for different</span>
    <span class="c1">#       kinds</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s1">&#39;reindex&#39;</span><span class="p">]</span> <span class="o">%</span> <span class="nb">dict</span><span class="p">(</span><span class="n">axes</span><span class="o">=</span><span class="s2">&quot;axes&quot;</span><span class="p">,</span> <span class="n">klass</span><span class="o">=</span><span class="s2">&quot;NDFrame&quot;</span><span class="p">,</span>
                                             <span class="n">optional_labels</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
                                             <span class="n">optional_axis</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">))</span>
    <span class="k">def</span> <span class="nf">reindex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

        <span class="c1"># construct the args</span>
        <span class="n">axes</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_construct_axes_from_arguments</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="n">method</span> <span class="o">=</span> <span class="n">missing</span><span class="o">.</span><span class="n">clean_reindex_fill_method</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;method&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
        <span class="n">level</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;level&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">copy</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;copy&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">limit</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;limit&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">tolerance</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;tolerance&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">fill_value</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;fill_value&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

        <span class="c1"># Series.reindex doesn&#39;t use / need the axis kwarg</span>
        <span class="c1"># We pop and ignore it here, to make writing Series/Frame generic code</span>
        <span class="c1"># easier</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;axis&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;reindex() got an unexpected keyword &#39;</span>
                            <span class="s1">&#39;argument &quot;</span><span class="si">{0}</span><span class="s1">&quot;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">]))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_consolidate_inplace</span><span class="p">()</span>

        <span class="c1"># if all axes that are requested to reindex are equal, then only copy</span>
        <span class="c1"># if indicated must have index names equal here as well as values</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span><span class="o">.</span><span class="n">identical</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">axis</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">axes</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="c1"># check if we are a multi reindex</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_needs_reindex_multi</span><span class="p">(</span><span class="n">axes</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">level</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reindex_multi</span><span class="p">(</span><span class="n">axes</span><span class="p">,</span> <span class="n">copy</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span>

        <span class="c1"># perform the reindex on the axes</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reindex_axes</span><span class="p">(</span><span class="n">axes</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span>
                                  <span class="n">fill_value</span><span class="p">,</span> <span class="n">copy</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_reindex_axes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span>
                      <span class="n">copy</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Perform the reindex for all the axes.&quot;&quot;&quot;</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_ORDERS</span><span class="p">:</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="n">axes</span><span class="p">[</span><span class="n">a</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">labels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">ax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="n">new_index</span><span class="p">,</span> <span class="n">indexer</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span>
                                            <span class="n">tolerance</span><span class="o">=</span><span class="n">tolerance</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span>

            <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">_reindex_with_indexers</span><span class="p">({</span><span class="n">axis</span><span class="p">:</span> <span class="p">[</span><span class="n">new_index</span><span class="p">,</span> <span class="n">indexer</span><span class="p">]},</span>
                                             <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span>
                                             <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">allow_dups</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">obj</span>

    <span class="k">def</span> <span class="nf">_needs_reindex_multi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">level</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check if we do need a multi reindex.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">((</span><span class="n">com</span><span class="o">.</span><span class="n">_count_not_none</span><span class="p">(</span><span class="o">*</span><span class="n">axes</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_LEN</span><span class="p">)</span> <span class="ow">and</span>
                <span class="n">method</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">level</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_mixed_type</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_reindex_multi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="n">copy</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="n">_shared_docs</span><span class="p">[</span>
        <span class="s1">&#39;reindex_axis&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;&quot;&quot;Conform input object to new index with optional</span>
<span class="s2">        filling logic, placing NA/NaN in locations having no value in the</span>
<span class="s2">        previous index. A new object is produced unless the new index is</span>
<span class="s2">        equivalent to the current one and copy=False</span>

<span class="s2">        Parameters</span>
<span class="s2">        ----------</span>
<span class="s2">        labels : array-like</span>
<span class="s2">            New labels / index to conform to. Preferably an Index object to</span>
<span class="s2">            avoid duplicating data</span>
<span class="s2">        axis : </span><span class="si">%(axes_single_arg)s</span><span class="s2"></span>
<span class="s2">        method : {None, &#39;backfill&#39;/&#39;bfill&#39;, &#39;pad&#39;/&#39;ffill&#39;, &#39;nearest&#39;}, optional</span>
<span class="s2">            Method to use for filling holes in reindexed DataFrame:</span>

<span class="s2">            * default: don&#39;t fill gaps</span>
<span class="s2">            * pad / ffill: propagate last valid observation forward to next</span>
<span class="s2">              valid</span>
<span class="s2">            * backfill / bfill: use next valid observation to fill gap</span>
<span class="s2">            * nearest: use nearest valid observations to fill gap</span>

<span class="s2">        copy : boolean, default True</span>
<span class="s2">            Return a new object, even if the passed indexes are the same</span>
<span class="s2">        level : int or name</span>
<span class="s2">            Broadcast across a level, matching Index values on the</span>
<span class="s2">            passed MultiIndex level</span>
<span class="s2">        limit : int, default None</span>
<span class="s2">            Maximum number of consecutive elements to forward or backward fill</span>
<span class="s2">        tolerance : optional</span>
<span class="s2">            Maximum distance between original and new labels for inexact</span>
<span class="s2">            matches. The values of the index at the matching locations most</span>
<span class="s2">            satisfy the equation ``abs(index[indexer] - target) &lt;= tolerance``.</span>

<span class="s2">            Tolerance may be a scalar value, which applies the same tolerance</span>
<span class="s2">            to all values, or list-like, which applies variable tolerance per</span>
<span class="s2">            element. List-like includes list, tuple, array, Series, and must be</span>
<span class="s2">            the same size as the index and its dtype must exactly match the</span>
<span class="s2">            index&#39;s type.</span>

<span class="s2">            .. versionadded:: 0.17.0</span>
<span class="s2">            .. versionadded:: 0.21.0 (list-like tolerance)</span>

<span class="s2">        Examples</span>
<span class="s2">        --------</span>
<span class="s2">        &gt;&gt;&gt; df.reindex_axis([&#39;A&#39;, &#39;B&#39;, &#39;C&#39;], axis=1)</span>

<span class="s2">        See Also</span>
<span class="s2">        --------</span>
<span class="s2">        reindex, reindex_like</span>

<span class="s2">        Returns</span>
<span class="s2">        -------</span>
<span class="s2">        reindexed : </span><span class="si">%(klass)s</span><span class="s2"></span>
<span class="s2">        &quot;&quot;&quot;</span><span class="p">)</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s1">&#39;reindex_axis&#39;</span><span class="p">]</span> <span class="o">%</span> <span class="n">_shared_doc_kwargs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">reindex_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                     <span class="n">limit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">):</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;&#39;.reindex_axis&#39; is deprecated and will be removed in a future &quot;</span>
               <span class="s2">&quot;version. Use &#39;.reindex&#39; instead.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_consolidate_inplace</span><span class="p">()</span>

        <span class="n">axis_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_name</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">axis_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">axis_name</span><span class="p">)</span>
        <span class="n">method</span> <span class="o">=</span> <span class="n">missing</span><span class="o">.</span><span class="n">clean_reindex_fill_method</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="ne">FutureWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">new_index</span><span class="p">,</span> <span class="n">indexer</span> <span class="o">=</span> <span class="n">axis_values</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span>
                                                 <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reindex_with_indexers</span><span class="p">({</span><span class="n">axis</span><span class="p">:</span> <span class="p">[</span><span class="n">new_index</span><span class="p">,</span> <span class="n">indexer</span><span class="p">]},</span>
                                           <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_reindex_with_indexers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reindexers</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                               <span class="n">allow_dups</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;allow_dups indicates an internal call here &quot;&quot;&quot;</span>

        <span class="c1"># reindex doing multiple operations on different axes if indicated</span>
        <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span>
        <span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">reindexers</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="n">index</span><span class="p">,</span> <span class="n">indexer</span> <span class="o">=</span> <span class="n">reindexers</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
            <span class="n">baxis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_block_manager_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">index</span> <span class="o">=</span> <span class="n">_ensure_index</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">indexer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">indexer</span> <span class="o">=</span> <span class="n">_ensure_int64</span><span class="p">(</span><span class="n">indexer</span><span class="p">)</span>

            <span class="c1"># TODO: speed up on homogeneous DataFrame objects</span>
            <span class="n">new_data</span> <span class="o">=</span> <span class="n">new_data</span><span class="o">.</span><span class="n">reindex_indexer</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">indexer</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">baxis</span><span class="p">,</span>
                                                <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span>
                                                <span class="n">allow_dups</span><span class="o">=</span><span class="n">allow_dups</span><span class="p">,</span>
                                                <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">copy</span> <span class="ow">and</span> <span class="n">new_data</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">:</span>
            <span class="n">new_data</span> <span class="o">=</span> <span class="n">new_data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">new_data</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_reindex_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_index</span><span class="p">,</span> <span class="n">fill_method</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">copy</span><span class="p">):</span>
        <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">reindex_axis</span><span class="p">(</span><span class="n">new_index</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
                                           <span class="n">method</span><span class="o">=</span><span class="n">fill_method</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">new_data</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">copy</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">new_data</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">items</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">like</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">regex</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Subset rows or columns of dataframe according to labels in</span>
<span class="sd">        the specified index.</span>

<span class="sd">        Note that this routine does not filter a dataframe on its</span>
<span class="sd">        contents. The filter is applied to the labels of the index.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        items : list-like</span>
<span class="sd">            List of info axis to restrict to (must not all be present)</span>
<span class="sd">        like : string</span>
<span class="sd">            Keep info axis where &quot;arg in col == True&quot;</span>
<span class="sd">        regex : string (regular expression)</span>
<span class="sd">            Keep info axis with re.search(regex, col) == True</span>
<span class="sd">        axis : int or string axis name</span>
<span class="sd">            The axis to filter on.  By default this is the info axis,</span>
<span class="sd">            &#39;index&#39; for Series, &#39;columns&#39; for DataFrame</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        same type as input object</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">        one  two  three</span>
<span class="sd">        mouse     1    2      3</span>
<span class="sd">        rabbit    4    5      6</span>

<span class="sd">        &gt;&gt;&gt; # select columns by name</span>
<span class="sd">        &gt;&gt;&gt; df.filter(items=[&#39;one&#39;, &#39;three&#39;])</span>
<span class="sd">        one  three</span>
<span class="sd">        mouse     1      3</span>
<span class="sd">        rabbit    4      6</span>

<span class="sd">        &gt;&gt;&gt; # select columns by regular expression</span>
<span class="sd">        &gt;&gt;&gt; df.filter(regex=&#39;e$&#39;, axis=1)</span>
<span class="sd">        one  three</span>
<span class="sd">        mouse     1      3</span>
<span class="sd">        rabbit    4      6</span>

<span class="sd">        &gt;&gt;&gt; # select rows containing &#39;bbi&#39;</span>
<span class="sd">        &gt;&gt;&gt; df.filter(like=&#39;bbi&#39;, axis=0)</span>
<span class="sd">        one  two  three</span>
<span class="sd">        rabbit    4    5      6</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        pandas.DataFrame.loc</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The ``items``, ``like``, and ``regex`` parameters are</span>
<span class="sd">        enforced to be mutually exclusive.</span>

<span class="sd">        ``axis`` defaults to the info axis that is used when indexing</span>
<span class="sd">        with ``[]``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">re</span>

        <span class="n">nkw</span> <span class="o">=</span> <span class="n">_count_not_none</span><span class="p">(</span><span class="n">items</span><span class="p">,</span> <span class="n">like</span><span class="p">,</span> <span class="n">regex</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nkw</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Keyword arguments `items`, `like`, or `regex` &#39;</span>
                            <span class="s1">&#39;are mutually exclusive&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_info_axis_name</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">items</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_name</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span>
                <span class="o">**</span><span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="p">[</span><span class="n">r</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">items</span> <span class="k">if</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">]})</span>
        <span class="k">elif</span> <span class="n">like</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">like</span> <span class="ow">in</span> <span class="n">to_str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">labels</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">loc</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)[</span><span class="n">values</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">regex</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">matcher</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">to_str</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="n">matcher</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">regex</span><span class="p">)</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">labels</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">loc</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)[</span><span class="n">values</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Must pass either `items`, `like`, or `regex`&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">head</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the first n rows.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n : int, default 5</span>
<span class="sd">            Number of rows to select.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        obj_head : type of caller</span>
<span class="sd">            The first n rows of the caller object.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:</span><span class="n">n</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">tail</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the last n rows.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n : int, default 5</span>
<span class="sd">            Number of rows to select.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        obj_tail : type of caller</span>
<span class="sd">            The last n rows of the caller object.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="o">-</span><span class="n">n</span><span class="p">:]</span>

    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">frac</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a random sample of items from an axis of object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n : int, optional</span>
<span class="sd">            Number of items from axis to return. Cannot be used with `frac`.</span>
<span class="sd">            Default = 1 if `frac` = None.</span>
<span class="sd">        frac : float, optional</span>
<span class="sd">            Fraction of axis items to return. Cannot be used with `n`.</span>
<span class="sd">        replace : boolean, optional</span>
<span class="sd">            Sample with or without replacement. Default = False.</span>
<span class="sd">        weights : str or ndarray-like, optional</span>
<span class="sd">            Default &#39;None&#39; results in equal probability weighting.</span>
<span class="sd">            If passed a Series, will align with target object on index. Index</span>
<span class="sd">            values in weights not found in sampled object will be ignored and</span>
<span class="sd">            index values in sampled object not in weights will be assigned</span>
<span class="sd">            weights of zero.</span>
<span class="sd">            If called on a DataFrame, will accept the name of a column</span>
<span class="sd">            when axis = 0.</span>
<span class="sd">            Unless weights are a Series, weights must be same length as axis</span>
<span class="sd">            being sampled.</span>
<span class="sd">            If weights do not sum to 1, they will be normalized to sum to 1.</span>
<span class="sd">            Missing values in the weights column will be treated as zero.</span>
<span class="sd">            inf and -inf values not allowed.</span>
<span class="sd">        random_state : int or numpy.random.RandomState, optional</span>
<span class="sd">            Seed for the random number generator (if int), or numpy RandomState</span>
<span class="sd">            object.</span>
<span class="sd">        axis : int or string, optional</span>
<span class="sd">            Axis to sample. Accepts axis number or name. Default is stat axis</span>
<span class="sd">            for given data type (0 for Series and DataFrames, 1 for Panels).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        A new object of same type as caller.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        Generate an example ``Series`` and ``DataFrame``:</span>

<span class="sd">        &gt;&gt;&gt; s = pd.Series(np.random.randn(50))</span>
<span class="sd">        &gt;&gt;&gt; s.head()</span>
<span class="sd">        0   -0.038497</span>
<span class="sd">        1    1.820773</span>
<span class="sd">        2   -0.972766</span>
<span class="sd">        3   -1.598270</span>
<span class="sd">        4   -1.095526</span>
<span class="sd">        dtype: float64</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame(np.random.randn(50, 4), columns=list(&#39;ABCD&#39;))</span>
<span class="sd">        &gt;&gt;&gt; df.head()</span>
<span class="sd">                  A         B         C         D</span>
<span class="sd">        0  0.016443 -2.318952 -0.566372 -1.028078</span>
<span class="sd">        1 -1.051921  0.438836  0.658280 -0.175797</span>
<span class="sd">        2 -1.243569 -0.364626 -0.215065  0.057736</span>
<span class="sd">        3  1.768216  0.404512 -0.385604 -1.457834</span>
<span class="sd">        4  1.072446 -1.137172  0.314194 -0.046661</span>

<span class="sd">        Next extract a random sample from both of these objects...</span>

<span class="sd">        3 random elements from the ``Series``:</span>

<span class="sd">        &gt;&gt;&gt; s.sample(n=3)</span>
<span class="sd">        27   -0.994689</span>
<span class="sd">        55   -1.049016</span>
<span class="sd">        67   -0.224565</span>
<span class="sd">        dtype: float64</span>

<span class="sd">        And a random 10% of the ``DataFrame`` with replacement:</span>

<span class="sd">        &gt;&gt;&gt; df.sample(frac=0.1, replace=True)</span>
<span class="sd">                   A         B         C         D</span>
<span class="sd">        35  1.981780  0.142106  1.817165 -0.290805</span>
<span class="sd">        49 -1.336199 -0.448634 -0.789640  0.217116</span>
<span class="sd">        40  0.823173 -0.078816  1.009536  1.015108</span>
<span class="sd">        15  1.421154 -0.055301 -1.922594 -0.019696</span>
<span class="sd">        6  -0.148339  0.832938  1.787600 -1.383767</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stat_axis_number</span>

        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">axis_length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>

        <span class="c1"># Process random_state argument</span>
        <span class="n">rs</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span>

        <span class="c1"># Check weights for compliance</span>
        <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

            <span class="c1"># If a series, align with frame</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">):</span>
                <span class="n">weights</span> <span class="o">=</span> <span class="n">weights</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">axis</span><span class="p">])</span>

            <span class="c1"># Strings acceptable if a dataframe and axis = 0</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">weights</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">weights</span><span class="p">]</span>
                        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;String passed to weights not a &quot;</span>
                                           <span class="s2">&quot;valid column&quot;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Strings can only be passed to &quot;</span>
                                         <span class="s2">&quot;weights when sampling from rows on &quot;</span>
                                         <span class="s2">&quot;a DataFrame&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Strings cannot be passed as weights &quot;</span>
                                     <span class="s2">&quot;when sampling from a Series or Panel.&quot;</span><span class="p">)</span>

            <span class="n">weights</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span> <span class="o">!=</span> <span class="n">axis_length</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Weights and axis to be sampled must be of &quot;</span>
                                 <span class="s2">&quot;same length&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">weights</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="ow">or</span> <span class="p">(</span><span class="n">weights</span> <span class="o">==</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;weight vector may not include `inf` values&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">weights</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;weight vector many not include negative &quot;</span>
                                 <span class="s2">&quot;values&quot;</span><span class="p">)</span>

            <span class="c1"># If has nan, set to zero.</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="n">weights</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

            <span class="c1"># Renormalize if don&#39;t sum to 1</span>
            <span class="k">if</span> <span class="n">weights</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">weights</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">weights</span> <span class="o">=</span> <span class="n">weights</span> <span class="o">/</span> <span class="n">weights</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid weights: weights sum to zero&quot;</span><span class="p">)</span>

            <span class="n">weights</span> <span class="o">=</span> <span class="n">weights</span><span class="o">.</span><span class="n">values</span>

        <span class="c1"># If no frac or n, default to n=1.</span>
        <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">frac</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">n</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">frac</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">1</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Only integers accepted as `n` values&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">n</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">frac</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">frac</span> <span class="o">*</span> <span class="n">axis_length</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">n</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">frac</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Please enter a value for `frac` OR `n`, not &#39;</span>
                             <span class="s1">&#39;both&#39;</span><span class="p">)</span>

        <span class="c1"># Check for negative sizes</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;A negative number of rows requested. Please &quot;</span>
                             <span class="s2">&quot;provide positive value.&quot;</span><span class="p">)</span>

        <span class="n">locs</span> <span class="o">=</span> <span class="n">rs</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">axis_length</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="n">replace</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">weights</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">locs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">is_copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="n">_shared_docs</span><span class="p">[</span><span class="s1">&#39;pipe&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="sa">r</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        Apply func(self, \*args, \*\*kwargs)</span>

<span class="s2">        Parameters</span>
<span class="s2">        ----------</span>
<span class="s2">        func : function</span>
<span class="s2">            function to apply to the </span><span class="si">%(klass)s</span><span class="s2">.</span>
<span class="s2">            ``args``, and ``kwargs`` are passed into ``func``.</span>
<span class="s2">            Alternatively a ``(callable, data_keyword)`` tuple where</span>
<span class="s2">            ``data_keyword`` is a string indicating the keyword of</span>
<span class="s2">            ``callable`` that expects the </span><span class="si">%(klass)s</span><span class="s2">.</span>
<span class="s2">        args : iterable, optional</span>
<span class="s2">            positional arguments passed into ``func``.</span>
<span class="s2">        kwargs : mapping, optional</span>
<span class="s2">            a dictionary of keyword arguments passed into ``func``.</span>

<span class="s2">        Returns</span>
<span class="s2">        -------</span>
<span class="s2">        object : the return type of ``func``.</span>

<span class="s2">        Notes</span>
<span class="s2">        -----</span>

<span class="s2">        Use ``.pipe`` when chaining together functions that expect</span>
<span class="s2">        Series, DataFrames or GroupBy objects. Instead of writing</span>

<span class="s2">        &gt;&gt;&gt; f(g(h(df), arg1=a), arg2=b, arg3=c)</span>

<span class="s2">        You can write</span>

<span class="s2">        &gt;&gt;&gt; (df.pipe(h)</span>
<span class="s2">        ...    .pipe(g, arg1=a)</span>
<span class="s2">        ...    .pipe(f, arg2=b, arg3=c)</span>
<span class="s2">        ... )</span>

<span class="s2">        If you have a function that takes the data as (say) the second</span>
<span class="s2">        argument, pass a tuple indicating which keyword expects the</span>
<span class="s2">        data. For example, suppose ``f`` takes its data as ``arg2``:</span>

<span class="s2">        &gt;&gt;&gt; (df.pipe(h)</span>
<span class="s2">        ...    .pipe(g, arg1=a)</span>
<span class="s2">        ...    .pipe((f, &#39;arg2&#39;), arg1=a, arg3=c)</span>
<span class="s2">        ...  )</span>

<span class="s2">        See Also</span>
<span class="s2">        --------</span>
<span class="s2">        pandas.DataFrame.apply</span>
<span class="s2">        pandas.DataFrame.applymap</span>
<span class="s2">        pandas.Series.map</span>
<span class="s2">    &quot;&quot;&quot;</span><span class="p">)</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s1">&#39;pipe&#39;</span><span class="p">]</span> <span class="o">%</span> <span class="n">_shared_doc_kwargs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">pipe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">com</span><span class="o">.</span><span class="n">_pipe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="n">_shared_docs</span><span class="p">[</span><span class="s1">&#39;aggregate&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    Aggregate using callable, string, dict, or list of string/callables</span>

<span class="s2">    </span><span class="si">%(versionadded)s</span><span class="s2"></span>

<span class="s2">    Parameters</span>
<span class="s2">    ----------</span>
<span class="s2">    func : callable, string, dictionary, or list of string/callables</span>
<span class="s2">        Function to use for aggregating the data. If a function, must either</span>
<span class="s2">        work when passed a </span><span class="si">%(klass)s</span><span class="s2"> or when passed to </span><span class="si">%(klass)s</span><span class="s2">.apply. For</span>
<span class="s2">        a DataFrame, can pass a dict, if the keys are DataFrame column names.</span>

<span class="s2">        Accepted Combinations are:</span>

<span class="s2">        - string function name</span>
<span class="s2">        - function</span>
<span class="s2">        - list of functions</span>
<span class="s2">        - dict of column names -&gt; functions (or list of functions)</span>

<span class="s2">    Notes</span>
<span class="s2">    -----</span>
<span class="s2">    Numpy functions mean/median/prod/sum/std/var are special cased so the</span>
<span class="s2">    default behavior is applying the function along axis=0</span>
<span class="s2">    (e.g., np.mean(arr_2d, axis=0)) as opposed to</span>
<span class="s2">    mimicking the default Numpy behavior (e.g., np.mean(arr_2d)).</span>

<span class="s2">    `agg` is an alias for `aggregate`. Use the alias.</span>

<span class="s2">    Returns</span>
<span class="s2">    -------</span>
<span class="s2">    aggregated : </span><span class="si">%(klass)s</span><span class="s2"></span>
<span class="s2">    &quot;&quot;&quot;</span><span class="p">)</span>

    <span class="n">_shared_docs</span><span class="p">[</span><span class="s1">&#39;transform&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    Call function producing a like-indexed </span><span class="si">%(klass)s</span><span class="s2"></span>
<span class="s2">    and return a </span><span class="si">%(klass)s</span><span class="s2"> with the transformed values</span>

<span class="s2">    .. versionadded:: 0.20.0</span>

<span class="s2">    Parameters</span>
<span class="s2">    ----------</span>
<span class="s2">    func : callable, string, dictionary, or list of string/callables</span>
<span class="s2">        To apply to column</span>

<span class="s2">        Accepted Combinations are:</span>

<span class="s2">        - string function name</span>
<span class="s2">        - function</span>
<span class="s2">        - list of functions</span>
<span class="s2">        - dict of column names -&gt; functions (or list of functions)</span>

<span class="s2">    Returns</span>
<span class="s2">    -------</span>
<span class="s2">    transformed : </span><span class="si">%(klass)s</span><span class="s2"></span>

<span class="s2">    Examples</span>
<span class="s2">    --------</span>
<span class="s2">    &gt;&gt;&gt; df = pd.DataFrame(np.random.randn(10, 3), columns=[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;],</span>
<span class="s2">    ...                   index=pd.date_range(&#39;1/1/2000&#39;, periods=10))</span>
<span class="s2">    df.iloc[3:7] = np.nan</span>

<span class="s2">    &gt;&gt;&gt; df.transform(lambda x: (x - x.mean()) / x.std())</span>
<span class="s2">                       A         B         C</span>
<span class="s2">    2000-01-01  0.579457  1.236184  0.123424</span>
<span class="s2">    2000-01-02  0.370357 -0.605875 -1.231325</span>
<span class="s2">    2000-01-03  1.455756 -0.277446  0.288967</span>
<span class="s2">    2000-01-04       NaN       NaN       NaN</span>
<span class="s2">    2000-01-05       NaN       NaN       NaN</span>
<span class="s2">    2000-01-06       NaN       NaN       NaN</span>
<span class="s2">    2000-01-07       NaN       NaN       NaN</span>
<span class="s2">    2000-01-08 -0.498658  1.274522  1.642524</span>
<span class="s2">    2000-01-09 -0.540524 -1.012676 -0.828968</span>
<span class="s2">    2000-01-10 -1.366388 -0.614710  0.005378</span>

<span class="s2">    See also</span>
<span class="s2">    --------</span>
<span class="s2">    pandas.</span><span class="si">%(klass)s</span><span class="s2">.aggregate</span>
<span class="s2">    pandas.</span><span class="si">%(klass)s</span><span class="s2">.apply</span>

<span class="s2">    &quot;&quot;&quot;</span><span class="p">)</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># Attribute access</span>

    <span class="k">def</span> <span class="nf">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Propagate metadata from other to self.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : the object from which to get the attributes that we are going</span>
<span class="sd">            to propagate</span>
<span class="sd">        method : optional, a passed method name ; possibly to take different</span>
<span class="sd">            types of propagation actions based on this</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">NDFrame</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_metadata</span><span class="p">:</span>
                <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;After regular attribute access, try looking up the name</span>
<span class="sd">        This allows simpler access to columns for interactive use.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Note: obj.x will always call obj.__getattribute__(&#39;x&#39;) prior to</span>
        <span class="c1"># calling obj.__getattr__(&#39;x&#39;).</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_internal_names_set</span> <span class="ow">or</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_metadata</span> <span class="ow">or</span>
                <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_accessors</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_info_axis</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="k">return</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;After regular attribute access, try setting the name</span>
<span class="sd">        This allows simpler access to columns for interactive use.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># first try regular attribute access via __getattribute__, so that</span>
        <span class="c1"># e.g. ``obj.x`` and ``obj.x = 4`` will always reference/modify</span>
        <span class="c1"># the same attribute.</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="nb">object</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="c1"># if this fails, go on to more involved attribute setting</span>
        <span class="c1"># (note that this matches __getattr__, above).</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_internal_names_set</span><span class="p">:</span>
            <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_metadata</span><span class="p">:</span>
            <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">existing</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">existing</span><span class="p">,</span> <span class="n">Index</span><span class="p">):</span>
                    <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_info_axis</span><span class="p">:</span>
                    <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ABCDataFrame</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">is_list_like</span><span class="p">(</span><span class="n">value</span><span class="p">)):</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Pandas doesn&#39;t allow columns to be &quot;</span>
                                  <span class="s2">&quot;created via a new attribute name - see &quot;</span>
                                  <span class="s2">&quot;https://pandas.pydata.org/pandas-docs/&quot;</span>
                                  <span class="s2">&quot;stable/indexing.html#attribute-access&quot;</span><span class="p">,</span>
                                  <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
                <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># Getting and setting elements</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># Consolidation of internals</span>

    <span class="k">def</span> <span class="nf">_protect_consolidate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Consolidate _data -- if the blocks have changed, then clear the</span>
<span class="sd">        cache</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">blocks_before</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">blocks</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">f</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">blocks</span><span class="p">)</span> <span class="o">!=</span> <span class="n">blocks_before</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_clear_item_cache</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">_consolidate_inplace</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Consolidate data in place and return None&quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">f</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">consolidate</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_protect_consolidate</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_consolidate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute NDFrame with &quot;consolidated&quot; internals (data of each dtype</span>
<span class="sd">        grouped together in a single ndarray).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        inplace : boolean, default False</span>
<span class="sd">            If False return new object, otherwise modify existing object</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        consolidated : type of caller</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">inplace</span> <span class="o">=</span> <span class="n">validate_bool_kwarg</span><span class="p">(</span><span class="n">inplace</span><span class="p">,</span> <span class="s1">&#39;inplace&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_consolidate_inplace</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">consolidate</span><span class="p">()</span>
            <span class="n">cons_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_protect_consolidate</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">cons_data</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">consolidate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        DEPRECATED: consolidate will be an internal implementation only.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># 15483</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;consolidate is deprecated and will be removed in a &quot;</span>
                      <span class="s2">&quot;future release.&quot;</span><span class="p">,</span> <span class="ne">FutureWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_consolidate</span><span class="p">(</span><span class="n">inplace</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_is_mixed_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">is_mixed_type</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_protect_consolidate</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_is_numeric_mixed_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">is_numeric_mixed_type</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_protect_consolidate</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_is_datelike_mixed_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">is_datelike_mixed_type</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_protect_consolidate</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_check_inplace_setting</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; check whether we allow in-place setting with this type of value &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_mixed_type</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_numeric_mixed_type</span><span class="p">:</span>

                <span class="c1"># allow an actual np.nan thru</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
                        <span class="k">return</span> <span class="kc">True</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="k">pass</span>

                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Cannot do inplace boolean setting on &#39;</span>
                                <span class="s1">&#39;mixed-types with a non np.nan value&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_get_numeric_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">get_numeric_data</span><span class="p">())</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_bool_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">get_bool_data</span><span class="p">())</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># Internal Interface Methods</span>

    <span class="k">def</span> <span class="nf">as_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert the frame to its Numpy-array representation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        columns: list, optional, default:None</span>
<span class="sd">            If None, return all columns, otherwise, returns specified columns.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        values : ndarray</span>
<span class="sd">            If the caller is heterogeneous and contains booleans or objects,</span>
<span class="sd">            the result will be of dtype=object. See Notes.</span>


<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Return is NOT a Numpy-matrix, rather, a Numpy-array.</span>

<span class="sd">        The dtype will be a lower-common-denominator dtype (implicit</span>
<span class="sd">        upcasting); that is to say if the dtypes (even of numeric types)</span>
<span class="sd">        are mixed, the one that accommodates all will be chosen. Use this</span>
<span class="sd">        with care if you are not dealing with the blocks.</span>

<span class="sd">        e.g. If the dtypes are float16 and float32, dtype will be upcast to</span>
<span class="sd">        float32.  If dtypes are int32 and uint8, dtype will be upcase to</span>
<span class="sd">        int32. By numpy.find_common_type convention, mixing int64 and uint64</span>
<span class="sd">        will result in a flot64 dtype.</span>

<span class="sd">        This method is provided for backwards compatibility. Generally,</span>
<span class="sd">        it is recommended to use &#39;.values&#39;.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        pandas.DataFrame.values</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_consolidate_inplace</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_REVERSED</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">as_matrix</span><span class="p">(</span><span class="n">columns</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">as_matrix</span><span class="p">(</span><span class="n">columns</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Numpy representation of NDFrame</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The dtype will be a lower-common-denominator dtype (implicit</span>
<span class="sd">        upcasting); that is to say if the dtypes (even of numeric types)</span>
<span class="sd">        are mixed, the one that accommodates all will be chosen. Use this</span>
<span class="sd">        with care if you are not dealing with the blocks.</span>

<span class="sd">        e.g. If the dtypes are float16 and float32, dtype will be upcast to</span>
<span class="sd">        float32.  If dtypes are int32 and uint8, dtype will be upcast to</span>
<span class="sd">        int32. By numpy.find_common_type convention, mixing int64 and uint64</span>
<span class="sd">        will result in a flot64 dtype.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_matrix</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;internal implementation&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_get_values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># compat</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_matrix</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">get_values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;same as values (but handles sparseness conversions)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_matrix</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">get_dtype_counts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the counts of dtypes in this object.&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas</span> <span class="k">import</span> <span class="n">Series</span>
        <span class="k">return</span> <span class="n">Series</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">get_dtype_counts</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">get_ftype_counts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the counts of ftypes in this object.&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas</span> <span class="k">import</span> <span class="n">Series</span>
        <span class="k">return</span> <span class="n">Series</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">get_ftype_counts</span><span class="p">())</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dtypes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the dtypes in this object.&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas</span> <span class="k">import</span> <span class="n">Series</span>
        <span class="k">return</span> <span class="n">Series</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">get_dtypes</span><span class="p">(),</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_info_axis</span><span class="p">,</span>
                      <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">object_</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ftypes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the ftypes (indication of sparse/dense and dtype)</span>
<span class="sd">        in this object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas</span> <span class="k">import</span> <span class="n">Series</span>
        <span class="k">return</span> <span class="n">Series</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">get_ftypes</span><span class="p">(),</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_info_axis</span><span class="p">,</span>
                      <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">object_</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">as_blocks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert the frame to a dict of dtype -&gt; Constructor Types that each has</span>
<span class="sd">        a homogeneous dtype.</span>

<span class="sd">        .. deprecated:: 0.21.0</span>

<span class="sd">        NOTE: the dtypes of the blocks WILL BE PRESERVED HERE (unlike in</span>
<span class="sd">              as_matrix)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        copy : boolean, default True</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        values : a dict of dtype -&gt; Constructor Types</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;as_blocks is deprecated and will &quot;</span>
                      <span class="s2">&quot;be removed in a future version&quot;</span><span class="p">,</span>
                      <span class="ne">FutureWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_dict_of_blocks</span><span class="p">(</span><span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">blocks</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Internal property, property synonym for as_blocks()</span>

<span class="sd">        .. deprecated:: 0.21.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_blocks</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_to_dict_of_blocks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a dict of dtype -&gt; Constructor Types that</span>
<span class="sd">        each is a homogeneous dtype.</span>

<span class="sd">        Internal ONLY</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">to_dict</span><span class="p">(</span><span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

    <span class="nd">@deprecate_kwarg</span><span class="p">(</span><span class="n">old_arg_name</span><span class="o">=</span><span class="s1">&#39;raise_on_error&#39;</span><span class="p">,</span> <span class="n">new_arg_name</span><span class="o">=</span><span class="s1">&#39;errors&#39;</span><span class="p">,</span>
                     <span class="n">mapping</span><span class="o">=</span><span class="p">{</span><span class="kc">True</span><span class="p">:</span> <span class="s1">&#39;raise&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">:</span> <span class="s1">&#39;ignore&#39;</span><span class="p">})</span>
    <span class="k">def</span> <span class="nf">astype</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="s1">&#39;raise&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Cast a pandas object to a specified dtype ``dtype``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dtype : data type, or dict of column name -&gt; data type</span>
<span class="sd">            Use a numpy.dtype or Python type to cast entire pandas object to</span>
<span class="sd">            the same type. Alternatively, use {col: dtype, ...}, where col is a</span>
<span class="sd">            column label and dtype is a numpy.dtype or Python type to cast one</span>
<span class="sd">            or more of the DataFrame&#39;s columns to column-specific types.</span>
<span class="sd">        copy : bool, default True.</span>
<span class="sd">            Return a copy when ``copy=True`` (be very careful setting</span>
<span class="sd">            ``copy=False`` as changes to values then may propagate to other</span>
<span class="sd">            pandas objects).</span>
<span class="sd">        errors : {&#39;raise&#39;, &#39;ignore&#39;}, default &#39;raise&#39;.</span>
<span class="sd">            Control raising of exceptions on invalid data for provided dtype.</span>

<span class="sd">            - ``raise`` : allow exceptions to be raised</span>
<span class="sd">            - ``ignore`` : suppress exceptions. On error return original object</span>

<span class="sd">            .. versionadded:: 0.20.0</span>

<span class="sd">        raise_on_error : raise on invalid input</span>
<span class="sd">            .. deprecated:: 0.20.0</span>
<span class="sd">               Use ``errors`` instead</span>
<span class="sd">        kwargs : keyword arguments to pass on to the constructor</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        casted : type of caller</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; ser = pd.Series([1, 2], dtype=&#39;int32&#39;)</span>
<span class="sd">        &gt;&gt;&gt; ser</span>
<span class="sd">        0    1</span>
<span class="sd">        1    2</span>
<span class="sd">        dtype: int32</span>
<span class="sd">        &gt;&gt;&gt; ser.astype(&#39;int64&#39;)</span>
<span class="sd">        0    1</span>
<span class="sd">        1    2</span>
<span class="sd">        dtype: int64</span>

<span class="sd">        Convert to categorical type:</span>

<span class="sd">        &gt;&gt;&gt; ser.astype(&#39;category&#39;)</span>
<span class="sd">        0    1</span>
<span class="sd">        1    2</span>
<span class="sd">        dtype: category</span>
<span class="sd">        Categories (2, int64): [1, 2]</span>

<span class="sd">        Convert to ordered categorical type with custom ordering:</span>

<span class="sd">        &gt;&gt;&gt; ser.astype(&#39;category&#39;, ordered=True, categories=[2, 1])</span>
<span class="sd">        0    1</span>
<span class="sd">        1    2</span>
<span class="sd">        dtype: category</span>
<span class="sd">        Categories (2, int64): [2 &lt; 1]</span>

<span class="sd">        Note that using ``copy=False`` and changing data on a new</span>
<span class="sd">        pandas object may propagate changes:</span>

<span class="sd">        &gt;&gt;&gt; s1 = pd.Series([1,2])</span>
<span class="sd">        &gt;&gt;&gt; s2 = s1.astype(&#39;int&#39;, copy=False)</span>
<span class="sd">        &gt;&gt;&gt; s2[0] = 10</span>
<span class="sd">        &gt;&gt;&gt; s1  # note that s1[0] has changed too</span>
<span class="sd">        0    10</span>
<span class="sd">        1     2</span>
<span class="sd">        dtype: int64</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        pandas.to_datetime : Convert argument to datetime.</span>
<span class="sd">        pandas.to_timedelta : Convert argument to timedelta.</span>
<span class="sd">        pandas.to_numeric : Convert argument to a numeric type.</span>
<span class="sd">        numpy.ndarray.astype : Cast a numpy array to a specified type.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">is_dict_like</span><span class="p">(</span><span class="n">dtype</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># i.e. Series</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dtype</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s1">&#39;Only the Series name can be used for &#39;</span>
                                   <span class="s1">&#39;the key in Series dtype mappings.&#39;</span><span class="p">)</span>
                <span class="n">new_type</span> <span class="o">=</span> <span class="n">dtype</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">new_type</span><span class="p">,</span> <span class="n">copy</span><span class="p">,</span> <span class="n">errors</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                    <span class="s1">&#39;astype() only accepts a dtype arg of type dict when &#39;</span>
                    <span class="s1">&#39;invoked on Series and DataFrames. A single dtype must be &#39;</span>
                    <span class="s1">&#39;specified when invoked on a Panel.&#39;</span>
                <span class="p">)</span>
            <span class="k">for</span> <span class="n">col_name</span> <span class="ow">in</span> <span class="n">dtype</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">col_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s1">&#39;Only a column name can be used for the &#39;</span>
                                   <span class="s1">&#39;key in a dtype mappings argument.&#39;</span><span class="p">)</span>
            <span class="kn">from</span> <span class="nn">pandas</span> <span class="k">import</span> <span class="n">concat</span>
            <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">col_name</span><span class="p">,</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">col_name</span> <span class="ow">in</span> <span class="n">dtype</span><span class="p">:</span>
                    <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">col</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">[</span><span class="n">col_name</span><span class="p">],</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">col</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">if</span> <span class="n">copy</span> <span class="k">else</span> <span class="n">col</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">concat</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># else, only a single dtype is given</span>
        <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="n">errors</span><span class="p">,</span>
                                     <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">new_data</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make a copy of this objects data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        deep : boolean or string, default True</span>
<span class="sd">            Make a deep copy, including a copy of the data and the indices.</span>
<span class="sd">            With ``deep=False`` neither the indices or the data are copied.</span>

<span class="sd">            Note that when ``deep=True`` data is copied, actual python objects</span>
<span class="sd">            will not be copied recursively, only the reference to the object.</span>
<span class="sd">            This is in contrast to ``copy.deepcopy`` in the Standard Library,</span>
<span class="sd">            which recursively copies object data.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        copy : type of caller</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="n">deep</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__copy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="n">deep</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">memo</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">memo</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_convert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">datetime</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">numeric</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">timedelta</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">coerce</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Attempt to infer better dtype for object columns</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        datetime : boolean, default False</span>
<span class="sd">            If True, convert to date where possible.</span>
<span class="sd">        numeric : boolean, default False</span>
<span class="sd">            If True, attempt to convert to numbers (including strings), with</span>
<span class="sd">            unconvertible values becoming NaN.</span>
<span class="sd">        timedelta : boolean, default False</span>
<span class="sd">            If True, convert to timedelta where possible.</span>
<span class="sd">        coerce : boolean, default False</span>
<span class="sd">            If True, force conversion with unconvertible values converted to</span>
<span class="sd">            nulls (NaN or NaT)</span>
<span class="sd">        copy : boolean, default True</span>
<span class="sd">            If True, return a copy even if no copy is necessary (e.g. no</span>
<span class="sd">            conversion was done). Note: This is meant for internal use, and</span>
<span class="sd">            should not be confused with inplace.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        converted : same as input object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">datetime</span><span class="o">=</span><span class="n">datetime</span><span class="p">,</span> <span class="n">numeric</span><span class="o">=</span><span class="n">numeric</span><span class="p">,</span>
                               <span class="n">timedelta</span><span class="o">=</span><span class="n">timedelta</span><span class="p">,</span> <span class="n">coerce</span><span class="o">=</span><span class="n">coerce</span><span class="p">,</span>
                               <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">))</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="c1"># TODO: Remove in 0.18 or 2017, which ever is sooner</span>
    <span class="k">def</span> <span class="nf">convert_objects</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">convert_dates</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">convert_numeric</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">convert_timedeltas</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Deprecated.</span>
<span class="sd">        Attempt to infer better dtype for object columns</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        convert_dates : boolean, default True</span>
<span class="sd">            If True, convert to date where possible. If &#39;coerce&#39;, force</span>
<span class="sd">            conversion, with unconvertible values becoming NaT.</span>
<span class="sd">        convert_numeric : boolean, default False</span>
<span class="sd">            If True, attempt to coerce to numbers (including strings), with</span>
<span class="sd">            unconvertible values becoming NaN.</span>
<span class="sd">        convert_timedeltas : boolean, default True</span>
<span class="sd">            If True, convert to timedelta where possible. If &#39;coerce&#39;, force</span>
<span class="sd">            conversion, with unconvertible values becoming NaT.</span>
<span class="sd">        copy : boolean, default True</span>
<span class="sd">            If True, return a copy even if no copy is necessary (e.g. no</span>
<span class="sd">            conversion was done). Note: This is meant for internal use, and</span>
<span class="sd">            should not be confused with inplace.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        pandas.to_datetime : Convert argument to datetime.</span>
<span class="sd">        pandas.to_timedelta : Convert argument to timedelta.</span>
<span class="sd">        pandas.to_numeric : Return a fixed frequency timedelta index,</span>
<span class="sd">            with day as the default.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        converted : same as input object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;convert_objects is deprecated.  To re-infer data dtypes for &quot;</span>
               <span class="s2">&quot;object columns, use </span><span class="si">{klass}</span><span class="s2">.infer_objects()</span><span class="se">\n</span><span class="s2">For all &quot;</span>
               <span class="s2">&quot;other conversions use the data-type specific converters &quot;</span>
               <span class="s2">&quot;pd.to_datetime, pd.to_timedelta and pd.to_numeric.&quot;</span>
               <span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">klass</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="ne">FutureWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">convert_dates</span><span class="o">=</span><span class="n">convert_dates</span><span class="p">,</span>
                               <span class="n">convert_numeric</span><span class="o">=</span><span class="n">convert_numeric</span><span class="p">,</span>
                               <span class="n">convert_timedeltas</span><span class="o">=</span><span class="n">convert_timedeltas</span><span class="p">,</span>
                               <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">))</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">infer_objects</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Attempt to infer better dtypes for object columns.</span>

<span class="sd">        Attempts soft conversion of object-dtyped</span>
<span class="sd">        columns, leaving non-object and unconvertible</span>
<span class="sd">        columns unchanged. The inference rules are the</span>
<span class="sd">        same as during normal Series/DataFrame construction.</span>

<span class="sd">        .. versionadded:: 0.21.0</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        pandas.to_datetime : Convert argument to datetime.</span>
<span class="sd">        pandas.to_timedelta : Convert argument to timedelta.</span>
<span class="sd">        pandas.to_numeric : Convert argument to numeric typeR</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        converted : same type as input object</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&quot;A&quot;: [&quot;a&quot;, 1, 2, 3]})</span>
<span class="sd">        &gt;&gt;&gt; df = df.iloc[1:]</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">           A</span>
<span class="sd">        1  1</span>
<span class="sd">        2  2</span>
<span class="sd">        3  3</span>

<span class="sd">        &gt;&gt;&gt; df.dtypes</span>
<span class="sd">        A    object</span>
<span class="sd">        dtype: object</span>

<span class="sd">        &gt;&gt;&gt; df.infer_objects().dtypes</span>
<span class="sd">        A    int64</span>
<span class="sd">        dtype: object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># numeric=False necessary to only soft convert;</span>
        <span class="c1"># python objects will still be converted to</span>
        <span class="c1"># native numpy numeric types</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">datetime</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">numeric</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                               <span class="n">timedelta</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">coerce</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                               <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># Filling NA&#39;s</span>

    <span class="n">_shared_docs</span><span class="p">[</span><span class="s1">&#39;fillna&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        Fill NA/NaN values using the specified method</span>

<span class="s2">        Parameters</span>
<span class="s2">        ----------</span>
<span class="s2">        value : scalar, dict, Series, or DataFrame</span>
<span class="s2">            Value to use to fill holes (e.g. 0), alternately a</span>
<span class="s2">            dict/Series/DataFrame of values specifying which value to use for</span>
<span class="s2">            each index (for a Series) or column (for a DataFrame). (values not</span>
<span class="s2">            in the dict/Series/DataFrame will not be filled). This value cannot</span>
<span class="s2">            be a list.</span>
<span class="s2">        method : {&#39;backfill&#39;, &#39;bfill&#39;, &#39;pad&#39;, &#39;ffill&#39;, None}, default None</span>
<span class="s2">            Method to use for filling holes in reindexed Series</span>
<span class="s2">            pad / ffill: propagate last valid observation forward to next valid</span>
<span class="s2">            backfill / bfill: use NEXT valid observation to fill gap</span>
<span class="s2">        axis : </span><span class="si">%(axes_single_arg)s</span><span class="s2"></span>
<span class="s2">        inplace : boolean, default False</span>
<span class="s2">            If True, fill in place. Note: this will modify any</span>
<span class="s2">            other views on this object, (e.g. a no-copy slice for a column in a</span>
<span class="s2">            DataFrame).</span>
<span class="s2">        limit : int, default None</span>
<span class="s2">            If method is specified, this is the maximum number of consecutive</span>
<span class="s2">            NaN values to forward/backward fill. In other words, if there is</span>
<span class="s2">            a gap with more than this number of consecutive NaNs, it will only</span>
<span class="s2">            be partially filled. If method is not specified, this is the</span>
<span class="s2">            maximum number of entries along the entire axis where NaNs will be</span>
<span class="s2">            filled. Must be greater than 0 if not None.</span>
<span class="s2">        downcast : dict, default is None</span>
<span class="s2">            a dict of item-&gt;dtype of what to downcast if possible,</span>
<span class="s2">            or the string &#39;infer&#39; which will try to downcast to an appropriate</span>
<span class="s2">            equal type (e.g. float64 to int64 if possible)</span>

<span class="s2">        See Also</span>
<span class="s2">        --------</span>
<span class="s2">        reindex, asfreq</span>

<span class="s2">        Returns</span>
<span class="s2">        -------</span>
<span class="s2">        filled : </span><span class="si">%(klass)s</span><span class="s2"></span>

<span class="s2">        Examples</span>
<span class="s2">        --------</span>
<span class="s2">        &gt;&gt;&gt; df = pd.DataFrame([[np.nan, 2, np.nan, 0],</span>
<span class="s2">        ...                    [3, 4, np.nan, 1],</span>
<span class="s2">        ...                    [np.nan, np.nan, np.nan, 5],</span>
<span class="s2">        ...                    [np.nan, 3, np.nan, 4]],</span>
<span class="s2">        ...                    columns=list(&#39;ABCD&#39;))</span>
<span class="s2">        &gt;&gt;&gt; df</span>
<span class="s2">             A    B   C  D</span>
<span class="s2">        0  NaN  2.0 NaN  0</span>
<span class="s2">        1  3.0  4.0 NaN  1</span>
<span class="s2">        2  NaN  NaN NaN  5</span>
<span class="s2">        3  NaN  3.0 NaN  4</span>

<span class="s2">        Replace all NaN elements with 0s.</span>

<span class="s2">        &gt;&gt;&gt; df.fillna(0)</span>
<span class="s2">            A   B   C   D</span>
<span class="s2">        0   0.0 2.0 0.0 0</span>
<span class="s2">        1   3.0 4.0 0.0 1</span>
<span class="s2">        2   0.0 0.0 0.0 5</span>
<span class="s2">        3   0.0 3.0 0.0 4</span>

<span class="s2">        We can also propagate non-null values forward or backward.</span>

<span class="s2">        &gt;&gt;&gt; df.fillna(method=&#39;ffill&#39;)</span>
<span class="s2">            A   B   C   D</span>
<span class="s2">        0   NaN 2.0 NaN 0</span>
<span class="s2">        1   3.0 4.0 NaN 1</span>
<span class="s2">        2   3.0 4.0 NaN 5</span>
<span class="s2">        3   3.0 3.0 NaN 4</span>

<span class="s2">        Replace all NaN elements in column &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, and &#39;D&#39;, with 0, 1,</span>
<span class="s2">        2, and 3 respectively.</span>

<span class="s2">        &gt;&gt;&gt; values = {&#39;A&#39;: 0, &#39;B&#39;: 1, &#39;C&#39;: 2, &#39;D&#39;: 3}</span>
<span class="s2">        &gt;&gt;&gt; df.fillna(value=values)</span>
<span class="s2">            A   B   C   D</span>
<span class="s2">        0   0.0 2.0 2.0 0</span>
<span class="s2">        1   3.0 4.0 2.0 1</span>
<span class="s2">        2   0.0 1.0 2.0 5</span>
<span class="s2">        3   0.0 3.0 2.0 4</span>

<span class="s2">        Only replace the first NaN element.</span>

<span class="s2">        &gt;&gt;&gt; df.fillna(value=values, limit=1)</span>
<span class="s2">            A   B   C   D</span>
<span class="s2">        0   0.0 2.0 2.0 0</span>
<span class="s2">        1   3.0 4.0 NaN 1</span>
<span class="s2">        2   NaN 1.0 NaN 5</span>
<span class="s2">        3   NaN 3.0 NaN 4</span>
<span class="s2">        &quot;&quot;&quot;</span><span class="p">)</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s1">&#39;fillna&#39;</span><span class="p">]</span> <span class="o">%</span> <span class="n">_shared_doc_kwargs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">fillna</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
               <span class="n">limit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">downcast</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">inplace</span> <span class="o">=</span> <span class="n">validate_bool_kwarg</span><span class="p">(</span><span class="n">inplace</span><span class="p">,</span> <span class="s1">&#39;inplace&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;&quot;value&quot; parameter must be a scalar or dict, but &#39;</span>
                            <span class="s1">&#39;you passed a &quot;</span><span class="si">{0}</span><span class="s1">&quot;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_consolidate_inplace</span><span class="p">()</span>

        <span class="c1"># set the default here, so functions examining the signaure</span>
        <span class="c1"># can detect if something was set (e.g. in groupby) (GH9221)</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">method</span> <span class="o">=</span> <span class="n">missing</span><span class="o">.</span><span class="n">clean_fill_method</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>
        <span class="kn">from</span> <span class="nn">pandas</span> <span class="k">import</span> <span class="n">DataFrame</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">method</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;must specify a fill method or value&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_mixed_type</span> <span class="ow">and</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
                <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

                <span class="c1"># need to downcast here because of all of the transposes</span>
                <span class="n">result</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">downcast</span><span class="p">()</span>

                <span class="k">return</span> <span class="n">result</span>

            <span class="c1"># &gt; 3d</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Cannot fillna with a method for &gt; &#39;</span>
                                          <span class="s1">&#39;3dims&#39;</span><span class="p">)</span>

            <span class="c1"># 3d</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>

                <span class="c1"># fill in 2d chunks</span>
                <span class="n">result</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">col</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">value</span><span class="p">))</span>
                               <span class="k">for</span> <span class="n">col</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iteritems</span><span class="p">()])</span>
                <span class="n">new_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="o">.</span>\
                    <span class="n">from_dict</span><span class="p">(</span><span class="n">result</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                <span class="n">new_data</span> <span class="o">=</span> <span class="n">new_obj</span><span class="o">.</span><span class="n">_data</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># 2d or less</span>
                <span class="n">method</span> <span class="o">=</span> <span class="n">missing</span><span class="o">.</span><span class="n">clean_fill_method</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>
                <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
                                                  <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">,</span>
                                                  <span class="n">coerce</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                  <span class="n">downcast</span><span class="o">=</span><span class="n">downcast</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">method</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;cannot specify both a fill method and value&#39;</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">dict</span><span class="p">,</span> <span class="n">ABCSeries</span><span class="p">)):</span>
                    <span class="kn">from</span> <span class="nn">pandas</span> <span class="k">import</span> <span class="n">Series</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="n">Series</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                <span class="k">elif</span> <span class="ow">not</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
                    <span class="k">pass</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;invalid fill value with a </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span>
                                     <span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>

                <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="n">value</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span>
                                             <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">,</span>
                                             <span class="n">downcast</span><span class="o">=</span><span class="n">downcast</span><span class="p">)</span>

            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">dict</span><span class="p">,</span> <span class="n">ABCSeries</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Currently only can fill &#39;</span>
                                              <span class="s1">&#39;with dict/Series column &#39;</span>
                                              <span class="s1">&#39;by column&#39;</span><span class="p">)</span>

                <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span> <span class="k">if</span> <span class="n">inplace</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">compat</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">obj</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                    <span class="n">obj</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">downcast</span><span class="o">=</span><span class="n">downcast</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">result</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">inplace</span> <span class="k">else</span> <span class="kc">None</span>

            <span class="k">elif</span> <span class="ow">not</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
                <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="n">value</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span>
                                             <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">,</span>
                                             <span class="n">downcast</span><span class="o">=</span><span class="n">downcast</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">DataFrame</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">notna</span><span class="p">(),</span> <span class="n">value</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;invalid fill value with a </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_inplace</span><span class="p">(</span><span class="n">new_data</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">new_data</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ffill</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">downcast</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Synonym for :meth:`DataFrame.fillna(method=&#39;ffill&#39;) &lt;DataFrame.fillna&gt;`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;ffill&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">,</span>
                           <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span> <span class="n">downcast</span><span class="o">=</span><span class="n">downcast</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">bfill</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">downcast</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Synonym for :meth:`DataFrame.fillna(method=&#39;bfill&#39;) &lt;DataFrame.fillna&gt;`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;bfill&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">,</span>
                           <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span> <span class="n">downcast</span><span class="o">=</span><span class="n">downcast</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">replace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">to_replace</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">regex</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;pad&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Replace values given in &#39;to_replace&#39; with &#39;value&#39;.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        to_replace : str, regex, list, dict, Series, numeric, or None</span>

<span class="sd">            * str or regex:</span>

<span class="sd">                - str: string exactly matching `to_replace` will be replaced</span>
<span class="sd">                  with `value`</span>
<span class="sd">                - regex: regexs matching `to_replace` will be replaced with</span>
<span class="sd">                  `value`</span>

<span class="sd">            * list of str, regex, or numeric:</span>

<span class="sd">                - First, if `to_replace` and `value` are both lists, they</span>
<span class="sd">                  **must** be the same length.</span>
<span class="sd">                - Second, if ``regex=True`` then all of the strings in **both**</span>
<span class="sd">                  lists will be interpreted as regexs otherwise they will match</span>
<span class="sd">                  directly. This doesn&#39;t matter much for `value` since there</span>
<span class="sd">                  are only a few possible substitution regexes you can use.</span>
<span class="sd">                - str and regex rules apply as above.</span>

<span class="sd">            * dict:</span>

<span class="sd">                - Nested dictionaries, e.g., {&#39;a&#39;: {&#39;b&#39;: nan}}, are read as</span>
<span class="sd">                  follows: look in column &#39;a&#39; for the value &#39;b&#39; and replace it</span>
<span class="sd">                  with nan. You can nest regular expressions as well. Note that</span>
<span class="sd">                  column names (the top-level dictionary keys in a nested</span>
<span class="sd">                  dictionary) **cannot** be regular expressions.</span>
<span class="sd">                - Keys map to column names and values map to substitution</span>
<span class="sd">                  values. You can treat this as a special case of passing two</span>
<span class="sd">                  lists except that you are specifying the column to search in.</span>

<span class="sd">            * None:</span>

<span class="sd">                - This means that the ``regex`` argument must be a string,</span>
<span class="sd">                  compiled regular expression, or list, dict, ndarray or Series</span>
<span class="sd">                  of such elements. If `value` is also ``None`` then this</span>
<span class="sd">                  **must** be a nested dictionary or ``Series``.</span>

<span class="sd">            See the examples section for examples of each of these.</span>
<span class="sd">        value : scalar, dict, list, str, regex, default None</span>
<span class="sd">            Value to use to fill holes (e.g. 0), alternately a dict of values</span>
<span class="sd">            specifying which value to use for each column (columns not in the</span>
<span class="sd">            dict will not be filled). Regular expressions, strings and lists or</span>
<span class="sd">            dicts of such objects are also allowed.</span>
<span class="sd">        inplace : boolean, default False</span>
<span class="sd">            If True, in place. Note: this will modify any</span>
<span class="sd">            other views on this object (e.g. a column from a DataFrame).</span>
<span class="sd">            Returns the caller if this is True.</span>
<span class="sd">        limit : int, default None</span>
<span class="sd">            Maximum size gap to forward or backward fill</span>
<span class="sd">        regex : bool or same types as `to_replace`, default False</span>
<span class="sd">            Whether to interpret `to_replace` and/or `value` as regular</span>
<span class="sd">            expressions. If this is ``True`` then `to_replace` *must* be a</span>
<span class="sd">            string. Otherwise, `to_replace` must be ``None`` because this</span>
<span class="sd">            parameter will be interpreted as a regular expression or a list,</span>
<span class="sd">            dict, or array of regular expressions.</span>
<span class="sd">        method : string, optional, {&#39;pad&#39;, &#39;ffill&#39;, &#39;bfill&#39;}</span>
<span class="sd">            The method to use when for replacement, when ``to_replace`` is a</span>
<span class="sd">            ``list``.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        NDFrame.reindex</span>
<span class="sd">        NDFrame.asfreq</span>
<span class="sd">        NDFrame.fillna</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        filled : NDFrame</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        AssertionError</span>
<span class="sd">            * If `regex` is not a ``bool`` and `to_replace` is not ``None``.</span>
<span class="sd">        TypeError</span>
<span class="sd">            * If `to_replace` is a ``dict`` and `value` is not a ``list``,</span>
<span class="sd">              ``dict``, ``ndarray``, or ``Series``</span>
<span class="sd">            * If `to_replace` is ``None`` and `regex` is not compilable into a</span>
<span class="sd">              regular expression or is a list, dict, ndarray, or Series.</span>
<span class="sd">        ValueError</span>
<span class="sd">            * If `to_replace` and `value` are ``list`` s or ``ndarray`` s, but</span>
<span class="sd">              they are not the same length.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        * Regex substitution is performed under the hood with ``re.sub``. The</span>
<span class="sd">          rules for substitution for ``re.sub`` are the same.</span>
<span class="sd">        * Regular expressions will only substitute on strings, meaning you</span>
<span class="sd">          cannot provide, for example, a regular expression matching floating</span>
<span class="sd">          point numbers and expect the columns in your frame that have a</span>
<span class="sd">          numeric dtype to be matched. However, if those floating point numbers</span>
<span class="sd">          *are* strings, then you can do this.</span>
<span class="sd">        * This method has *a lot* of options. You are encouraged to experiment</span>
<span class="sd">          and play with this method to gain intuition about how it works.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">inplace</span> <span class="o">=</span> <span class="n">validate_bool_kwarg</span><span class="p">(</span><span class="n">inplace</span><span class="p">,</span> <span class="s1">&#39;inplace&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_bool</span><span class="p">(</span><span class="n">regex</span><span class="p">)</span> <span class="ow">and</span> <span class="n">to_replace</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;&#39;to_replace&#39; must be &#39;None&#39; if &#39;regex&#39; is &quot;</span>
                                 <span class="s2">&quot;not a bool&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;the &quot;axis&quot; argument is deprecated &#39;</span>
                          <span class="s1">&#39;and will be removed in&#39;</span>
                          <span class="s1">&#39;v0.13; this argument has no effect&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_consolidate_inplace</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># passing a single value that is scalar like</span>
            <span class="c1"># when value is None (GH5319), for compat</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_dict_like</span><span class="p">(</span><span class="n">to_replace</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_dict_like</span><span class="p">(</span><span class="n">regex</span><span class="p">):</span>
                <span class="n">to_replace</span> <span class="o">=</span> <span class="p">[</span><span class="n">to_replace</span><span class="p">]</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">to_replace</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
                <span class="k">return</span> <span class="n">_single_replace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">to_replace</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">inplace</span><span class="p">,</span>
                                       <span class="n">limit</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_dict_like</span><span class="p">(</span><span class="n">to_replace</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">is_dict_like</span><span class="p">(</span><span class="n">regex</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;If &quot;to_replace&quot; and &quot;value&quot; are both None&#39;</span>
                                    <span class="s1">&#39; and &quot;to_replace&quot; is not a list, then &#39;</span>
                                    <span class="s1">&#39;regex must be a mapping&#39;</span><span class="p">)</span>
                <span class="n">to_replace</span> <span class="o">=</span> <span class="n">regex</span>
                <span class="n">regex</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="n">items</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">compat</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(</span><span class="n">to_replace</span><span class="p">))</span>
            <span class="n">keys</span><span class="p">,</span> <span class="n">values</span> <span class="o">=</span> <span class="n">lzip</span><span class="p">(</span><span class="o">*</span><span class="n">items</span><span class="p">)</span> <span class="ow">or</span> <span class="p">([],</span> <span class="p">[])</span>

            <span class="n">are_mappings</span> <span class="o">=</span> <span class="p">[</span><span class="n">is_dict_like</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">values</span><span class="p">]</span>

            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">are_mappings</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">are_mappings</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;If a nested mapping is passed, all values&quot;</span>
                                    <span class="s2">&quot; of the top level mapping must be &quot;</span>
                                    <span class="s2">&quot;mappings&quot;</span><span class="p">)</span>
                <span class="c1"># passed a nested dict/Series</span>
                <span class="n">to_rep_dict</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="n">value_dict</span> <span class="o">=</span> <span class="p">{}</span>

                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">items</span><span class="p">:</span>
                    <span class="n">keys</span><span class="p">,</span> <span class="n">values</span> <span class="o">=</span> <span class="n">lzip</span><span class="p">(</span><span class="o">*</span><span class="n">v</span><span class="o">.</span><span class="n">items</span><span class="p">())</span> <span class="ow">or</span> <span class="p">([],</span> <span class="p">[])</span>
                    <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Replacement not allowed with &quot;</span>
                                         <span class="s2">&quot;overlapping keys and values&quot;</span><span class="p">)</span>
                    <span class="n">to_rep_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span>
                    <span class="n">value_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>

                <span class="n">to_replace</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="n">to_rep_dict</span><span class="p">,</span> <span class="n">value_dict</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">to_replace</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="n">keys</span><span class="p">,</span> <span class="n">values</span>

            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">to_replace</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">,</span>
                                <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span> <span class="n">regex</span><span class="o">=</span><span class="n">regex</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>

            <span class="c1"># need a non-zero len on all axes</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_ORDERS</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">a</span><span class="p">)):</span>
                    <span class="k">return</span> <span class="bp">self</span>

            <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span>
            <span class="k">if</span> <span class="n">is_dict_like</span><span class="p">(</span><span class="n">to_replace</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">is_dict_like</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>  <span class="c1"># {&#39;A&#39; : NA} -&gt; {&#39;A&#39; : 0}</span>
                    <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span> <span class="k">if</span> <span class="n">inplace</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                    <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">src</span> <span class="ow">in</span> <span class="n">compat</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(</span><span class="n">to_replace</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">value</span> <span class="ow">and</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                            <span class="c1"># object conversion is handled in</span>
                            <span class="c1"># series.replace which is called recursivelly</span>
                            <span class="n">res</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">to_replace</span><span class="o">=</span><span class="n">src</span><span class="p">,</span>
                                                    <span class="n">value</span><span class="o">=</span><span class="n">value</span><span class="p">[</span><span class="n">c</span><span class="p">],</span>
                                                    <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                    <span class="n">regex</span><span class="o">=</span><span class="n">regex</span><span class="p">)</span>
                    <span class="k">return</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">inplace</span> <span class="k">else</span> <span class="n">res</span>

                <span class="c1"># {&#39;A&#39;: NA} -&gt; 0</span>
                <span class="k">elif</span> <span class="ow">not</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
                    <span class="n">keys</span> <span class="o">=</span> <span class="p">[(</span><span class="n">k</span><span class="p">,</span> <span class="n">src</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">src</span> <span class="ow">in</span> <span class="n">compat</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(</span><span class="n">to_replace</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span>
                    <span class="n">keys_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
                    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">src</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">keys</span><span class="p">):</span>
                        <span class="n">convert</span> <span class="o">=</span> <span class="n">i</span> <span class="o">==</span> <span class="n">keys_len</span>
                        <span class="n">new_data</span> <span class="o">=</span> <span class="n">new_data</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">to_replace</span><span class="o">=</span><span class="n">src</span><span class="p">,</span>
                                                    <span class="n">value</span><span class="o">=</span><span class="n">value</span><span class="p">,</span>
                                                    <span class="nb">filter</span><span class="o">=</span><span class="p">[</span><span class="n">k</span><span class="p">],</span>
                                                    <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">,</span>
                                                    <span class="n">regex</span><span class="o">=</span><span class="n">regex</span><span class="p">,</span>
                                                    <span class="n">convert</span><span class="o">=</span><span class="n">convert</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;value argument must be scalar, dict, or &#39;</span>
                                    <span class="s1">&#39;Series&#39;</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">to_replace</span><span class="p">):</span>  <span class="c1"># [NA, &#39;&#39;] -&gt; [0, &#39;missing&#39;]</span>
                <span class="k">if</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">to_replace</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Replacement lists must match &#39;</span>
                                         <span class="s1">&#39;in length. Expecting </span><span class="si">%d</span><span class="s1"> got </span><span class="si">%d</span><span class="s1"> &#39;</span> <span class="o">%</span>
                                         <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">to_replace</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)))</span>

                    <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">replace_list</span><span class="p">(</span><span class="n">src_list</span><span class="o">=</span><span class="n">to_replace</span><span class="p">,</span>
                                                       <span class="n">dest_list</span><span class="o">=</span><span class="n">value</span><span class="p">,</span>
                                                       <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">,</span>
                                                       <span class="n">regex</span><span class="o">=</span><span class="n">regex</span><span class="p">)</span>

                <span class="k">else</span><span class="p">:</span>  <span class="c1"># [NA, &#39;&#39;] -&gt; 0</span>
                    <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">to_replace</span><span class="o">=</span><span class="n">to_replace</span><span class="p">,</span>
                                                  <span class="n">value</span><span class="o">=</span><span class="n">value</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">,</span>
                                                  <span class="n">regex</span><span class="o">=</span><span class="n">regex</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">to_replace</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">is_re_compilable</span><span class="p">(</span><span class="n">regex</span><span class="p">)</span> <span class="ow">or</span>
                        <span class="n">is_list_like</span><span class="p">(</span><span class="n">regex</span><span class="p">)</span> <span class="ow">or</span> <span class="n">is_dict_like</span><span class="p">(</span><span class="n">regex</span><span class="p">)):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;&#39;regex&#39; must be a string or a compiled &quot;</span>
                                    <span class="s2">&quot;regular expression or a list or dict of &quot;</span>
                                    <span class="s2">&quot;strings or regular expressions, you &quot;</span>
                                    <span class="s2">&quot;passed a&quot;</span>
                                    <span class="s2">&quot; </span><span class="si">{0!r}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">regex</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">regex</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span>
                                    <span class="n">regex</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>

                <span class="c1"># dest iterable dict-like</span>
                <span class="k">if</span> <span class="n">is_dict_like</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>  <span class="c1"># NA -&gt; {&#39;A&#39; : 0, &#39;B&#39; : -1}</span>
                    <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span>

                    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">compat</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                            <span class="n">new_data</span> <span class="o">=</span> <span class="n">new_data</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">to_replace</span><span class="o">=</span><span class="n">to_replace</span><span class="p">,</span>
                                                        <span class="n">value</span><span class="o">=</span><span class="n">v</span><span class="p">,</span> <span class="nb">filter</span><span class="o">=</span><span class="p">[</span><span class="n">k</span><span class="p">],</span>
                                                        <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">,</span>
                                                        <span class="n">regex</span><span class="o">=</span><span class="n">regex</span><span class="p">)</span>

                <span class="k">elif</span> <span class="ow">not</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>  <span class="c1"># NA -&gt; 0</span>
                    <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">to_replace</span><span class="o">=</span><span class="n">to_replace</span><span class="p">,</span>
                                                  <span class="n">value</span><span class="o">=</span><span class="n">value</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">,</span>
                                                  <span class="n">regex</span><span class="o">=</span><span class="n">regex</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;Invalid &quot;to_replace&quot; type: &#39;</span>
                           <span class="s1">&#39;</span><span class="si">{0!r}</span><span class="s1">&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">to_replace</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>  <span class="c1"># pragma: no cover</span>

        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_inplace</span><span class="p">(</span><span class="n">new_data</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">new_data</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="n">_shared_docs</span><span class="p">[</span><span class="s1">&#39;interpolate&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        Please note that only ``method=&#39;linear&#39;`` is supported for</span>
<span class="s2">        DataFrames/Series with a MultiIndex.</span>

<span class="s2">        Parameters</span>
<span class="s2">        ----------</span>
<span class="s2">        method : {&#39;linear&#39;, &#39;time&#39;, &#39;index&#39;, &#39;values&#39;, &#39;nearest&#39;, &#39;zero&#39;,</span>
<span class="s2">                  &#39;slinear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;, &#39;barycentric&#39;, &#39;krogh&#39;,</span>
<span class="s2">                  &#39;polynomial&#39;, &#39;spline&#39;, &#39;piecewise_polynomial&#39;,</span>
<span class="s2">                  &#39;from_derivatives&#39;, &#39;pchip&#39;, &#39;akima&#39;}</span>

<span class="s2">            * &#39;linear&#39;: ignore the index and treat the values as equally</span>
<span class="s2">              spaced. This is the only method supported on MultiIndexes.</span>
<span class="s2">              default</span>
<span class="s2">            * &#39;time&#39;: interpolation works on daily and higher resolution</span>
<span class="s2">              data to interpolate given length of interval</span>
<span class="s2">            * &#39;index&#39;, &#39;values&#39;: use the actual numerical values of the index</span>
<span class="s2">            * &#39;nearest&#39;, &#39;zero&#39;, &#39;slinear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;,</span>
<span class="s2">              &#39;barycentric&#39;, &#39;polynomial&#39; is passed to</span>
<span class="s2">              ``scipy.interpolate.interp1d``. Both &#39;polynomial&#39; and &#39;spline&#39;</span>
<span class="s2">              require that you also specify an `order` (int),</span>
<span class="s2">              e.g. df.interpolate(method=&#39;polynomial&#39;, order=4).</span>
<span class="s2">              These use the actual numerical values of the index.</span>
<span class="s2">            * &#39;krogh&#39;, &#39;piecewise_polynomial&#39;, &#39;spline&#39;, &#39;pchip&#39; and &#39;akima&#39;</span>
<span class="s2">              are all wrappers around the scipy interpolation methods of</span>
<span class="s2">              similar names. These use the actual numerical values of the</span>
<span class="s2">              index. For more information on their behavior, see the</span>
<span class="s2">              `scipy documentation</span>
<span class="s2">              &lt;http://docs.scipy.org/doc/scipy/reference/interpolate.html#univariate-interpolation&gt;`__</span>
<span class="s2">              and `tutorial documentation</span>
<span class="s2">              &lt;http://docs.scipy.org/doc/scipy/reference/tutorial/interpolate.html&gt;`__</span>
<span class="s2">            * &#39;from_derivatives&#39; refers to BPoly.from_derivatives which</span>
<span class="s2">              replaces &#39;piecewise_polynomial&#39; interpolation method in</span>
<span class="s2">              scipy 0.18</span>

<span class="s2">            .. versionadded:: 0.18.1</span>

<span class="s2">               Added support for the &#39;akima&#39; method</span>
<span class="s2">               Added interpolate method &#39;from_derivatives&#39; which replaces</span>
<span class="s2">               &#39;piecewise_polynomial&#39; in scipy 0.18; backwards-compatible with</span>
<span class="s2">               scipy &lt; 0.18</span>

<span class="s2">        axis : {0, 1}, default 0</span>
<span class="s2">            * 0: fill column-by-column</span>
<span class="s2">            * 1: fill row-by-row</span>
<span class="s2">        limit : int, default None.</span>
<span class="s2">            Maximum number of consecutive NaNs to fill. Must be greater than 0.</span>
<span class="s2">        limit_direction : {&#39;forward&#39;, &#39;backward&#39;, &#39;both&#39;}, default &#39;forward&#39;</span>
<span class="s2">            If limit is specified, consecutive NaNs will be filled in this</span>
<span class="s2">            direction.</span>

<span class="s2">            .. versionadded:: 0.17.0</span>

<span class="s2">        inplace : bool, default False</span>
<span class="s2">            Update the NDFrame in place if possible.</span>
<span class="s2">        downcast : optional, &#39;infer&#39; or None, defaults to None</span>
<span class="s2">            Downcast dtypes if possible.</span>
<span class="s2">        kwargs : keyword arguments to pass on to the interpolating function.</span>

<span class="s2">        Returns</span>
<span class="s2">        -------</span>
<span class="s2">        Series or DataFrame of same shape interpolated at the NaNs</span>

<span class="s2">        See Also</span>
<span class="s2">        --------</span>
<span class="s2">        reindex, replace, fillna</span>

<span class="s2">        Examples</span>
<span class="s2">        --------</span>

<span class="s2">        Filling in NaNs</span>

<span class="s2">        &gt;&gt;&gt; s = pd.Series([0, 1, np.nan, 3])</span>
<span class="s2">        &gt;&gt;&gt; s.interpolate()</span>
<span class="s2">        0    0</span>
<span class="s2">        1    1</span>
<span class="s2">        2    2</span>
<span class="s2">        3    3</span>
<span class="s2">        dtype: float64</span>

<span class="s2">        &quot;&quot;&quot;</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s1">&#39;interpolate&#39;</span><span class="p">]</span> <span class="o">%</span> <span class="n">_shared_doc_kwargs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">interpolate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">limit_direction</span><span class="o">=</span><span class="s1">&#39;forward&#39;</span><span class="p">,</span> <span class="n">downcast</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Interpolate values according to different methods.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">inplace</span> <span class="o">=</span> <span class="n">validate_bool_kwarg</span><span class="p">(</span><span class="n">inplace</span><span class="p">,</span> <span class="s1">&#39;inplace&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Interpolate has not been implemented &quot;</span>
                                      <span class="s2">&quot;on Panel and Panel 4D objects.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_info_axis_name</span>
            <span class="n">_maybe_transposed_self</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">_maybe_transposed_self</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_maybe_transposed_self</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">_maybe_transposed_self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">_maybe_transposed_self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">alt_ax</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">ax</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">alt_ax</span> <span class="o">=</span> <span class="n">ax</span>

        <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">_maybe_transposed_self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">)</span> <span class="ow">and</span>
                <span class="n">method</span> <span class="o">!=</span> <span class="s1">&#39;linear&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Only `method=linear` interpolation is supported &quot;</span>
                             <span class="s2">&quot;on MultiIndexes.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">_maybe_transposed_self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">get_dtype_counts</span><span class="p">()</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                <span class="s1">&#39;object&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">_maybe_transposed_self</span><span class="o">.</span><span class="n">T</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Cannot interpolate with all NaNs.&quot;</span><span class="p">)</span>

        <span class="c1"># create/use the index</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;linear&#39;</span><span class="p">:</span>
            <span class="c1"># prior default</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">_maybe_transposed_self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">alt_ax</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">_maybe_transposed_self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">alt_ax</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">isna</span><span class="p">(</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Interpolation with NaNs in the index &quot;</span>
                                      <span class="s2">&quot;has not been implemented. Try filling &quot;</span>
                                      <span class="s2">&quot;those NaNs before interpolating.&quot;</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">_maybe_transposed_self</span><span class="o">.</span><span class="n">_data</span>
        <span class="n">new_data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span>
                                    <span class="n">values</span><span class="o">=</span><span class="n">_maybe_transposed_self</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span>
                                    <span class="n">limit_direction</span><span class="o">=</span><span class="n">limit_direction</span><span class="p">,</span>
                                    <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">,</span> <span class="n">downcast</span><span class="o">=</span><span class="n">downcast</span><span class="p">,</span>
                                    <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">new_data</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">_data</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_inplace</span><span class="p">(</span><span class="n">new_data</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">new_data</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">T</span>
            <span class="k">return</span> <span class="n">res</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># Timeseries methods Methods</span>

    <span class="k">def</span> <span class="nf">asof</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">where</span><span class="p">,</span> <span class="n">subset</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The last row without any NaN is taken (or the last row without</span>
<span class="sd">        NaN considering only the subset of columns in the case of a DataFrame)</span>

<span class="sd">        .. versionadded:: 0.19.0 For DataFrame</span>

<span class="sd">        If there is no good value, NaN is returned for a Series</span>
<span class="sd">        a Series of NaN values for a DataFrame</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        where : date or array of dates</span>
<span class="sd">        subset : string or list of strings, default None</span>
<span class="sd">           if not None use these columns for NaN propagation</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Dates are assumed to be sorted</span>
<span class="sd">        Raises if this is not the case</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        where is scalar</span>

<span class="sd">          - value or NaN if input is Series</span>
<span class="sd">          - Series if input is DataFrame</span>

<span class="sd">        where is Index: same shape object as input</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        merge_asof</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">where</span><span class="p">,</span> <span class="n">compat</span><span class="o">.</span><span class="n">string_types</span><span class="p">):</span>
            <span class="kn">from</span> <span class="nn">pandas</span> <span class="k">import</span> <span class="n">to_datetime</span>
            <span class="n">where</span> <span class="o">=</span> <span class="n">to_datetime</span><span class="p">(</span><span class="n">where</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">is_monotonic</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;asof requires a sorted index&quot;</span><span class="p">)</span>

        <span class="n">is_series</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ABCSeries</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">is_series</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">subset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;subset is not valid for Series&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;asof is not implemented &quot;</span>
                                      <span class="s2">&quot;for </span><span class="si">{type}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">subset</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">subset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">subset</span><span class="p">):</span>
                <span class="n">subset</span> <span class="o">=</span> <span class="p">[</span><span class="n">subset</span><span class="p">]</span>

        <span class="n">is_list</span> <span class="o">=</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">where</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_list</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">PeriodIndex</span><span class="p">):</span>
                <span class="n">where</span> <span class="o">=</span> <span class="n">Period</span><span class="p">(</span><span class="n">where</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">freq</span><span class="p">)</span><span class="o">.</span><span class="n">ordinal</span>
                <span class="n">start</span> <span class="o">=</span> <span class="n">start</span><span class="o">.</span><span class="n">ordinal</span>

            <span class="k">if</span> <span class="n">where</span> <span class="o">&lt;</span> <span class="n">start</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">is_series</span><span class="p">:</span>
                    <span class="kn">from</span> <span class="nn">pandas</span> <span class="k">import</span> <span class="n">Series</span>
                    <span class="k">return</span> <span class="n">Series</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">where</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

            <span class="c1"># It&#39;s always much faster to use a *while* loop here for</span>
            <span class="c1"># Series than pre-computing all the NAs. However a</span>
            <span class="c1"># *while* loop is extremely expensive for DataFrame</span>
            <span class="c1"># so we later pre-compute all the NAs and use the same</span>
            <span class="c1"># code path whether *where* is a scalar or list.</span>
            <span class="c1"># See PR: https://github.com/pandas-dev/pandas/pull/14476</span>
            <span class="k">if</span> <span class="n">is_series</span><span class="p">:</span>
                <span class="n">loc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">where</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">loc</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">loc</span> <span class="o">-=</span> <span class="mi">1</span>

                <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span>
                <span class="k">while</span> <span class="n">loc</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">isna</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="n">loc</span><span class="p">]):</span>
                    <span class="n">loc</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="k">return</span> <span class="n">values</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">where</span><span class="p">,</span> <span class="n">Index</span><span class="p">):</span>
            <span class="n">where</span> <span class="o">=</span> <span class="n">Index</span><span class="p">(</span><span class="n">where</span><span class="p">)</span> <span class="k">if</span> <span class="n">is_list</span> <span class="k">else</span> <span class="n">Index</span><span class="p">([</span><span class="n">where</span><span class="p">])</span>

        <span class="n">nulls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">isna</span><span class="p">()</span> <span class="k">if</span> <span class="n">is_series</span> <span class="k">else</span> <span class="bp">self</span><span class="p">[</span><span class="n">subset</span><span class="p">]</span><span class="o">.</span><span class="n">isna</span><span class="p">()</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nulls</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">is_series</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">where</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">is_list</span><span class="p">:</span>
                <span class="kn">from</span> <span class="nn">pandas</span> <span class="k">import</span> <span class="n">DataFrame</span>
                <span class="k">return</span> <span class="n">DataFrame</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">where</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="kn">from</span> <span class="nn">pandas</span> <span class="k">import</span> <span class="n">Series</span>
                <span class="k">return</span> <span class="n">Series</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">where</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="n">locs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">asof_locs</span><span class="p">(</span><span class="n">where</span><span class="p">,</span> <span class="o">~</span><span class="p">(</span><span class="n">nulls</span><span class="o">.</span><span class="n">values</span><span class="p">))</span>

        <span class="c1"># mask the missing</span>
        <span class="n">missing</span> <span class="o">=</span> <span class="n">locs</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">locs</span><span class="p">,</span> <span class="n">is_copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">data</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">where</span>
        <span class="n">data</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">missing</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">return</span> <span class="n">data</span> <span class="k">if</span> <span class="n">is_list</span> <span class="k">else</span> <span class="n">data</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># Action Methods</span>

    <span class="n">_shared_docs</span><span class="p">[</span><span class="s1">&#39;isna&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        Return a boolean same-sized object indicating if the values are NA.</span>

<span class="s2">        See Also</span>
<span class="s2">        --------</span>
<span class="s2">        </span><span class="si">%(klass)s</span><span class="s2">.notna : boolean inverse of isna</span>
<span class="s2">        </span><span class="si">%(klass)s</span><span class="s2">.isnull : alias of isna</span>
<span class="s2">        isna : top-level isna</span>
<span class="s2">        &quot;&quot;&quot;</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s1">&#39;isna&#39;</span><span class="p">]</span> <span class="o">%</span> <span class="n">_shared_doc_kwargs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">isna</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">isna</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s1">&#39;isna&#39;</span><span class="p">]</span> <span class="o">%</span> <span class="n">_shared_doc_kwargs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">isnull</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">isna</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="n">_shared_docs</span><span class="p">[</span><span class="s1">&#39;notna&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        Return a boolean same-sized object indicating if the values are</span>
<span class="s2">        not NA.</span>

<span class="s2">        See Also</span>
<span class="s2">        --------</span>
<span class="s2">        </span><span class="si">%(klass)s</span><span class="s2">.isna : boolean inverse of notna</span>
<span class="s2">        </span><span class="si">%(klass)s</span><span class="s2">.notnull : alias of notna</span>
<span class="s2">        notna : top-level notna</span>
<span class="s2">        &quot;&quot;&quot;</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s1">&#39;notna&#39;</span><span class="p">]</span> <span class="o">%</span> <span class="n">_shared_doc_kwargs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">notna</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">notna</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s1">&#39;notna&#39;</span><span class="p">]</span> <span class="o">%</span> <span class="n">_shared_doc_kwargs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">notnull</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">notna</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_clip_with_scalar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">lower</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">isna</span><span class="p">(</span><span class="n">lower</span><span class="p">)))</span> <span class="ow">or</span>
                <span class="p">(</span><span class="n">upper</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">isna</span><span class="p">(</span><span class="n">upper</span><span class="p">)))):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot use an NA value as a clip threshold&quot;</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">isna</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

        <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="nb">all</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">upper</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">result</span> <span class="o">&gt;=</span> <span class="n">upper</span><span class="p">,</span> <span class="n">upper</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">lower</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">result</span> <span class="o">&lt;=</span> <span class="n">lower</span><span class="p">,</span> <span class="n">lower</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">mask</span><span class="p">):</span>
            <span class="n">result</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

        <span class="n">axes_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_construct_axes_dict</span><span class="p">()</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="o">**</span><span class="n">axes_dict</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_inplace</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">_clip_with_one_bound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">inplace</span><span class="p">):</span>

        <span class="n">inplace</span> <span class="o">=</span> <span class="n">validate_bool_kwarg</span><span class="p">(</span><span class="n">inplace</span><span class="p">,</span> <span class="s1">&#39;inplace&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

        <span class="c1"># method is self.le for upper bound and self.ge for lower bound</span>
        <span class="k">if</span> <span class="n">is_scalar</span><span class="p">(</span><span class="n">threshold</span><span class="p">)</span> <span class="ow">and</span> <span class="n">is_number</span><span class="p">(</span><span class="n">threshold</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;le&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clip_with_scalar</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clip_with_scalar</span><span class="p">(</span><span class="n">threshold</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">)</span>

        <span class="n">subset</span> <span class="o">=</span> <span class="n">method</span><span class="p">(</span><span class="n">threshold</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span> <span class="o">|</span> <span class="n">isna</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c1"># GH #15390</span>
        <span class="c1"># In order for where method to work, the threshold must</span>
        <span class="c1"># be transformed to NDFrame from other array like structure.</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">threshold</span><span class="p">,</span> <span class="n">ABCSeries</span><span class="p">))</span> <span class="ow">and</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">threshold</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ABCSeries</span><span class="p">):</span>
                <span class="n">threshold</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">threshold</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">threshold</span> <span class="o">=</span> <span class="n">_align_method_FRAME</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">threshold</span><span class="p">),</span>
                                                <span class="n">axis</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">subset</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">clip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lower</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">upper</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
             <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Trim values at input threshold(s).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lower : float or array_like, default None</span>
<span class="sd">        upper : float or array_like, default None</span>
<span class="sd">        axis : int or string axis name, optional</span>
<span class="sd">            Align object with lower and upper along the given axis.</span>
<span class="sd">        inplace : boolean, default False</span>
<span class="sd">            Whether to perform the operation in place on the data</span>
<span class="sd">                .. versionadded:: 0.21.0</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        clipped : Series</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">                  0         1</span>
<span class="sd">        0  0.335232 -1.256177</span>
<span class="sd">        1 -1.367855  0.746646</span>
<span class="sd">        2  0.027753 -1.176076</span>
<span class="sd">        3  0.230930 -0.679613</span>
<span class="sd">        4  1.261967  0.570967</span>

<span class="sd">        &gt;&gt;&gt; df.clip(-1.0, 0.5)</span>
<span class="sd">                  0         1</span>
<span class="sd">        0  0.335232 -1.000000</span>
<span class="sd">        1 -1.000000  0.500000</span>
<span class="sd">        2  0.027753 -1.000000</span>
<span class="sd">        3  0.230930 -0.679613</span>
<span class="sd">        4  0.500000  0.500000</span>

<span class="sd">        &gt;&gt;&gt; t</span>
<span class="sd">        0   -0.3</span>
<span class="sd">        1   -0.2</span>
<span class="sd">        2   -0.1</span>
<span class="sd">        3    0.0</span>
<span class="sd">        4    0.1</span>
<span class="sd">        dtype: float64</span>

<span class="sd">        &gt;&gt;&gt; df.clip(t, t + 1, axis=0)</span>
<span class="sd">                  0         1</span>
<span class="sd">        0  0.335232 -0.300000</span>
<span class="sd">        1 -0.200000  0.746646</span>
<span class="sd">        2  0.027753 -0.100000</span>
<span class="sd">        3  0.230930  0.000000</span>
<span class="sd">        4  1.100000  0.570967</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ABCPanel</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;clip is not supported yet for panels&quot;</span><span class="p">)</span>

        <span class="n">inplace</span> <span class="o">=</span> <span class="n">validate_bool_kwarg</span><span class="p">(</span><span class="n">inplace</span><span class="p">,</span> <span class="s1">&#39;inplace&#39;</span><span class="p">)</span>

        <span class="n">axis</span> <span class="o">=</span> <span class="n">nv</span><span class="o">.</span><span class="n">validate_clip_with_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># GH 17276</span>
        <span class="c1"># numpy doesn&#39;t like NaN as a clip value</span>
        <span class="c1"># so ignore</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="n">lower</span><span class="p">)):</span>
            <span class="n">lower</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="n">upper</span><span class="p">)):</span>
            <span class="n">upper</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># GH 2747 (arguments were reversed)</span>
        <span class="k">if</span> <span class="n">lower</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">upper</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">is_scalar</span><span class="p">(</span><span class="n">lower</span><span class="p">)</span> <span class="ow">and</span> <span class="n">is_scalar</span><span class="p">(</span><span class="n">upper</span><span class="p">):</span>
                <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">)</span>

        <span class="c1"># fast-path for scalars</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">lower</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="p">(</span><span class="n">is_scalar</span><span class="p">(</span><span class="n">lower</span><span class="p">)</span> <span class="ow">and</span> <span class="n">is_number</span><span class="p">(</span><span class="n">lower</span><span class="p">)))</span> <span class="ow">and</span>
                <span class="p">(</span><span class="n">upper</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="p">(</span><span class="n">is_scalar</span><span class="p">(</span><span class="n">upper</span><span class="p">)</span> <span class="ow">and</span> <span class="n">is_number</span><span class="p">(</span><span class="n">upper</span><span class="p">)))):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clip_with_scalar</span><span class="p">(</span><span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="n">lower</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">clip_lower</span><span class="p">(</span><span class="n">lower</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">upper</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">clip_upper</span><span class="p">(</span><span class="n">upper</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">clip_upper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return copy of input with values above given value(s) truncated.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        threshold : float or array_like</span>
<span class="sd">        axis : int or string axis name, optional</span>
<span class="sd">            Align object with threshold along the given axis.</span>
<span class="sd">        inplace : boolean, default False</span>
<span class="sd">            Whether to perform the operation in place on the data</span>
<span class="sd">                .. versionadded:: 0.21.0</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        clip</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        clipped : same type as input</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clip_with_one_bound</span><span class="p">(</span><span class="n">threshold</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">le</span><span class="p">,</span>
                                         <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">clip_lower</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return copy of the input with values below given value(s) truncated.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        threshold : float or array_like</span>
<span class="sd">        axis : int or string axis name, optional</span>
<span class="sd">            Align object with threshold along the given axis.</span>
<span class="sd">        inplace : boolean, default False</span>
<span class="sd">            Whether to perform the operation in place on the data</span>
<span class="sd">                .. versionadded:: 0.21.0</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        clip</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        clipped : same type as input</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clip_with_one_bound</span><span class="p">(</span><span class="n">threshold</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ge</span><span class="p">,</span>
                                         <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">groupby</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">by</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">as_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">group_keys</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">squeeze</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Group series using mapper (dict or key function, apply given function</span>
<span class="sd">        to group, return result as series) or by a series of columns.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        by : mapping, function, str, or iterable</span>
<span class="sd">            Used to determine the groups for the groupby.</span>
<span class="sd">            If ``by`` is a function, it&#39;s called on each value of the object&#39;s</span>
<span class="sd">            index. If a dict or Series is passed, the Series or dict VALUES</span>
<span class="sd">            will be used to determine the groups (the Series&#39; values are first</span>
<span class="sd">            aligned; see ``.align()`` method). If an ndarray is passed, the</span>
<span class="sd">            values are used as-is determine the groups. A str or list of strs</span>
<span class="sd">            may be passed to group by the columns in ``self``</span>
<span class="sd">        axis : int, default 0</span>
<span class="sd">        level : int, level name, or sequence of such, default None</span>
<span class="sd">            If the axis is a MultiIndex (hierarchical), group by a particular</span>
<span class="sd">            level or levels</span>
<span class="sd">        as_index : boolean, default True</span>
<span class="sd">            For aggregated output, return object with group labels as the</span>
<span class="sd">            index. Only relevant for DataFrame input. as_index=False is</span>
<span class="sd">            effectively &quot;SQL-style&quot; grouped output</span>
<span class="sd">        sort : boolean, default True</span>
<span class="sd">            Sort group keys. Get better performance by turning this off.</span>
<span class="sd">            Note this does not influence the order of observations within each</span>
<span class="sd">            group.  groupby preserves the order of rows within each group.</span>
<span class="sd">        group_keys : boolean, default True</span>
<span class="sd">            When calling apply, add group keys to index to identify pieces</span>
<span class="sd">        squeeze : boolean, default False</span>
<span class="sd">            reduce the dimensionality of the return type if possible,</span>
<span class="sd">            otherwise return a consistent type</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrame results</span>

<span class="sd">        &gt;&gt;&gt; data.groupby(func, axis=0).mean()</span>
<span class="sd">        &gt;&gt;&gt; data.groupby([&#39;col1&#39;, &#39;col2&#39;])[&#39;col3&#39;].mean()</span>

<span class="sd">        DataFrame with hierarchical index</span>

<span class="sd">        &gt;&gt;&gt; data.groupby([&#39;col1&#39;, &#39;col2&#39;]).mean()</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        GroupBy object</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas.core.groupby</span> <span class="k">import</span> <span class="n">groupby</span>

        <span class="k">if</span> <span class="n">level</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">by</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;You have to supply one of &#39;by&#39; and &#39;level&#39;&quot;</span><span class="p">)</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">groupby</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">by</span><span class="o">=</span><span class="n">by</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span> <span class="n">as_index</span><span class="o">=</span><span class="n">as_index</span><span class="p">,</span>
                       <span class="n">sort</span><span class="o">=</span><span class="n">sort</span><span class="p">,</span> <span class="n">group_keys</span><span class="o">=</span><span class="n">group_keys</span><span class="p">,</span> <span class="n">squeeze</span><span class="o">=</span><span class="n">squeeze</span><span class="p">,</span>
                       <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">asfreq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
               <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert TimeSeries to specified frequency.</span>

<span class="sd">        Optionally provide filling method to pad/backfill missing values.</span>

<span class="sd">        Returns the original data conformed to a new index with the specified</span>
<span class="sd">        frequency. ``resample`` is more appropriate if an operation, such as</span>
<span class="sd">        summarization, is necessary to represent the data at the new frequency.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        freq : DateOffset object, or string</span>
<span class="sd">        method : {&#39;backfill&#39;/&#39;bfill&#39;, &#39;pad&#39;/&#39;ffill&#39;}, default None</span>
<span class="sd">            Method to use for filling holes in reindexed Series (note this</span>
<span class="sd">            does not fill NaNs that already were present):</span>

<span class="sd">            * &#39;pad&#39; / &#39;ffill&#39;: propagate last valid observation forward to next</span>
<span class="sd">              valid</span>
<span class="sd">            * &#39;backfill&#39; / &#39;bfill&#39;: use NEXT valid observation to fill</span>
<span class="sd">        how : {&#39;start&#39;, &#39;end&#39;}, default end</span>
<span class="sd">            For PeriodIndex only, see PeriodIndex.asfreq</span>
<span class="sd">        normalize : bool, default False</span>
<span class="sd">            Whether to reset output index to midnight</span>
<span class="sd">        fill_value: scalar, optional</span>
<span class="sd">            Value to use for missing values, applied during upsampling (note</span>
<span class="sd">            this does not fill NaNs that already were present).</span>

<span class="sd">            .. versionadded:: 0.20.0</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        converted : type of caller</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        Start by creating a series with 4 one minute timestamps.</span>

<span class="sd">        &gt;&gt;&gt; index = pd.date_range(&#39;1/1/2000&#39;, periods=4, freq=&#39;T&#39;)</span>
<span class="sd">        &gt;&gt;&gt; series = pd.Series([0.0, None, 2.0, 3.0], index=index)</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;s&#39;:series})</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">                               s</span>
<span class="sd">        2000-01-01 00:00:00    0.0</span>
<span class="sd">        2000-01-01 00:01:00    NaN</span>
<span class="sd">        2000-01-01 00:02:00    2.0</span>
<span class="sd">        2000-01-01 00:03:00    3.0</span>

<span class="sd">        Upsample the series into 30 second bins.</span>

<span class="sd">        &gt;&gt;&gt; df.asfreq(freq=&#39;30S&#39;)</span>
<span class="sd">                               s</span>
<span class="sd">        2000-01-01 00:00:00    0.0</span>
<span class="sd">        2000-01-01 00:00:30    NaN</span>
<span class="sd">        2000-01-01 00:01:00    NaN</span>
<span class="sd">        2000-01-01 00:01:30    NaN</span>
<span class="sd">        2000-01-01 00:02:00    2.0</span>
<span class="sd">        2000-01-01 00:02:30    NaN</span>
<span class="sd">        2000-01-01 00:03:00    3.0</span>

<span class="sd">        Upsample again, providing a ``fill value``.</span>

<span class="sd">        &gt;&gt;&gt; df.asfreq(freq=&#39;30S&#39;, fill_value=9.0)</span>
<span class="sd">                               s</span>
<span class="sd">        2000-01-01 00:00:00    0.0</span>
<span class="sd">        2000-01-01 00:00:30    9.0</span>
<span class="sd">        2000-01-01 00:01:00    NaN</span>
<span class="sd">        2000-01-01 00:01:30    9.0</span>
<span class="sd">        2000-01-01 00:02:00    2.0</span>
<span class="sd">        2000-01-01 00:02:30    9.0</span>
<span class="sd">        2000-01-01 00:03:00    3.0</span>

<span class="sd">        Upsample again, providing a ``method``.</span>

<span class="sd">        &gt;&gt;&gt; df.asfreq(freq=&#39;30S&#39;, method=&#39;bfill&#39;)</span>
<span class="sd">                               s</span>
<span class="sd">        2000-01-01 00:00:00    0.0</span>
<span class="sd">        2000-01-01 00:00:30    NaN</span>
<span class="sd">        2000-01-01 00:01:00    NaN</span>
<span class="sd">        2000-01-01 00:01:30    2.0</span>
<span class="sd">        2000-01-01 00:02:00    2.0</span>
<span class="sd">        2000-01-01 00:02:30    3.0</span>
<span class="sd">        2000-01-01 00:03:00    3.0</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        reindex</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        To learn more about the frequency strings, please see `this link</span>
<span class="sd">        &lt;http://pandas.pydata.org/pandas-docs/stable/timeseries.html#offset-aliases&gt;`__.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas.core.resample</span> <span class="k">import</span> <span class="n">asfreq</span>
        <span class="k">return</span> <span class="n">asfreq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="n">how</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="n">normalize</span><span class="p">,</span>
                      <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">at_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">asof</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Select values at particular time of day (e.g. 9:30AM).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        time : datetime.time or string</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        values_at_time : type of caller</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">indexer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">indexer_at_time</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">asof</span><span class="o">=</span><span class="n">asof</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_take</span><span class="p">(</span><span class="n">indexer</span><span class="p">,</span> <span class="n">convert</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Index must be DatetimeIndex&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">between_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_time</span><span class="p">,</span> <span class="n">end_time</span><span class="p">,</span> <span class="n">include_start</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                     <span class="n">include_end</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Select values between particular times of the day (e.g., 9:00-9:30 AM).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start_time : datetime.time or string</span>
<span class="sd">        end_time : datetime.time or string</span>
<span class="sd">        include_start : boolean, default True</span>
<span class="sd">        include_end : boolean, default True</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        values_between_time : type of caller</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">indexer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">indexer_between_time</span><span class="p">(</span>
                <span class="n">start_time</span><span class="p">,</span> <span class="n">end_time</span><span class="p">,</span> <span class="n">include_start</span><span class="o">=</span><span class="n">include_start</span><span class="p">,</span>
                <span class="n">include_end</span><span class="o">=</span><span class="n">include_end</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_take</span><span class="p">(</span><span class="n">indexer</span><span class="p">,</span> <span class="n">convert</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Index must be DatetimeIndex&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">resample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rule</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">fill_method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">closed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">label</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">convention</span><span class="o">=</span><span class="s1">&#39;start&#39;</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">loffset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">limit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convenience method for frequency conversion and resampling of time</span>
<span class="sd">        series.  Object must have a datetime-like index (DatetimeIndex,</span>
<span class="sd">        PeriodIndex, or TimedeltaIndex), or pass datetime-like values</span>
<span class="sd">        to the on or level keyword.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        rule : string</span>
<span class="sd">            the offset string or object representing target conversion</span>
<span class="sd">        axis : int, optional, default 0</span>
<span class="sd">        closed : {&#39;right&#39;, &#39;left&#39;}</span>
<span class="sd">            Which side of bin interval is closed. The default is &#39;left&#39;</span>
<span class="sd">            for all frequency offsets except for &#39;M&#39;, &#39;A&#39;, &#39;Q&#39;, &#39;BM&#39;,</span>
<span class="sd">            &#39;BA&#39;, &#39;BQ&#39;, and &#39;W&#39; which all have a default of &#39;right&#39;.</span>
<span class="sd">        label : {&#39;right&#39;, &#39;left&#39;}</span>
<span class="sd">            Which bin edge label to label bucket with. The default is &#39;left&#39;</span>
<span class="sd">            for all frequency offsets except for &#39;M&#39;, &#39;A&#39;, &#39;Q&#39;, &#39;BM&#39;,</span>
<span class="sd">            &#39;BA&#39;, &#39;BQ&#39;, and &#39;W&#39; which all have a default of &#39;right&#39;.</span>
<span class="sd">        convention : {&#39;start&#39;, &#39;end&#39;, &#39;s&#39;, &#39;e&#39;}</span>
<span class="sd">            For PeriodIndex only, controls whether to use the start or end of</span>
<span class="sd">            `rule`</span>
<span class="sd">        loffset : timedelta</span>
<span class="sd">            Adjust the resampled time labels</span>
<span class="sd">        base : int, default 0</span>
<span class="sd">            For frequencies that evenly subdivide 1 day, the &quot;origin&quot; of the</span>
<span class="sd">            aggregated intervals. For example, for &#39;5min&#39; frequency, base could</span>
<span class="sd">            range from 0 through 4. Defaults to 0</span>
<span class="sd">        on : string, optional</span>
<span class="sd">            For a DataFrame, column to use instead of index for resampling.</span>
<span class="sd">            Column must be datetime-like.</span>

<span class="sd">            .. versionadded:: 0.19.0</span>

<span class="sd">        level : string or int, optional</span>
<span class="sd">            For a MultiIndex, level (name or number) to use for</span>
<span class="sd">            resampling.  Level must be datetime-like.</span>

<span class="sd">            .. versionadded:: 0.19.0</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        To learn more about the offset strings, please see `this link</span>
<span class="sd">        &lt;http://pandas.pydata.org/pandas-docs/stable/timeseries.html#offset-aliases&gt;`__.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        Start by creating a series with 9 one minute timestamps.</span>

<span class="sd">        &gt;&gt;&gt; index = pd.date_range(&#39;1/1/2000&#39;, periods=9, freq=&#39;T&#39;)</span>
<span class="sd">        &gt;&gt;&gt; series = pd.Series(range(9), index=index)</span>
<span class="sd">        &gt;&gt;&gt; series</span>
<span class="sd">        2000-01-01 00:00:00    0</span>
<span class="sd">        2000-01-01 00:01:00    1</span>
<span class="sd">        2000-01-01 00:02:00    2</span>
<span class="sd">        2000-01-01 00:03:00    3</span>
<span class="sd">        2000-01-01 00:04:00    4</span>
<span class="sd">        2000-01-01 00:05:00    5</span>
<span class="sd">        2000-01-01 00:06:00    6</span>
<span class="sd">        2000-01-01 00:07:00    7</span>
<span class="sd">        2000-01-01 00:08:00    8</span>
<span class="sd">        Freq: T, dtype: int64</span>

<span class="sd">        Downsample the series into 3 minute bins and sum the values</span>
<span class="sd">        of the timestamps falling into a bin.</span>

<span class="sd">        &gt;&gt;&gt; series.resample(&#39;3T&#39;).sum()</span>
<span class="sd">        2000-01-01 00:00:00     3</span>
<span class="sd">        2000-01-01 00:03:00    12</span>
<span class="sd">        2000-01-01 00:06:00    21</span>
<span class="sd">        Freq: 3T, dtype: int64</span>

<span class="sd">        Downsample the series into 3 minute bins as above, but label each</span>
<span class="sd">        bin using the right edge instead of the left. Please note that the</span>
<span class="sd">        value in the bucket used as the label is not included in the bucket,</span>
<span class="sd">        which it labels. For example, in the original series the</span>
<span class="sd">        bucket ``2000-01-01 00:03:00`` contains the value 3, but the summed</span>
<span class="sd">        value in the resampled bucket with the label ``2000-01-01 00:03:00``</span>
<span class="sd">        does not include 3 (if it did, the summed value would be 6, not 3).</span>
<span class="sd">        To include this value close the right side of the bin interval as</span>
<span class="sd">        illustrated in the example below this one.</span>

<span class="sd">        &gt;&gt;&gt; series.resample(&#39;3T&#39;, label=&#39;right&#39;).sum()</span>
<span class="sd">        2000-01-01 00:03:00     3</span>
<span class="sd">        2000-01-01 00:06:00    12</span>
<span class="sd">        2000-01-01 00:09:00    21</span>
<span class="sd">        Freq: 3T, dtype: int64</span>

<span class="sd">        Downsample the series into 3 minute bins as above, but close the right</span>
<span class="sd">        side of the bin interval.</span>

<span class="sd">        &gt;&gt;&gt; series.resample(&#39;3T&#39;, label=&#39;right&#39;, closed=&#39;right&#39;).sum()</span>
<span class="sd">        2000-01-01 00:00:00     0</span>
<span class="sd">        2000-01-01 00:03:00     6</span>
<span class="sd">        2000-01-01 00:06:00    15</span>
<span class="sd">        2000-01-01 00:09:00    15</span>
<span class="sd">        Freq: 3T, dtype: int64</span>

<span class="sd">        Upsample the series into 30 second bins.</span>

<span class="sd">        &gt;&gt;&gt; series.resample(&#39;30S&#39;).asfreq()[0:5] #select first 5 rows</span>
<span class="sd">        2000-01-01 00:00:00   0.0</span>
<span class="sd">        2000-01-01 00:00:30   NaN</span>
<span class="sd">        2000-01-01 00:01:00   1.0</span>
<span class="sd">        2000-01-01 00:01:30   NaN</span>
<span class="sd">        2000-01-01 00:02:00   2.0</span>
<span class="sd">        Freq: 30S, dtype: float64</span>

<span class="sd">        Upsample the series into 30 second bins and fill the ``NaN``</span>
<span class="sd">        values using the ``pad`` method.</span>

<span class="sd">        &gt;&gt;&gt; series.resample(&#39;30S&#39;).pad()[0:5]</span>
<span class="sd">        2000-01-01 00:00:00    0</span>
<span class="sd">        2000-01-01 00:00:30    0</span>
<span class="sd">        2000-01-01 00:01:00    1</span>
<span class="sd">        2000-01-01 00:01:30    1</span>
<span class="sd">        2000-01-01 00:02:00    2</span>
<span class="sd">        Freq: 30S, dtype: int64</span>

<span class="sd">        Upsample the series into 30 second bins and fill the</span>
<span class="sd">        ``NaN`` values using the ``bfill`` method.</span>

<span class="sd">        &gt;&gt;&gt; series.resample(&#39;30S&#39;).bfill()[0:5]</span>
<span class="sd">        2000-01-01 00:00:00    0</span>
<span class="sd">        2000-01-01 00:00:30    1</span>
<span class="sd">        2000-01-01 00:01:00    1</span>
<span class="sd">        2000-01-01 00:01:30    2</span>
<span class="sd">        2000-01-01 00:02:00    2</span>
<span class="sd">        Freq: 30S, dtype: int64</span>

<span class="sd">        Pass a custom function via ``apply``</span>

<span class="sd">        &gt;&gt;&gt; def custom_resampler(array_like):</span>
<span class="sd">        ...     return np.sum(array_like)+5</span>

<span class="sd">        &gt;&gt;&gt; series.resample(&#39;3T&#39;).apply(custom_resampler)</span>
<span class="sd">        2000-01-01 00:00:00     8</span>
<span class="sd">        2000-01-01 00:03:00    17</span>
<span class="sd">        2000-01-01 00:06:00    26</span>
<span class="sd">        Freq: 3T, dtype: int64</span>

<span class="sd">        For a Series with a PeriodIndex, the keyword `convention` can be</span>
<span class="sd">        used to control whether to use the start or end of `rule`.</span>

<span class="sd">        &gt;&gt;&gt; s = pd.Series([1, 2], index=pd.period_range(&#39;2012-01-01&#39;,</span>
<span class="sd">                                                        freq=&#39;A&#39;,</span>
<span class="sd">                                                        periods=2))</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        2012    1</span>
<span class="sd">        2013    2</span>
<span class="sd">        Freq: A-DEC, dtype: int64</span>

<span class="sd">        Resample by month using &#39;start&#39; `convention`. Values are assigned to</span>
<span class="sd">        the first month of the period.</span>

<span class="sd">        &gt;&gt;&gt; s.resample(&#39;M&#39;, convention=&#39;start&#39;).asfreq().head()</span>
<span class="sd">        2012-01    1.0</span>
<span class="sd">        2012-02    NaN</span>
<span class="sd">        2012-03    NaN</span>
<span class="sd">        2012-04    NaN</span>
<span class="sd">        2012-05    NaN</span>
<span class="sd">        Freq: M, dtype: float64</span>

<span class="sd">        Resample by month using &#39;end&#39; `convention`. Values are assigned to</span>
<span class="sd">        the last month of the period.</span>

<span class="sd">        &gt;&gt;&gt; s.resample(&#39;M&#39;, convention=&#39;end&#39;).asfreq()</span>
<span class="sd">        2012-12    1.0</span>
<span class="sd">        2013-01    NaN</span>
<span class="sd">        2013-02    NaN</span>
<span class="sd">        2013-03    NaN</span>
<span class="sd">        2013-04    NaN</span>
<span class="sd">        2013-05    NaN</span>
<span class="sd">        2013-06    NaN</span>
<span class="sd">        2013-07    NaN</span>
<span class="sd">        2013-08    NaN</span>
<span class="sd">        2013-09    NaN</span>
<span class="sd">        2013-10    NaN</span>
<span class="sd">        2013-11    NaN</span>
<span class="sd">        2013-12    2.0</span>
<span class="sd">        Freq: M, dtype: float64</span>

<span class="sd">        For DataFrame objects, the keyword ``on`` can be used to specify the</span>
<span class="sd">        column instead of the index for resampling.</span>

<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame(data=9*[range(4)], columns=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])</span>
<span class="sd">        &gt;&gt;&gt; df[&#39;time&#39;] = pd.date_range(&#39;1/1/2000&#39;, periods=9, freq=&#39;T&#39;)</span>
<span class="sd">        &gt;&gt;&gt; df.resample(&#39;3T&#39;, on=&#39;time&#39;).sum()</span>
<span class="sd">                             a  b  c  d</span>
<span class="sd">        time</span>
<span class="sd">        2000-01-01 00:00:00  0  3  6  9</span>
<span class="sd">        2000-01-01 00:03:00  0  3  6  9</span>
<span class="sd">        2000-01-01 00:06:00  0  3  6  9</span>

<span class="sd">        For a DataFrame with MultiIndex, the keyword ``level`` can be used to</span>
<span class="sd">        specify on level the resampling needs to take place.</span>

<span class="sd">        &gt;&gt;&gt; time = pd.date_range(&#39;1/1/2000&#39;, periods=5, freq=&#39;T&#39;)</span>
<span class="sd">        &gt;&gt;&gt; df2 = pd.DataFrame(data=10*[range(4)],</span>
<span class="sd">                               columns=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;],</span>
<span class="sd">                               index=pd.MultiIndex.from_product([time, [1, 2]])</span>
<span class="sd">                               )</span>
<span class="sd">        &gt;&gt;&gt; df2.resample(&#39;3T&#39;, level=0).sum()</span>
<span class="sd">                             a  b   c   d</span>
<span class="sd">        2000-01-01 00:00:00  0  6  12  18</span>
<span class="sd">        2000-01-01 00:03:00  0  4   8  12</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas.core.resample</span> <span class="k">import</span> <span class="p">(</span><span class="n">resample</span><span class="p">,</span>
                                          <span class="n">_maybe_process_deprecations</span><span class="p">)</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">resample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="n">rule</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">,</span> <span class="n">closed</span><span class="o">=</span><span class="n">closed</span><span class="p">,</span>
                     <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span> <span class="n">loffset</span><span class="o">=</span><span class="n">loffset</span><span class="p">,</span>
                     <span class="n">convention</span><span class="o">=</span><span class="n">convention</span><span class="p">,</span>
                     <span class="n">base</span><span class="o">=</span><span class="n">base</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">on</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_maybe_process_deprecations</span><span class="p">(</span><span class="n">r</span><span class="p">,</span>
                                           <span class="n">how</span><span class="o">=</span><span class="n">how</span><span class="p">,</span>
                                           <span class="n">fill_method</span><span class="o">=</span><span class="n">fill_method</span><span class="p">,</span>
                                           <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">first</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">offset</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convenience method for subsetting initial periods of time series data</span>
<span class="sd">        based on a date offset.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        offset : string, DateOffset, dateutil.relativedelta</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        ts.first(&#39;10D&#39;) -&gt; First 10 days</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        subset : type of caller</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas.tseries.frequencies</span> <span class="k">import</span> <span class="n">to_offset</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">DatetimeIndex</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;&#39;first&#39; only supports a DatetimeIndex &quot;</span>
                                      <span class="s2">&quot;index&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="n">offset</span> <span class="o">=</span> <span class="n">to_offset</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span>
        <span class="n">end_date</span> <span class="o">=</span> <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">offset</span>

        <span class="c1"># Tick-like, e.g. 3 weeks</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">offset</span><span class="o">.</span><span class="n">isAnchored</span><span class="p">()</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="s1">&#39;_inc&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">end_date</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">:</span>
                <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">end_date</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:</span><span class="n">end</span><span class="p">]</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">loc</span><span class="p">[:</span><span class="n">end</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">last</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">offset</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convenience method for subsetting final periods of time series data</span>
<span class="sd">        based on a date offset.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        offset : string, DateOffset, dateutil.relativedelta</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        ts.last(&#39;5M&#39;) -&gt; Last 5 months</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        subset : type of caller</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas.tseries.frequencies</span> <span class="k">import</span> <span class="n">to_offset</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">DatetimeIndex</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;&#39;last&#39; only supports a DatetimeIndex &quot;</span>
                                      <span class="s2">&quot;index&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="n">offset</span> <span class="o">=</span> <span class="n">to_offset</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span>

        <span class="n">start_date</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">offset</span>
        <span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">start_date</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">start</span><span class="p">:]</span>

    <span class="k">def</span> <span class="nf">rank</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;average&#39;</span><span class="p">,</span> <span class="n">numeric_only</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">na_option</span><span class="o">=</span><span class="s1">&#39;keep&#39;</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">pct</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute numerical data ranks (1 through n) along axis. Equal values are</span>
<span class="sd">        assigned a rank that is the average of the ranks of those values</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis : {0 or &#39;index&#39;, 1 or &#39;columns&#39;}, default 0</span>
<span class="sd">            index to direct ranking</span>
<span class="sd">        method : {&#39;average&#39;, &#39;min&#39;, &#39;max&#39;, &#39;first&#39;, &#39;dense&#39;}</span>
<span class="sd">            * average: average rank of group</span>
<span class="sd">            * min: lowest rank in group</span>
<span class="sd">            * max: highest rank in group</span>
<span class="sd">            * first: ranks assigned in order they appear in the array</span>
<span class="sd">            * dense: like &#39;min&#39;, but rank always increases by 1 between groups</span>
<span class="sd">        numeric_only : boolean, default None</span>
<span class="sd">            Include only float, int, boolean data. Valid only for DataFrame or</span>
<span class="sd">            Panel objects</span>
<span class="sd">        na_option : {&#39;keep&#39;, &#39;top&#39;, &#39;bottom&#39;}</span>
<span class="sd">            * keep: leave NA values where they are</span>
<span class="sd">            * top: smallest rank if ascending</span>
<span class="sd">            * bottom: smallest rank if descending</span>
<span class="sd">        ascending : boolean, default True</span>
<span class="sd">            False for ranks by high (1) to low (N)</span>
<span class="sd">        pct : boolean, default False</span>
<span class="sd">            Computes percentage rank of data</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ranks : same type as caller</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;rank does not make sense when ndim &gt; 2&quot;</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">ranker</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
            <span class="n">ranks</span> <span class="o">=</span> <span class="n">algos</span><span class="o">.</span><span class="n">rank</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
                               <span class="n">ascending</span><span class="o">=</span><span class="n">ascending</span><span class="p">,</span> <span class="n">na_option</span><span class="o">=</span><span class="n">na_option</span><span class="p">,</span>
                               <span class="n">pct</span><span class="o">=</span><span class="n">pct</span><span class="p">)</span>
            <span class="n">ranks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">ranks</span><span class="p">,</span> <span class="o">**</span><span class="n">data</span><span class="o">.</span><span class="n">_construct_axes_dict</span><span class="p">())</span>
            <span class="k">return</span> <span class="n">ranks</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c1"># if numeric_only is None, and we can&#39;t get anything, we try with</span>
        <span class="c1"># numeric_only=True</span>
        <span class="k">if</span> <span class="n">numeric_only</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">ranker</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="n">numeric_only</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">numeric_only</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_numeric_data</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="k">return</span> <span class="n">ranker</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

    <span class="n">_shared_docs</span><span class="p">[</span><span class="s1">&#39;align&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        Align two objects on their axes with the</span>
<span class="s2">        specified join method for each axis Index</span>

<span class="s2">        Parameters</span>
<span class="s2">        ----------</span>
<span class="s2">        other : DataFrame or Series</span>
<span class="s2">        join : {&#39;outer&#39;, &#39;inner&#39;, &#39;left&#39;, &#39;right&#39;}, default &#39;outer&#39;</span>
<span class="s2">        axis : allowed axis of the other object, default None</span>
<span class="s2">            Align on index (0), columns (1), or both (None)</span>
<span class="s2">        level : int or level name, default None</span>
<span class="s2">            Broadcast across a level, matching Index values on the</span>
<span class="s2">            passed MultiIndex level</span>
<span class="s2">        copy : boolean, default True</span>
<span class="s2">            Always returns new objects. If copy=False and no reindexing is</span>
<span class="s2">            required then original objects are returned.</span>
<span class="s2">        fill_value : scalar, default np.NaN</span>
<span class="s2">            Value to use for missing values. Defaults to NaN, but can be any</span>
<span class="s2">            &quot;compatible&quot; value</span>
<span class="s2">        method : str, default None</span>
<span class="s2">        limit : int, default None</span>
<span class="s2">        fill_axis : </span><span class="si">%(axes_single_arg)s</span><span class="s2">, default 0</span>
<span class="s2">            Filling axis, method and limit</span>
<span class="s2">        broadcast_axis : </span><span class="si">%(axes_single_arg)s</span><span class="s2">, default None</span>
<span class="s2">            Broadcast values along this axis, if aligning two objects of</span>
<span class="s2">            different dimensions</span>

<span class="s2">            .. versionadded:: 0.17.0</span>

<span class="s2">        Returns</span>
<span class="s2">        -------</span>
<span class="s2">        (left, right) : (</span><span class="si">%(klass)s</span><span class="s2">, type of other)</span>
<span class="s2">            Aligned objects</span>
<span class="s2">        &quot;&quot;&quot;</span><span class="p">)</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s1">&#39;align&#39;</span><span class="p">]</span> <span class="o">%</span> <span class="n">_shared_doc_kwargs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">align</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="s1">&#39;outer&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
              <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fill_axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
              <span class="n">broadcast_axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">pandas</span> <span class="k">import</span> <span class="n">DataFrame</span><span class="p">,</span> <span class="n">Series</span>
        <span class="n">method</span> <span class="o">=</span> <span class="n">missing</span><span class="o">.</span><span class="n">clean_fill_method</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">broadcast_axis</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Series</span><span class="p">):</span>
                <span class="c1"># this means other is a DataFrame, and we need to broadcast</span>
                <span class="c1"># self</span>
                <span class="n">cons</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor_expanddim</span>
                <span class="n">df</span> <span class="o">=</span> <span class="n">cons</span><span class="p">(</span><span class="nb">dict</span><span class="p">((</span><span class="n">c</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">columns</span><span class="p">),</span>
                          <span class="o">**</span><span class="n">other</span><span class="o">.</span><span class="n">_construct_axes_dict</span><span class="p">())</span>
                <span class="k">return</span> <span class="n">df</span><span class="o">.</span><span class="n">_align_frame</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="n">join</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
                                       <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span>
                                       <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
                                       <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span> <span class="n">fill_axis</span><span class="o">=</span><span class="n">fill_axis</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Series</span><span class="p">):</span>
                <span class="c1"># this means self is a DataFrame, and we need to broadcast</span>
                <span class="c1"># other</span>
                <span class="n">cons</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_constructor_expanddim</span>
                <span class="n">df</span> <span class="o">=</span> <span class="n">cons</span><span class="p">(</span><span class="nb">dict</span><span class="p">((</span><span class="n">c</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">),</span>
                          <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_construct_axes_dict</span><span class="p">())</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_align_frame</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="n">join</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span>
                                         <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span>
                                         <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span>
                                         <span class="n">fill_axis</span><span class="o">=</span><span class="n">fill_axis</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">DataFrame</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_align_frame</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="n">join</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span>
                                     <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span>
                                     <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span>
                                     <span class="n">fill_axis</span><span class="o">=</span><span class="n">fill_axis</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Series</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_align_series</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="n">join</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span>
                                      <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span>
                                      <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span>
                                      <span class="n">fill_axis</span><span class="o">=</span><span class="n">fill_axis</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;unsupported type: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_align_frame</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="s1">&#39;outer&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">fill_axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="c1"># defaults</span>
        <span class="n">join_index</span><span class="p">,</span> <span class="n">join_columns</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
        <span class="n">ilidx</span><span class="p">,</span> <span class="n">iridx</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
        <span class="n">clidx</span><span class="p">,</span> <span class="n">cridx</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

        <span class="n">is_series</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ABCSeries</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">index</span><span class="p">):</span>
                <span class="n">join_index</span><span class="p">,</span> <span class="n">ilidx</span><span class="p">,</span> <span class="n">iridx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                    <span class="n">other</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="n">join</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span> <span class="n">return_indexers</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_series</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
                <span class="n">join_columns</span><span class="p">,</span> <span class="n">clidx</span><span class="p">,</span> <span class="n">cridx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                    <span class="n">other</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="n">join</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span> <span class="n">return_indexers</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">is_series</span><span class="p">:</span>
            <span class="n">reindexers</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="n">join_index</span><span class="p">,</span> <span class="n">ilidx</span><span class="p">]}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">reindexers</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="n">join_index</span><span class="p">,</span> <span class="n">ilidx</span><span class="p">],</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="n">join_columns</span><span class="p">,</span> <span class="n">clidx</span><span class="p">]}</span>

        <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reindex_with_indexers</span><span class="p">(</span><span class="n">reindexers</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span>
                                           <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span>
                                           <span class="n">allow_dups</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># other must be always DataFrame</span>
        <span class="n">right</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_reindex_with_indexers</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="n">join_index</span><span class="p">,</span> <span class="n">iridx</span><span class="p">],</span>
                                              <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="n">join_columns</span><span class="p">,</span> <span class="n">cridx</span><span class="p">]},</span>
                                             <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span>
                                             <span class="n">allow_dups</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">method</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">fill_axis</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">)</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">right</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">fill_axis</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">)</span>

        <span class="c1"># if DatetimeIndex have different tz, convert to UTC</span>
        <span class="k">if</span> <span class="n">is_datetime64tz_dtype</span><span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">index</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">left</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">tz</span> <span class="o">!=</span> <span class="n">right</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">tz</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">join_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">left</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">join_index</span>
                    <span class="n">right</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">join_index</span>

        <span class="k">return</span> <span class="n">left</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">right</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_align_series</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="s1">&#39;outer&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">fill_axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>

        <span class="n">is_series</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ABCSeries</span><span class="p">)</span>

        <span class="c1"># series/series compat, other must always be a Series</span>
        <span class="k">if</span> <span class="n">is_series</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">axis</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;cannot align series to a series other than &#39;</span>
                                 <span class="s1">&#39;axis 0&#39;</span><span class="p">)</span>

            <span class="c1"># equal</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">index</span><span class="p">):</span>
                <span class="n">join_index</span><span class="p">,</span> <span class="n">lidx</span><span class="p">,</span> <span class="n">ridx</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">join_index</span><span class="p">,</span> <span class="n">lidx</span><span class="p">,</span> <span class="n">ridx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="n">join</span><span class="p">,</span>
                                                         <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span>
                                                         <span class="n">return_indexers</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reindex_indexer</span><span class="p">(</span><span class="n">join_index</span><span class="p">,</span> <span class="n">lidx</span><span class="p">,</span> <span class="n">copy</span><span class="p">)</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_reindex_indexer</span><span class="p">(</span><span class="n">join_index</span><span class="p">,</span> <span class="n">ridx</span><span class="p">,</span> <span class="n">copy</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># one has &gt; 1 ndim</span>
            <span class="n">fdata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span>
            <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">join_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span>
                <span class="n">lidx</span><span class="p">,</span> <span class="n">ridx</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">index</span><span class="p">):</span>
                    <span class="n">join_index</span><span class="p">,</span> <span class="n">lidx</span><span class="p">,</span> <span class="n">ridx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                        <span class="n">other</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="n">join</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span>
                        <span class="n">return_indexers</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">lidx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">fdata</span> <span class="o">=</span> <span class="n">fdata</span><span class="o">.</span><span class="n">reindex_indexer</span><span class="p">(</span><span class="n">join_index</span><span class="p">,</span> <span class="n">lidx</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">join_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span>
                <span class="n">lidx</span><span class="p">,</span> <span class="n">ridx</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">index</span><span class="p">):</span>
                    <span class="n">join_index</span><span class="p">,</span> <span class="n">lidx</span><span class="p">,</span> <span class="n">ridx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                        <span class="n">other</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="n">join</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span>
                        <span class="n">return_indexers</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">lidx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">fdata</span> <span class="o">=</span> <span class="n">fdata</span><span class="o">.</span><span class="n">reindex_indexer</span><span class="p">(</span><span class="n">join_index</span><span class="p">,</span> <span class="n">lidx</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Must specify axis=0 or 1&#39;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">copy</span> <span class="ow">and</span> <span class="n">fdata</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">:</span>
                <span class="n">fdata</span> <span class="o">=</span> <span class="n">fdata</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">fdata</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">ridx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">other</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">join_index</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">)</span>

        <span class="c1"># fill</span>
        <span class="n">fill_na</span> <span class="o">=</span> <span class="n">notna</span><span class="p">(</span><span class="n">fill_value</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">method</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fill_na</span><span class="p">:</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span>
                               <span class="n">axis</span><span class="o">=</span><span class="n">fill_axis</span><span class="p">)</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">right</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">)</span>

        <span class="c1"># if DatetimeIndex have different tz, convert to UTC</span>
        <span class="k">if</span> <span class="n">is_series</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="n">is_series</span> <span class="ow">and</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">is_datetime64tz_dtype</span><span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">index</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">left</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">tz</span> <span class="o">!=</span> <span class="n">right</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">tz</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">join_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">left</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">join_index</span>
                        <span class="n">right</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">join_index</span>

        <span class="k">return</span> <span class="n">left</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">right</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_where</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cond</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">errors</span><span class="o">=</span><span class="s1">&#39;raise&#39;</span><span class="p">,</span> <span class="n">try_cast</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Equivalent to public method `where`, except that `other` is not</span>
<span class="sd">        applied as a function even if callable. Used in __setitem__.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">inplace</span> <span class="o">=</span> <span class="n">validate_bool_kwarg</span><span class="p">(</span><span class="n">inplace</span><span class="p">,</span> <span class="s1">&#39;inplace&#39;</span><span class="p">)</span>

        <span class="c1"># align the cond to same shape as myself</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">_apply_if_callable</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="n">NDFrame</span><span class="p">):</span>
            <span class="n">cond</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">cond</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">,</span> <span class="n">broadcast_axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="s1">&#39;shape&#39;</span><span class="p">):</span>
                <span class="n">cond</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">cond</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">cond</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Array conditional must be same shape as &#39;</span>
                                 <span class="s1">&#39;self&#39;</span><span class="p">)</span>
            <span class="n">cond</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_construct_axes_dict</span><span class="p">())</span>

        <span class="c1"># make sure we are boolean</span>
        <span class="n">fill_value</span> <span class="o">=</span> <span class="kc">True</span> <span class="k">if</span> <span class="n">inplace</span> <span class="k">else</span> <span class="kc">False</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="n">cond</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">fill_value</span><span class="p">)</span>

        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Boolean array expected for the condition, not </span><span class="si">{dtype}</span><span class="s2">&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
            <span class="c1"># This is a single-dimensional object.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_bool_dtype</span><span class="p">(</span><span class="n">cond</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">cond</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">dt</span> <span class="ow">in</span> <span class="n">cond</span><span class="o">.</span><span class="n">dtypes</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">is_bool_dtype</span><span class="p">(</span><span class="n">dt</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">dt</span><span class="p">))</span>

        <span class="n">cond</span> <span class="o">=</span> <span class="n">cond</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="o">-</span><span class="n">cond</span> <span class="k">if</span> <span class="n">inplace</span> <span class="k">else</span> <span class="n">cond</span>

        <span class="c1"># try to align with other</span>
        <span class="n">try_quick</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s1">&#39;align&#39;</span><span class="p">):</span>

            <span class="c1"># align with me</span>
            <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>

                <span class="n">_</span><span class="p">,</span> <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
                                      <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

                <span class="c1"># if we are NOT aligned, raise as we cannot where index</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span>
                        <span class="ow">not</span> <span class="nb">all</span><span class="p">([</span><span class="n">other</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>
                                 <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">)])):</span>
                    <span class="k">raise</span> <span class="n">InvalidIndexError</span>

            <span class="c1"># slice me out of the other</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;cannot align with a higher &quot;</span>
                                          <span class="s2">&quot;dimensional NDFrame&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>

            <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>

                    <span class="n">icond</span> <span class="o">=</span> <span class="n">cond</span><span class="o">.</span><span class="n">values</span>

                    <span class="c1"># GH 2745 / GH 4192</span>
                    <span class="c1"># treat like a scalar</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">other</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">other</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

                    <span class="c1"># GH 3235</span>
                    <span class="c1"># match True cond to other</span>
                    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">cond</span><span class="p">[</span><span class="n">icond</span><span class="p">])</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>

                        <span class="c1"># try to not change dtype at first (if try_quick)</span>
                        <span class="k">if</span> <span class="n">try_quick</span><span class="p">:</span>

                            <span class="k">try</span><span class="p">:</span>
                                <span class="n">new_other</span> <span class="o">=</span> <span class="n">_values_from_object</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                                <span class="n">new_other</span><span class="p">[</span><span class="n">icond</span><span class="p">]</span> <span class="o">=</span> <span class="n">other</span>
                                <span class="n">other</span> <span class="o">=</span> <span class="n">new_other</span>
                            <span class="k">except</span><span class="p">:</span>
                                <span class="n">try_quick</span> <span class="o">=</span> <span class="kc">False</span>

                        <span class="c1"># let&#39;s create a new (if we failed at the above</span>
                        <span class="c1"># or not try_quick</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">try_quick</span><span class="p">:</span>

                            <span class="n">dtype</span><span class="p">,</span> <span class="n">fill_value</span> <span class="o">=</span> <span class="n">maybe_promote</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                            <span class="n">new_other</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">icond</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
                            <span class="n">new_other</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">fill_value</span><span class="p">)</span>
                            <span class="n">maybe_upcast_putmask</span><span class="p">(</span><span class="n">new_other</span><span class="p">,</span> <span class="n">icond</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
                            <span class="n">other</span> <span class="o">=</span> <span class="n">new_other</span>

                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Length of replacements must equal &#39;</span>
                                         <span class="s1">&#39;series length&#39;</span><span class="p">)</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;other must be the same shape as self &#39;</span>
                                     <span class="s1">&#39;when an ndarray&#39;</span><span class="p">)</span>

            <span class="c1"># we are the same shape, so create an actual object for alignment</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_construct_axes_dict</span><span class="p">())</span>

        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s1">&#39;ndim&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">align</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">align</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">block_axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_block_manager_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="c1"># we may have different type blocks come out of putmask, so</span>
            <span class="c1"># reconstruct the block manager</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_check_inplace_setting</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">putmask</span><span class="p">(</span><span class="n">mask</span><span class="o">=</span><span class="n">cond</span><span class="p">,</span> <span class="n">new</span><span class="o">=</span><span class="n">other</span><span class="p">,</span> <span class="n">align</span><span class="o">=</span><span class="n">align</span><span class="p">,</span>
                                          <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">block_axis</span><span class="p">,</span>
                                          <span class="n">transpose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_REVERSED</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_inplace</span><span class="p">(</span><span class="n">new_data</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">,</span> <span class="n">cond</span><span class="o">=</span><span class="n">cond</span><span class="p">,</span> <span class="n">align</span><span class="o">=</span><span class="n">align</span><span class="p">,</span>
                                        <span class="n">errors</span><span class="o">=</span><span class="n">errors</span><span class="p">,</span>
                                        <span class="n">try_cast</span><span class="o">=</span><span class="n">try_cast</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">block_axis</span><span class="p">,</span>
                                        <span class="n">transpose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_REVERSED</span><span class="p">)</span>

            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">new_data</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="n">_shared_docs</span><span class="p">[</span><span class="s1">&#39;where&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        Return an object of same shape as self and whose corresponding</span>
<span class="s2">        entries are from self where `cond` is </span><span class="si">%(cond)s</span><span class="s2"> and otherwise are from</span>
<span class="s2">        `other`.</span>

<span class="s2">        Parameters</span>
<span class="s2">        ----------</span>
<span class="s2">        cond : boolean </span><span class="si">%(klass)s</span><span class="s2">, array-like, or callable</span>
<span class="s2">            Where `cond` is </span><span class="si">%(cond)s</span><span class="s2">, keep the original value. Where</span>
<span class="s2">            </span><span class="si">%(cond_rev)s</span><span class="s2">, replace with corresponding value from `other`.</span>
<span class="s2">            If `cond` is callable, it is computed on the </span><span class="si">%(klass)s</span><span class="s2"> and</span>
<span class="s2">            should return boolean </span><span class="si">%(klass)s</span><span class="s2"> or array. The callable must</span>
<span class="s2">            not change input </span><span class="si">%(klass)s</span><span class="s2"> (though pandas doesn&#39;t check it).</span>

<span class="s2">            .. versionadded:: 0.18.1</span>
<span class="s2">                A callable can be used as cond.</span>

<span class="s2">        other : scalar, </span><span class="si">%(klass)s</span><span class="s2">, or callable</span>
<span class="s2">            Entries where `cond` is </span><span class="si">%(cond_rev)s</span><span class="s2"> are replaced with</span>
<span class="s2">            corresponding value from `other`.</span>
<span class="s2">            If other is callable, it is computed on the </span><span class="si">%(klass)s</span><span class="s2"> and</span>
<span class="s2">            should return scalar or </span><span class="si">%(klass)s</span><span class="s2">. The callable must not</span>
<span class="s2">            change input </span><span class="si">%(klass)s</span><span class="s2"> (though pandas doesn&#39;t check it).</span>

<span class="s2">            .. versionadded:: 0.18.1</span>
<span class="s2">                A callable can be used as other.</span>

<span class="s2">        inplace : boolean, default False</span>
<span class="s2">            Whether to perform the operation in place on the data</span>
<span class="s2">        axis : alignment axis if needed, default None</span>
<span class="s2">        level : alignment level if needed, default None</span>
<span class="s2">        errors : str, {&#39;raise&#39;, &#39;ignore&#39;}, default &#39;raise&#39;</span>
<span class="s2">            - ``raise`` : allow exceptions to be raised</span>
<span class="s2">            - ``ignore`` : suppress exceptions. On error return original object</span>

<span class="s2">            Note that currently this parameter won&#39;t affect</span>
<span class="s2">            the results and will always coerce to a suitable dtype.</span>

<span class="s2">        try_cast : boolean, default False</span>
<span class="s2">            try to cast the result back to the input type (if possible),</span>
<span class="s2">        raise_on_error : boolean, default True</span>
<span class="s2">            Whether to raise on invalid data types (e.g. trying to where on</span>
<span class="s2">            strings)</span>

<span class="s2">            .. deprecated:: 0.21.0</span>

<span class="s2">        Returns</span>
<span class="s2">        -------</span>
<span class="s2">        wh : same type as caller</span>

<span class="s2">        Notes</span>
<span class="s2">        -----</span>
<span class="s2">        The </span><span class="si">%(name)s</span><span class="s2"> method is an application of the if-then idiom. For each</span>
<span class="s2">        element in the calling DataFrame, if ``cond`` is ``</span><span class="si">%(cond)s</span><span class="s2">`` the</span>
<span class="s2">        element is used; otherwise the corresponding element from the DataFrame</span>
<span class="s2">        ``other`` is used.</span>

<span class="s2">        The signature for :func:`DataFrame.where` differs from</span>
<span class="s2">        :func:`numpy.where`. Roughly ``df1.where(m, df2)`` is equivalent to</span>
<span class="s2">        ``np.where(m, df1, df2)``.</span>

<span class="s2">        For further details and examples see the ``</span><span class="si">%(name)s</span><span class="s2">`` documentation in</span>
<span class="s2">        :ref:`indexing &lt;indexing.where_mask&gt;`.</span>

<span class="s2">        Examples</span>
<span class="s2">        --------</span>
<span class="s2">        &gt;&gt;&gt; s = pd.Series(range(5))</span>
<span class="s2">        &gt;&gt;&gt; s.where(s &gt; 0)</span>
<span class="s2">        0    NaN</span>
<span class="s2">        1    1.0</span>
<span class="s2">        2    2.0</span>
<span class="s2">        3    3.0</span>
<span class="s2">        4    4.0</span>

<span class="s2">        &gt;&gt;&gt; s.mask(s &gt; 0)</span>
<span class="s2">        0    0.0</span>
<span class="s2">        1    NaN</span>
<span class="s2">        2    NaN</span>
<span class="s2">        3    NaN</span>
<span class="s2">        4    NaN</span>

<span class="s2">        &gt;&gt;&gt; s.where(s &gt; 1, 10)</span>
<span class="s2">        0    10.0</span>
<span class="s2">        1    10.0</span>
<span class="s2">        2    2.0</span>
<span class="s2">        3    3.0</span>
<span class="s2">        4    4.0</span>

<span class="s2">        &gt;&gt;&gt; df = pd.DataFrame(np.arange(10).reshape(-1, 2), columns=[&#39;A&#39;, &#39;B&#39;])</span>
<span class="s2">        &gt;&gt;&gt; m = df </span><span class="si">%%</span><span class="s2"> 3 == 0</span>
<span class="s2">        &gt;&gt;&gt; df.where(m, -df)</span>
<span class="s2">           A  B</span>
<span class="s2">        0  0 -1</span>
<span class="s2">        1 -2  3</span>
<span class="s2">        2 -4 -5</span>
<span class="s2">        3  6 -7</span>
<span class="s2">        4 -8  9</span>
<span class="s2">        &gt;&gt;&gt; df.where(m, -df) == np.where(m, df, -df)</span>
<span class="s2">              A     B</span>
<span class="s2">        0  True  True</span>
<span class="s2">        1  True  True</span>
<span class="s2">        2  True  True</span>
<span class="s2">        3  True  True</span>
<span class="s2">        4  True  True</span>
<span class="s2">        &gt;&gt;&gt; df.where(m, -df) == df.mask(~m, -df)</span>
<span class="s2">              A     B</span>
<span class="s2">        0  True  True</span>
<span class="s2">        1  True  True</span>
<span class="s2">        2  True  True</span>
<span class="s2">        3  True  True</span>
<span class="s2">        4  True  True</span>

<span class="s2">        See Also</span>
<span class="s2">        --------</span>
<span class="s2">        :func:`DataFrame.</span><span class="si">%(name_other)s</span><span class="s2">`</span>
<span class="s2">        &quot;&quot;&quot;</span><span class="p">)</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s1">&#39;where&#39;</span><span class="p">]</span> <span class="o">%</span> <span class="nb">dict</span><span class="p">(</span><span class="n">_shared_doc_kwargs</span><span class="p">,</span> <span class="n">cond</span><span class="o">=</span><span class="s2">&quot;True&quot;</span><span class="p">,</span>
                                           <span class="n">cond_rev</span><span class="o">=</span><span class="s2">&quot;False&quot;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;where&#39;</span><span class="p">,</span>
                                           <span class="n">name_other</span><span class="o">=</span><span class="s1">&#39;mask&#39;</span><span class="p">))</span>
    <span class="k">def</span> <span class="nf">where</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cond</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
              <span class="n">errors</span><span class="o">=</span><span class="s1">&#39;raise&#39;</span><span class="p">,</span> <span class="n">try_cast</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">raise_on_error</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">raise_on_error</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;raise_on_error is deprecated in &quot;</span>
                <span class="s2">&quot;favor of errors=&#39;raise|ignore&#39;&quot;</span><span class="p">,</span>
                <span class="ne">FutureWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">raise_on_error</span><span class="p">:</span>
                <span class="n">errors</span> <span class="o">=</span> <span class="s1">&#39;raise&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">errors</span> <span class="o">=</span> <span class="s1">&#39;ignore&#39;</span>

        <span class="n">other</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">_apply_if_callable</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_where</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">inplace</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span>
                           <span class="n">errors</span><span class="o">=</span><span class="n">errors</span><span class="p">,</span> <span class="n">try_cast</span><span class="o">=</span><span class="n">try_cast</span><span class="p">)</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s1">&#39;where&#39;</span><span class="p">]</span> <span class="o">%</span> <span class="nb">dict</span><span class="p">(</span><span class="n">_shared_doc_kwargs</span><span class="p">,</span> <span class="n">cond</span><span class="o">=</span><span class="s2">&quot;False&quot;</span><span class="p">,</span>
                                           <span class="n">cond_rev</span><span class="o">=</span><span class="s2">&quot;True&quot;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;mask&#39;</span><span class="p">,</span>
                                           <span class="n">name_other</span><span class="o">=</span><span class="s1">&#39;where&#39;</span><span class="p">))</span>
    <span class="k">def</span> <span class="nf">mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cond</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">errors</span><span class="o">=</span><span class="s1">&#39;raise&#39;</span><span class="p">,</span> <span class="n">try_cast</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">raise_on_error</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">raise_on_error</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;raise_on_error is deprecated in &quot;</span>
                <span class="s2">&quot;favor of errors=&#39;raise|ignore&#39;&quot;</span><span class="p">,</span>
                <span class="ne">FutureWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">raise_on_error</span><span class="p">:</span>
                <span class="n">errors</span> <span class="o">=</span> <span class="s1">&#39;raise&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">errors</span> <span class="o">=</span> <span class="s1">&#39;ignore&#39;</span>

        <span class="n">inplace</span> <span class="o">=</span> <span class="n">validate_bool_kwarg</span><span class="p">(</span><span class="n">inplace</span><span class="p">,</span> <span class="s1">&#39;inplace&#39;</span><span class="p">)</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">_apply_if_callable</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">cond</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
                          <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span> <span class="n">try_cast</span><span class="o">=</span><span class="n">try_cast</span><span class="p">,</span>
                          <span class="n">errors</span><span class="o">=</span><span class="n">errors</span><span class="p">)</span>

    <span class="n">_shared_docs</span><span class="p">[</span><span class="s1">&#39;shift&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        Shift index by desired number of periods with an optional time freq</span>

<span class="s2">        Parameters</span>
<span class="s2">        ----------</span>
<span class="s2">        periods : int</span>
<span class="s2">            Number of periods to move, can be positive or negative</span>
<span class="s2">        freq : DateOffset, timedelta, or time rule string, optional</span>
<span class="s2">            Increment to use from the tseries module or time rule (e.g. &#39;EOM&#39;).</span>
<span class="s2">            See Notes.</span>
<span class="s2">        axis : </span><span class="si">%(axes_single_arg)s</span><span class="s2"></span>

<span class="s2">        Notes</span>
<span class="s2">        -----</span>
<span class="s2">        If freq is specified then the index values are shifted but the data</span>
<span class="s2">        is not realigned. That is, use freq if you would like to extend the</span>
<span class="s2">        index when shifting and preserve the original data.</span>

<span class="s2">        Returns</span>
<span class="s2">        -------</span>
<span class="s2">        shifted : </span><span class="si">%(klass)s</span><span class="s2"></span>
<span class="s2">    &quot;&quot;&quot;</span><span class="p">)</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s1">&#39;shift&#39;</span><span class="p">]</span> <span class="o">%</span> <span class="n">_shared_doc_kwargs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">shift</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">periods</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">periods</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="n">block_axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_block_manager_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">freq</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="n">periods</span><span class="o">=</span><span class="n">periods</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">block_axis</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tshift</span><span class="p">(</span><span class="n">periods</span><span class="p">,</span> <span class="n">freq</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">new_data</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">slice_shift</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">periods</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Equivalent to `shift` without copying data. The shifted data will</span>
<span class="sd">        not include the dropped periods and the shifted axis will be smaller</span>
<span class="sd">        than the original.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        periods : int</span>
<span class="sd">            Number of periods to move, can be positive or negative</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        While the `slice_shift` is faster than `shift`, you may pay for it</span>
<span class="sd">        later during alignment.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        shifted : same type as caller</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">periods</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="k">if</span> <span class="n">periods</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">vslicer</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="o">-</span><span class="n">periods</span><span class="p">)</span>
            <span class="n">islicer</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">periods</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">vslicer</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="o">-</span><span class="n">periods</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">islicer</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">periods</span><span class="p">)</span>

        <span class="n">new_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_slice</span><span class="p">(</span><span class="n">vslicer</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">shifted_axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)[</span><span class="n">islicer</span><span class="p">]</span>
        <span class="n">new_obj</span><span class="o">.</span><span class="n">set_axis</span><span class="p">(</span><span class="n">shifted_axis</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">new_obj</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">tshift</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">periods</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Shift the time index, using the index&#39;s frequency if available.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        periods : int</span>
<span class="sd">            Number of periods to move, can be positive or negative</span>
<span class="sd">        freq : DateOffset, timedelta, or time rule string, default None</span>
<span class="sd">            Increment to use from the tseries module or time rule (e.g. &#39;EOM&#39;)</span>
<span class="sd">        axis : int or basestring</span>
<span class="sd">            Corresponds to the axis that contains the Index</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If freq is not specified then tries to use the freq or inferred_freq</span>
<span class="sd">        attributes of the index. If neither of those attributes exist, a</span>
<span class="sd">        ValueError is thrown</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        shifted : NDFrame</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">freq</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">freq</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="s1">&#39;freq&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">freq</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">freq</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="s1">&#39;inferred_freq&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">freq</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Freq was not given and was not set in the index&#39;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">periods</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
            <span class="n">freq</span> <span class="o">=</span> <span class="n">to_offset</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span>

        <span class="n">block_axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_block_manager_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">PeriodIndex</span><span class="p">):</span>
            <span class="n">orig_freq</span> <span class="o">=</span> <span class="n">to_offset</span><span class="p">(</span><span class="n">index</span><span class="o">.</span><span class="n">freq</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">freq</span> <span class="o">==</span> <span class="n">orig_freq</span><span class="p">:</span>
                <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">new_data</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">block_axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="n">periods</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;Given freq </span><span class="si">%s</span><span class="s1"> does not match PeriodIndex freq </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span>
                       <span class="p">(</span><span class="n">freq</span><span class="o">.</span><span class="n">rule_code</span><span class="p">,</span> <span class="n">orig_freq</span><span class="o">.</span><span class="n">rule_code</span><span class="p">))</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">new_data</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">block_axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="n">periods</span><span class="p">,</span> <span class="n">freq</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">new_data</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">truncate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">before</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">after</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Truncates a sorted DataFrame/Series before and/or after some</span>
<span class="sd">        particular index value. If the axis contains only datetime values,</span>
<span class="sd">        before/after parameters are converted to datetime values.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        before : date, string, int</span>
<span class="sd">            Truncate all rows before this index value</span>
<span class="sd">        after : date, string, int</span>
<span class="sd">            Truncate all rows after this index value</span>
<span class="sd">        axis : {0 or &#39;index&#39;, 1 or &#39;columns&#39;}</span>

<span class="sd">            * 0 or &#39;index&#39;: apply truncation to rows</span>
<span class="sd">            * 1 or &#39;columns&#39;: apply truncation to columns</span>
<span class="sd">            Default is stat axis for given data type (0 for Series and</span>
<span class="sd">            DataFrames, 1 for Panels)</span>
<span class="sd">        copy : boolean, default is True,</span>
<span class="sd">            return a copy of the truncated section</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        truncated : type of caller</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;A&#39;: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;],</span>
<span class="sd">        ...                    &#39;B&#39;: [&#39;f&#39;, &#39;g&#39;, &#39;h&#39;, &#39;i&#39;, &#39;j&#39;],</span>
<span class="sd">        ...                    &#39;C&#39;: [&#39;k&#39;, &#39;l&#39;, &#39;m&#39;, &#39;n&#39;, &#39;o&#39;]},</span>
<span class="sd">        ...                    index=[1, 2, 3, 4, 5])</span>
<span class="sd">        &gt;&gt;&gt; df.truncate(before=2, after=4)</span>
<span class="sd">           A  B  C</span>
<span class="sd">        2  b  g  l</span>
<span class="sd">        3  c  h  m</span>
<span class="sd">        4  d  i  n</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;A&#39;: [1, 2, 3, 4, 5],</span>
<span class="sd">        ...                    &#39;B&#39;: [6, 7, 8, 9, 10],</span>
<span class="sd">        ...                    &#39;C&#39;: [11, 12, 13, 14, 15]},</span>
<span class="sd">        ...                    index=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;])</span>
<span class="sd">        &gt;&gt;&gt; df.truncate(before=&#39;b&#39;, after=&#39;d&#39;)</span>
<span class="sd">           A  B   C</span>
<span class="sd">        b  2  7  12</span>
<span class="sd">        c  3  8  13</span>
<span class="sd">        d  4  9  14</span>

<span class="sd">        The index values in ``truncate`` can be datetimes or string</span>
<span class="sd">        dates. Note that ``truncate`` assumes a 0 value for any unspecified</span>
<span class="sd">        date component in a ``DatetimeIndex`` in contrast to slicing which</span>
<span class="sd">        returns any partially matching dates.</span>

<span class="sd">        &gt;&gt;&gt; dates = pd.date_range(&#39;2016-01-01&#39;, &#39;2016-02-01&#39;, freq=&#39;s&#39;)</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame(index=dates, data={&#39;A&#39;: 1})</span>
<span class="sd">        &gt;&gt;&gt; df.truncate(&#39;2016-01-05&#39;, &#39;2016-01-10&#39;).tail()</span>
<span class="sd">                             A</span>
<span class="sd">        2016-01-09 23:59:56  1</span>
<span class="sd">        2016-01-09 23:59:57  1</span>
<span class="sd">        2016-01-09 23:59:58  1</span>
<span class="sd">        2016-01-09 23:59:59  1</span>
<span class="sd">        2016-01-10 00:00:00  1</span>
<span class="sd">        &gt;&gt;&gt; df.loc[&#39;2016-01-05&#39;:&#39;2016-01-10&#39;, :].tail()</span>
<span class="sd">                             A</span>
<span class="sd">        2016-01-10 23:59:55  1</span>
<span class="sd">        2016-01-10 23:59:56  1</span>
<span class="sd">        2016-01-10 23:59:57  1</span>
<span class="sd">        2016-01-10 23:59:58  1</span>
<span class="sd">        2016-01-10 23:59:59  1</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stat_axis_number</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

        <span class="c1"># if we have a date index, convert to dates, otherwise</span>
        <span class="c1"># treat like a slice</span>
        <span class="k">if</span> <span class="n">ax</span><span class="o">.</span><span class="n">is_all_dates</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">pandas.core.tools.datetimes</span> <span class="k">import</span> <span class="n">to_datetime</span>
            <span class="n">before</span> <span class="o">=</span> <span class="n">to_datetime</span><span class="p">(</span><span class="n">before</span><span class="p">)</span>
            <span class="n">after</span> <span class="o">=</span> <span class="n">to_datetime</span><span class="p">(</span><span class="n">after</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">before</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">after</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">before</span> <span class="o">&gt;</span> <span class="n">after</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Truncate: </span><span class="si">%s</span><span class="s1"> must be after </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span>
                                 <span class="p">(</span><span class="n">after</span><span class="p">,</span> <span class="n">before</span><span class="p">))</span>

        <span class="n">slicer</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_AXIS_LEN</span>
        <span class="n">slicer</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">before</span><span class="p">,</span> <span class="n">after</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slicer</span><span class="p">)]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">):</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_name</span><span class="p">(</span><span class="n">axis</span><span class="p">),</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">truncate</span><span class="p">(</span><span class="n">before</span><span class="p">,</span> <span class="n">after</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">tz_convert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tz</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert tz-aware axis to target time zone.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tz : string or pytz.timezone object</span>
<span class="sd">        axis : the axis to convert</span>
<span class="sd">        level : int, str, default None</span>
<span class="sd">            If axis ia a MultiIndex, convert a specific level. Otherwise</span>
<span class="sd">            must be None</span>
<span class="sd">        copy : boolean, default True</span>
<span class="sd">            Also make a copy of the underlying data</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        TypeError</span>
<span class="sd">            If the axis is tz-naive.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">_tz_convert</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">tz</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="s1">&#39;tz_convert&#39;</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">ax_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_name</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> is not a valid DatetimeIndex or &#39;</span>
                                    <span class="s1">&#39;PeriodIndex&#39;</span> <span class="o">%</span> <span class="n">ax_name</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ax</span> <span class="o">=</span> <span class="n">DatetimeIndex</span><span class="p">([],</span> <span class="n">tz</span><span class="o">=</span><span class="n">tz</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ax</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">tz_convert</span><span class="p">(</span><span class="n">tz</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">ax</span>

        <span class="c1"># if a level is given it must be a MultiIndex level or</span>
        <span class="c1"># equivalent to the axis name</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">):</span>
            <span class="n">level</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">_get_level_number</span><span class="p">(</span><span class="n">level</span><span class="p">)</span>
            <span class="n">new_level</span> <span class="o">=</span> <span class="n">_tz_convert</span><span class="p">(</span><span class="n">ax</span><span class="o">.</span><span class="n">levels</span><span class="p">[</span><span class="n">level</span><span class="p">],</span> <span class="n">tz</span><span class="p">)</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">set_levels</span><span class="p">(</span><span class="n">new_level</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">level</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ax</span><span class="o">.</span><span class="n">name</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The level </span><span class="si">{0}</span><span class="s2"> is not valid&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">level</span><span class="p">))</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">_tz_convert</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">tz</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>
        <span class="n">result</span><span class="o">.</span><span class="n">set_axis</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@deprecate_kwarg</span><span class="p">(</span><span class="n">old_arg_name</span><span class="o">=</span><span class="s1">&#39;infer_dst&#39;</span><span class="p">,</span> <span class="n">new_arg_name</span><span class="o">=</span><span class="s1">&#39;ambiguous&#39;</span><span class="p">,</span>
                     <span class="n">mapping</span><span class="o">=</span><span class="p">{</span><span class="kc">True</span><span class="p">:</span> <span class="s1">&#39;infer&#39;</span><span class="p">,</span>
                              <span class="kc">False</span><span class="p">:</span> <span class="s1">&#39;raise&#39;</span><span class="p">})</span>
    <span class="k">def</span> <span class="nf">tz_localize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tz</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">ambiguous</span><span class="o">=</span><span class="s1">&#39;raise&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Localize tz-naive TimeSeries to target time zone.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tz : string or pytz.timezone object</span>
<span class="sd">        axis : the axis to localize</span>
<span class="sd">        level : int, str, default None</span>
<span class="sd">            If axis ia a MultiIndex, localize a specific level. Otherwise</span>
<span class="sd">            must be None</span>
<span class="sd">        copy : boolean, default True</span>
<span class="sd">            Also make a copy of the underlying data</span>
<span class="sd">        ambiguous : &#39;infer&#39;, bool-ndarray, &#39;NaT&#39;, default &#39;raise&#39;</span>
<span class="sd">            - &#39;infer&#39; will attempt to infer fall dst-transition hours based on</span>
<span class="sd">              order</span>
<span class="sd">            - bool-ndarray where True signifies a DST time, False designates</span>
<span class="sd">              a non-DST time (note that this flag is only applicable for</span>
<span class="sd">              ambiguous times)</span>
<span class="sd">            - &#39;NaT&#39; will return NaT where there are ambiguous times</span>
<span class="sd">            - &#39;raise&#39; will raise an AmbiguousTimeError if there are ambiguous</span>
<span class="sd">              times</span>
<span class="sd">        infer_dst : boolean, default False</span>
<span class="sd">            .. deprecated:: 0.15.0</span>
<span class="sd">               Attempt to infer fall dst-transition hours based on order</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        TypeError</span>
<span class="sd">            If the TimeSeries is tz-aware and tz is not None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">_tz_localize</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">tz</span><span class="p">,</span> <span class="n">ambiguous</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="s1">&#39;tz_localize&#39;</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">ax_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_name</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> is not a valid DatetimeIndex or &#39;</span>
                                    <span class="s1">&#39;PeriodIndex&#39;</span> <span class="o">%</span> <span class="n">ax_name</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ax</span> <span class="o">=</span> <span class="n">DatetimeIndex</span><span class="p">([],</span> <span class="n">tz</span><span class="o">=</span><span class="n">tz</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ax</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">tz_localize</span><span class="p">(</span><span class="n">tz</span><span class="p">,</span> <span class="n">ambiguous</span><span class="o">=</span><span class="n">ambiguous</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">ax</span>

        <span class="c1"># if a level is given it must be a MultiIndex level or</span>
        <span class="c1"># equivalent to the axis name</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">):</span>
            <span class="n">level</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">_get_level_number</span><span class="p">(</span><span class="n">level</span><span class="p">)</span>
            <span class="n">new_level</span> <span class="o">=</span> <span class="n">_tz_localize</span><span class="p">(</span><span class="n">ax</span><span class="o">.</span><span class="n">levels</span><span class="p">[</span><span class="n">level</span><span class="p">],</span> <span class="n">tz</span><span class="p">,</span> <span class="n">ambiguous</span><span class="p">)</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">set_levels</span><span class="p">(</span><span class="n">new_level</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">level</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ax</span><span class="o">.</span><span class="n">name</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The level </span><span class="si">{0}</span><span class="s2"> is not valid&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">level</span><span class="p">))</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">_tz_localize</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">tz</span><span class="p">,</span> <span class="n">ambiguous</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>
        <span class="n">result</span><span class="o">.</span><span class="n">set_axis</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># Numeric Methods</span>
    <span class="k">def</span> <span class="nf">abs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an object with absolute value taken--only applicable to objects</span>
<span class="sd">        that are all numeric.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        abs: type of caller</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">describe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">percentiles</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">include</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates descriptive statistics that summarize the central tendency,</span>
<span class="sd">        dispersion and shape of a dataset&#39;s distribution, excluding</span>
<span class="sd">        ``NaN`` values.</span>

<span class="sd">        Analyzes both numeric and object series, as well</span>
<span class="sd">        as ``DataFrame`` column sets of mixed data types. The output</span>
<span class="sd">        will vary depending on what is provided. Refer to the notes</span>
<span class="sd">        below for more detail.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        percentiles : list-like of numbers, optional</span>
<span class="sd">            The percentiles to include in the output. All should</span>
<span class="sd">            fall between 0 and 1. The default is</span>
<span class="sd">            ``[.25, .5, .75]``, which returns the 25th, 50th, and</span>
<span class="sd">            75th percentiles.</span>
<span class="sd">        include : &#39;all&#39;, list-like of dtypes or None (default), optional</span>
<span class="sd">            A white list of data types to include in the result. Ignored</span>
<span class="sd">            for ``Series``. Here are the options:</span>

<span class="sd">            - &#39;all&#39; : All columns of the input will be included in the output.</span>
<span class="sd">            - A list-like of dtypes : Limits the results to the</span>
<span class="sd">              provided data types.</span>
<span class="sd">              To limit the result to numeric types submit</span>
<span class="sd">              ``numpy.number``. To limit it instead to object columns submit</span>
<span class="sd">              the ``numpy.object`` data type. Strings</span>
<span class="sd">              can also be used in the style of</span>
<span class="sd">              ``select_dtypes`` (e.g. ``df.describe(include=[&#39;O&#39;])``). To</span>
<span class="sd">              select pandas categorical columns, use ``&#39;category&#39;``</span>
<span class="sd">            - None (default) : The result will include all numeric columns.</span>
<span class="sd">        exclude : list-like of dtypes or None (default), optional,</span>
<span class="sd">            A black list of data types to omit from the result. Ignored</span>
<span class="sd">            for ``Series``. Here are the options:</span>

<span class="sd">            - A list-like of dtypes : Excludes the provided data types</span>
<span class="sd">              from the result. To exclude numeric types submit</span>
<span class="sd">              ``numpy.number``. To exclude object columns submit the data</span>
<span class="sd">              type ``numpy.object``. Strings can also be used in the style of</span>
<span class="sd">              ``select_dtypes`` (e.g. ``df.describe(include=[&#39;O&#39;])``). To</span>
<span class="sd">              exclude pandas categorical columns, use ``&#39;category&#39;``</span>
<span class="sd">            - None (default) : The result will exclude nothing.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        summary:  Series/DataFrame of summary statistics</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        For numeric data, the result&#39;s index will include ``count``,</span>
<span class="sd">        ``mean``, ``std``, ``min``, ``max`` as well as lower, ``50`` and</span>
<span class="sd">        upper percentiles. By default the lower percentile is ``25`` and the</span>
<span class="sd">        upper percentile is ``75``. The ``50`` percentile is the</span>
<span class="sd">        same as the median.</span>

<span class="sd">        For object data (e.g. strings or timestamps), the result&#39;s index</span>
<span class="sd">        will include ``count``, ``unique``, ``top``, and ``freq``. The ``top``</span>
<span class="sd">        is the most common value. The ``freq`` is the most common value&#39;s</span>
<span class="sd">        frequency. Timestamps also include the ``first`` and ``last`` items.</span>

<span class="sd">        If multiple object values have the highest count, then the</span>
<span class="sd">        ``count`` and ``top`` results will be arbitrarily chosen from</span>
<span class="sd">        among those with the highest count.</span>

<span class="sd">        For mixed data types provided via a ``DataFrame``, the default is to</span>
<span class="sd">        return only an analysis of numeric columns. If the dataframe consists</span>
<span class="sd">        only of object and categorical data without any numeric columns, the</span>
<span class="sd">        default is to return an analysis of both the object and categorical</span>
<span class="sd">        columns. If ``include=&#39;all&#39;`` is provided as an option, the result</span>
<span class="sd">        will include a union of attributes of each type.</span>

<span class="sd">        The `include` and `exclude` parameters can be used to limit</span>
<span class="sd">        which columns in a ``DataFrame`` are analyzed for the output.</span>
<span class="sd">        The parameters are ignored when analyzing a ``Series``.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Describing a numeric ``Series``.</span>

<span class="sd">        &gt;&gt;&gt; s = pd.Series([1, 2, 3])</span>
<span class="sd">        &gt;&gt;&gt; s.describe()</span>
<span class="sd">        count    3.0</span>
<span class="sd">        mean     2.0</span>
<span class="sd">        std      1.0</span>
<span class="sd">        min      1.0</span>
<span class="sd">        25%      1.5</span>
<span class="sd">        50%      2.0</span>
<span class="sd">        75%      2.5</span>
<span class="sd">        max      3.0</span>

<span class="sd">        Describing a categorical ``Series``.</span>

<span class="sd">        &gt;&gt;&gt; s = pd.Series([&#39;a&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;])</span>
<span class="sd">        &gt;&gt;&gt; s.describe()</span>
<span class="sd">        count     4</span>
<span class="sd">        unique    3</span>
<span class="sd">        top       a</span>
<span class="sd">        freq      2</span>
<span class="sd">        dtype: object</span>

<span class="sd">        Describing a timestamp ``Series``.</span>

<span class="sd">        &gt;&gt;&gt; s = pd.Series([</span>
<span class="sd">        ...   np.datetime64(&quot;2000-01-01&quot;),</span>
<span class="sd">        ...   np.datetime64(&quot;2010-01-01&quot;),</span>
<span class="sd">        ...   np.datetime64(&quot;2010-01-01&quot;)</span>
<span class="sd">        ... ])</span>
<span class="sd">        &gt;&gt;&gt; s.describe()</span>
<span class="sd">        count                       3</span>
<span class="sd">        unique                      2</span>
<span class="sd">        top       2010-01-01 00:00:00</span>
<span class="sd">        freq                        2</span>
<span class="sd">        first     2000-01-01 00:00:00</span>
<span class="sd">        last      2010-01-01 00:00:00</span>
<span class="sd">        dtype: object</span>

<span class="sd">        Describing a ``DataFrame``. By default only numeric fields</span>
<span class="sd">        are returned.</span>

<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({ &#39;object&#39;: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;],</span>
<span class="sd">        ...                     &#39;numeric&#39;: [1, 2, 3],</span>
<span class="sd">        ...                     &#39;categorical&#39;: pd.Categorical([&#39;d&#39;,&#39;e&#39;,&#39;f&#39;])</span>
<span class="sd">        ...                   })</span>
<span class="sd">        &gt;&gt;&gt; df.describe()</span>
<span class="sd">               numeric</span>
<span class="sd">        count      3.0</span>
<span class="sd">        mean       2.0</span>
<span class="sd">        std        1.0</span>
<span class="sd">        min        1.0</span>
<span class="sd">        25%        1.5</span>
<span class="sd">        50%        2.0</span>
<span class="sd">        75%        2.5</span>
<span class="sd">        max        3.0</span>

<span class="sd">        Describing all columns of a ``DataFrame`` regardless of data type.</span>

<span class="sd">        &gt;&gt;&gt; df.describe(include=&#39;all&#39;)</span>
<span class="sd">                categorical  numeric object</span>
<span class="sd">        count            3      3.0      3</span>
<span class="sd">        unique           3      NaN      3</span>
<span class="sd">        top              f      NaN      c</span>
<span class="sd">        freq             1      NaN      1</span>
<span class="sd">        mean           NaN      2.0    NaN</span>
<span class="sd">        std            NaN      1.0    NaN</span>
<span class="sd">        min            NaN      1.0    NaN</span>
<span class="sd">        25%            NaN      1.5    NaN</span>
<span class="sd">        50%            NaN      2.0    NaN</span>
<span class="sd">        75%            NaN      2.5    NaN</span>
<span class="sd">        max            NaN      3.0    NaN</span>

<span class="sd">        Describing a column from a ``DataFrame`` by accessing it as</span>
<span class="sd">        an attribute.</span>

<span class="sd">        &gt;&gt;&gt; df.numeric.describe()</span>
<span class="sd">        count    3.0</span>
<span class="sd">        mean     2.0</span>
<span class="sd">        std      1.0</span>
<span class="sd">        min      1.0</span>
<span class="sd">        25%      1.5</span>
<span class="sd">        50%      2.0</span>
<span class="sd">        75%      2.5</span>
<span class="sd">        max      3.0</span>
<span class="sd">        Name: numeric, dtype: float64</span>

<span class="sd">        Including only numeric columns in a ``DataFrame`` description.</span>

<span class="sd">        &gt;&gt;&gt; df.describe(include=[np.number])</span>
<span class="sd">               numeric</span>
<span class="sd">        count      3.0</span>
<span class="sd">        mean       2.0</span>
<span class="sd">        std        1.0</span>
<span class="sd">        min        1.0</span>
<span class="sd">        25%        1.5</span>
<span class="sd">        50%        2.0</span>
<span class="sd">        75%        2.5</span>
<span class="sd">        max        3.0</span>

<span class="sd">        Including only string columns in a ``DataFrame`` description.</span>

<span class="sd">        &gt;&gt;&gt; df.describe(include=[np.object])</span>
<span class="sd">               object</span>
<span class="sd">        count       3</span>
<span class="sd">        unique      3</span>
<span class="sd">        top         c</span>
<span class="sd">        freq        1</span>

<span class="sd">        Including only categorical columns from a ``DataFrame`` description.</span>

<span class="sd">        &gt;&gt;&gt; df.describe(include=[&#39;category&#39;])</span>
<span class="sd">               categorical</span>
<span class="sd">        count            3</span>
<span class="sd">        unique           3</span>
<span class="sd">        top              f</span>
<span class="sd">        freq             1</span>

<span class="sd">        Excluding numeric columns from a ``DataFrame`` description.</span>

<span class="sd">        &gt;&gt;&gt; df.describe(exclude=[np.number])</span>
<span class="sd">               categorical object</span>
<span class="sd">        count            3      3</span>
<span class="sd">        unique           3      3</span>
<span class="sd">        top              f      c</span>
<span class="sd">        freq             1      1</span>

<span class="sd">        Excluding object columns from a ``DataFrame`` description.</span>

<span class="sd">        &gt;&gt;&gt; df.describe(exclude=[np.object])</span>
<span class="sd">                categorical  numeric</span>
<span class="sd">        count            3      3.0</span>
<span class="sd">        unique           3      NaN</span>
<span class="sd">        top              f      NaN</span>
<span class="sd">        freq             1      NaN</span>
<span class="sd">        mean           NaN      2.0</span>
<span class="sd">        std            NaN      1.0</span>
<span class="sd">        min            NaN      1.0</span>
<span class="sd">        25%            NaN      1.5</span>
<span class="sd">        50%            NaN      2.0</span>
<span class="sd">        75%            NaN      2.5</span>
<span class="sd">        max            NaN      3.0</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrame.count</span>
<span class="sd">        DataFrame.max</span>
<span class="sd">        DataFrame.min</span>
<span class="sd">        DataFrame.mean</span>
<span class="sd">        DataFrame.std</span>
<span class="sd">        DataFrame.select_dtypes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;describe is not implemented on Panel or PanelND objects.&quot;</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot describe a DataFrame without columns&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">percentiles</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># explicit conversion of `percentiles` to list</span>
            <span class="n">percentiles</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">percentiles</span><span class="p">)</span>

            <span class="c1"># get them all to be in [0, 1]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_percentile</span><span class="p">(</span><span class="n">percentiles</span><span class="p">)</span>

            <span class="c1"># median should always be included</span>
            <span class="k">if</span> <span class="mf">0.5</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">percentiles</span><span class="p">:</span>
                <span class="n">percentiles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
            <span class="n">percentiles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">percentiles</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">percentiles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">])</span>

        <span class="c1"># sort and check for duplicates</span>
        <span class="n">unique_pcts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">percentiles</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_pcts</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">percentiles</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;percentiles cannot contain duplicates&quot;</span><span class="p">)</span>
        <span class="n">percentiles</span> <span class="o">=</span> <span class="n">unique_pcts</span>

        <span class="n">formatted_percentiles</span> <span class="o">=</span> <span class="n">format_percentiles</span><span class="p">(</span><span class="n">percentiles</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">describe_numeric_1d</span><span class="p">(</span><span class="n">series</span><span class="p">):</span>
            <span class="n">stat_index</span> <span class="o">=</span> <span class="p">([</span><span class="s1">&#39;count&#39;</span><span class="p">,</span> <span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="s1">&#39;std&#39;</span><span class="p">,</span> <span class="s1">&#39;min&#39;</span><span class="p">]</span> <span class="o">+</span>
                          <span class="n">formatted_percentiles</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;max&#39;</span><span class="p">])</span>
            <span class="n">d</span> <span class="o">=</span> <span class="p">([</span><span class="n">series</span><span class="o">.</span><span class="n">count</span><span class="p">(),</span> <span class="n">series</span><span class="o">.</span><span class="n">mean</span><span class="p">(),</span> <span class="n">series</span><span class="o">.</span><span class="n">std</span><span class="p">(),</span> <span class="n">series</span><span class="o">.</span><span class="n">min</span><span class="p">()]</span> <span class="o">+</span>
                 <span class="p">[</span><span class="n">series</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">percentiles</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">series</span><span class="o">.</span><span class="n">max</span><span class="p">()])</span>
            <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">stat_index</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">series</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">describe_categorical_1d</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
            <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;count&#39;</span><span class="p">,</span> <span class="s1">&#39;unique&#39;</span><span class="p">]</span>
            <span class="n">objcounts</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">value_counts</span><span class="p">()</span>
            <span class="n">count_unique</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">objcounts</span><span class="p">[</span><span class="n">objcounts</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">])</span>
            <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">data</span><span class="o">.</span><span class="n">count</span><span class="p">(),</span> <span class="n">count_unique</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">top</span><span class="p">,</span> <span class="n">freq</span> <span class="o">=</span> <span class="n">objcounts</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">objcounts</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">is_datetime64_dtype</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
                    <span class="n">asint</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="s1">&#39;i8&#39;</span><span class="p">)</span>
                    <span class="n">names</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;top&#39;</span><span class="p">,</span> <span class="s1">&#39;freq&#39;</span><span class="p">,</span> <span class="s1">&#39;first&#39;</span><span class="p">,</span> <span class="s1">&#39;last&#39;</span><span class="p">]</span>
                    <span class="n">result</span> <span class="o">+=</span> <span class="p">[</span><span class="n">lib</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="n">top</span><span class="p">),</span> <span class="n">freq</span><span class="p">,</span>
                               <span class="n">lib</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="n">asint</span><span class="o">.</span><span class="n">min</span><span class="p">()),</span>
                               <span class="n">lib</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="n">asint</span><span class="o">.</span><span class="n">max</span><span class="p">())]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">names</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;top&#39;</span><span class="p">,</span> <span class="s1">&#39;freq&#39;</span><span class="p">]</span>
                    <span class="n">result</span> <span class="o">+=</span> <span class="p">[</span><span class="n">top</span><span class="p">,</span> <span class="n">freq</span><span class="p">]</span>

            <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">names</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">describe_1d</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">is_bool_dtype</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">describe_categorical_1d</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">is_numeric_dtype</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">describe_numeric_1d</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">is_timedelta64_dtype</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">describe_numeric_1d</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">describe_categorical_1d</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">describe_1d</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">include</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">exclude</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="c1"># when some numerics are found, keep only numerics</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">select_dtypes</span><span class="p">(</span><span class="n">include</span><span class="o">=</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">])</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">elif</span> <span class="n">include</span> <span class="o">==</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">exclude</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;exclude must be None when include is &#39;all&#39;&quot;</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">select_dtypes</span><span class="p">(</span><span class="n">include</span><span class="o">=</span><span class="n">include</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="n">exclude</span><span class="p">)</span>

        <span class="n">ldesc</span> <span class="o">=</span> <span class="p">[</span><span class="n">describe_1d</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">iteritems</span><span class="p">()]</span>
        <span class="c1"># set a convenient order for rows</span>
        <span class="n">names</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">ldesc_indexes</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">index</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ldesc</span><span class="p">],</span> <span class="n">key</span><span class="o">=</span><span class="nb">len</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">idxnames</span> <span class="ow">in</span> <span class="n">ldesc_indexes</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">idxnames</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
                    <span class="n">names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

        <span class="n">d</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">ldesc</span><span class="p">,</span> <span class="n">join_axes</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">([</span><span class="n">names</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">d</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">d</span>

    <span class="k">def</span> <span class="nf">_check_percentile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">q</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Validate percentiles (used by describe and quantile).&quot;&quot;&quot;</span>

        <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;percentiles should all be in the interval [0, 1]. &quot;</span>
               <span class="s2">&quot;Try </span><span class="si">{0}</span><span class="s2"> instead.&quot;</span><span class="p">)</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">q</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">q</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">q</span> <span class="o">/</span> <span class="mf">100.0</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">qs</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">qs</span> <span class="ow">in</span> <span class="n">q</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">q</span> <span class="o">/</span> <span class="mf">100.0</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">q</span>

    <span class="n">_shared_docs</span><span class="p">[</span><span class="s1">&#39;pct_change&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        Percent change over given number of periods.</span>

<span class="s2">        Parameters</span>
<span class="s2">        ----------</span>
<span class="s2">        periods : int, default 1</span>
<span class="s2">            Periods to shift for forming percent change</span>
<span class="s2">        fill_method : str, default &#39;pad&#39;</span>
<span class="s2">            How to handle NAs before computing percent changes</span>
<span class="s2">        limit : int, default None</span>
<span class="s2">            The number of consecutive NAs to fill before stopping</span>
<span class="s2">        freq : DateOffset, timedelta, or offset alias string, optional</span>
<span class="s2">            Increment to use from time series API (e.g. &#39;M&#39; or BDay())</span>

<span class="s2">        Returns</span>
<span class="s2">        -------</span>
<span class="s2">        chg : </span><span class="si">%(klass)s</span><span class="s2"></span>

<span class="s2">        Notes</span>
<span class="s2">        -----</span>

<span class="s2">        By default, the percentage change is calculated along the stat</span>
<span class="s2">        axis: 0, or ``Index``, for ``DataFrame`` and 1, or ``minor`` for</span>
<span class="s2">        ``Panel``. You can change this with the ``axis`` keyword argument.</span>
<span class="s2">        &quot;&quot;&quot;</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s1">&#39;pct_change&#39;</span><span class="p">]</span> <span class="o">%</span> <span class="n">_shared_doc_kwargs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">pct_change</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">periods</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">fill_method</span><span class="o">=</span><span class="s1">&#39;pad&#39;</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                   <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># TODO: Not sure if above is correct - need someone to confirm.</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;axis&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stat_axis_name</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">fill_method</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="n">fill_method</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

        <span class="n">rs</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">div</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="n">periods</span><span class="o">=</span><span class="n">periods</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
                                  <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">freq</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">isna</span><span class="p">(</span><span class="n">_values_from_object</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
            <span class="n">np</span><span class="o">.</span><span class="n">putmask</span><span class="p">(</span><span class="n">rs</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">rs</span>

    <span class="k">def</span> <span class="nf">_agg_by_level</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">grouped</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">grouped</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="ow">and</span> <span class="n">skipna</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">grouped</span><span class="p">,</span> <span class="n">name</span><span class="p">)(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">method</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">name</span><span class="p">)</span>
        <span class="n">applyf</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">method</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="n">skipna</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">grouped</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span><span class="n">applyf</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_add_numeric_operations</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add the operations to the cls; evaluate the doc strings again&quot;&quot;&quot;</span>

        <span class="n">axis_descr</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">name2</span> <span class="o">=</span> <span class="n">_doc_parms</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>

        <span class="bp">cls</span><span class="o">.</span><span class="n">any</span> <span class="o">=</span> <span class="n">_make_logical_function</span><span class="p">(</span>
            <span class="bp">cls</span><span class="p">,</span> <span class="s1">&#39;any&#39;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">name2</span><span class="p">,</span> <span class="n">axis_descr</span><span class="p">,</span>
            <span class="s1">&#39;Return whether any element is True over requested axis&#39;</span><span class="p">,</span>
            <span class="n">nanops</span><span class="o">.</span><span class="n">nanany</span><span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">all</span> <span class="o">=</span> <span class="n">_make_logical_function</span><span class="p">(</span>
            <span class="bp">cls</span><span class="p">,</span> <span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">name2</span><span class="p">,</span> <span class="n">axis_descr</span><span class="p">,</span>
            <span class="s1">&#39;Return whether all elements are True over requested axis&#39;</span><span class="p">,</span>
            <span class="n">nanops</span><span class="o">.</span><span class="n">nanall</span><span class="p">)</span>

        <span class="nd">@Substitution</span><span class="p">(</span><span class="n">outname</span><span class="o">=</span><span class="s1">&#39;mad&#39;</span><span class="p">,</span>
                      <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Return the mean absolute deviation of the values &quot;</span>
                           <span class="s2">&quot;for the requested axis&quot;</span><span class="p">,</span>
                      <span class="n">name1</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">name2</span><span class="o">=</span><span class="n">name2</span><span class="p">,</span> <span class="n">axis_descr</span><span class="o">=</span><span class="n">axis_descr</span><span class="p">,</span>
                      <span class="n">min_count</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">examples</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="nd">@Appender</span><span class="p">(</span><span class="n">_num_doc</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">mad</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">skipna</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">skipna</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stat_axis_number</span>
            <span class="k">if</span> <span class="n">level</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_agg_by_level</span><span class="p">(</span><span class="s1">&#39;mad&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span>
                                          <span class="n">skipna</span><span class="o">=</span><span class="n">skipna</span><span class="p">)</span>

            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_numeric_data</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">demeaned</span> <span class="o">=</span> <span class="n">data</span> <span class="o">-</span> <span class="n">data</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">demeaned</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">demeaned</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="n">skipna</span><span class="p">)</span>

        <span class="bp">cls</span><span class="o">.</span><span class="n">mad</span> <span class="o">=</span> <span class="n">mad</span>

        <span class="bp">cls</span><span class="o">.</span><span class="n">sem</span> <span class="o">=</span> <span class="n">_make_stat_function_ddof</span><span class="p">(</span>
            <span class="bp">cls</span><span class="p">,</span> <span class="s1">&#39;sem&#39;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">name2</span><span class="p">,</span> <span class="n">axis_descr</span><span class="p">,</span>
            <span class="s2">&quot;Return unbiased standard error of the mean over requested &quot;</span>
            <span class="s2">&quot;axis.</span><span class="se">\n\n</span><span class="s2">Normalized by N-1 by default. This can be changed &quot;</span>
            <span class="s2">&quot;using the ddof argument&quot;</span><span class="p">,</span>
            <span class="n">nanops</span><span class="o">.</span><span class="n">nansem</span><span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">var</span> <span class="o">=</span> <span class="n">_make_stat_function_ddof</span><span class="p">(</span>
            <span class="bp">cls</span><span class="p">,</span> <span class="s1">&#39;var&#39;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">name2</span><span class="p">,</span> <span class="n">axis_descr</span><span class="p">,</span>
            <span class="s2">&quot;Return unbiased variance over requested axis.</span><span class="se">\n\n</span><span class="s2">Normalized by &quot;</span>
            <span class="s2">&quot;N-1 by default. This can be changed using the ddof argument&quot;</span><span class="p">,</span>
            <span class="n">nanops</span><span class="o">.</span><span class="n">nanvar</span><span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">std</span> <span class="o">=</span> <span class="n">_make_stat_function_ddof</span><span class="p">(</span>
            <span class="bp">cls</span><span class="p">,</span> <span class="s1">&#39;std&#39;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">name2</span><span class="p">,</span> <span class="n">axis_descr</span><span class="p">,</span>
            <span class="s2">&quot;Return sample standard deviation over requested axis.&quot;</span>
            <span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Normalized by N-1 by default. This can be changed using the &quot;</span>
            <span class="s2">&quot;ddof argument&quot;</span><span class="p">,</span>
            <span class="n">nanops</span><span class="o">.</span><span class="n">nanstd</span><span class="p">)</span>

        <span class="nd">@Substitution</span><span class="p">(</span><span class="n">outname</span><span class="o">=</span><span class="s1">&#39;compounded&#39;</span><span class="p">,</span>
                      <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Return the compound percentage of the values for &quot;</span>
                      <span class="s2">&quot;the requested axis&quot;</span><span class="p">,</span> <span class="n">name1</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">name2</span><span class="o">=</span><span class="n">name2</span><span class="p">,</span>
                      <span class="n">axis_descr</span><span class="o">=</span><span class="n">axis_descr</span><span class="p">,</span>
                      <span class="n">min_count</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">examples</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="nd">@Appender</span><span class="p">(</span><span class="n">_num_doc</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">compound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">skipna</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">skipna</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">return</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="n">skipna</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="bp">cls</span><span class="o">.</span><span class="n">compound</span> <span class="o">=</span> <span class="n">compound</span>

        <span class="bp">cls</span><span class="o">.</span><span class="n">cummin</span> <span class="o">=</span> <span class="n">_make_cum_function</span><span class="p">(</span>
            <span class="bp">cls</span><span class="p">,</span> <span class="s1">&#39;cummin&#39;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">name2</span><span class="p">,</span> <span class="n">axis_descr</span><span class="p">,</span> <span class="s2">&quot;cumulative minimum&quot;</span><span class="p">,</span>
            <span class="k">lambda</span> <span class="n">y</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="o">.</span><span class="n">accumulate</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">axis</span><span class="p">),</span> <span class="s2">&quot;min&quot;</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">cumsum</span> <span class="o">=</span> <span class="n">_make_cum_function</span><span class="p">(</span>
            <span class="bp">cls</span><span class="p">,</span> <span class="s1">&#39;cumsum&#39;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">name2</span><span class="p">,</span> <span class="n">axis_descr</span><span class="p">,</span> <span class="s2">&quot;cumulative sum&quot;</span><span class="p">,</span>
            <span class="k">lambda</span> <span class="n">y</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">y</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">axis</span><span class="p">),</span> <span class="s2">&quot;sum&quot;</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">cumprod</span> <span class="o">=</span> <span class="n">_make_cum_function</span><span class="p">(</span>
            <span class="bp">cls</span><span class="p">,</span> <span class="s1">&#39;cumprod&#39;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">name2</span><span class="p">,</span> <span class="n">axis_descr</span><span class="p">,</span> <span class="s2">&quot;cumulative product&quot;</span><span class="p">,</span>
            <span class="k">lambda</span> <span class="n">y</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">y</span><span class="o">.</span><span class="n">cumprod</span><span class="p">(</span><span class="n">axis</span><span class="p">),</span> <span class="s2">&quot;prod&quot;</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">cummax</span> <span class="o">=</span> <span class="n">_make_cum_function</span><span class="p">(</span>
            <span class="bp">cls</span><span class="p">,</span> <span class="s1">&#39;cummax&#39;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">name2</span><span class="p">,</span> <span class="n">axis_descr</span><span class="p">,</span> <span class="s2">&quot;cumulative max&quot;</span><span class="p">,</span>
            <span class="k">lambda</span> <span class="n">y</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="o">.</span><span class="n">accumulate</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">axis</span><span class="p">),</span> <span class="s2">&quot;max&quot;</span><span class="p">,</span>
            <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

        <span class="bp">cls</span><span class="o">.</span><span class="n">sum</span> <span class="o">=</span> <span class="n">_make_min_count_stat_function</span><span class="p">(</span>
            <span class="bp">cls</span><span class="p">,</span> <span class="s1">&#39;sum&#39;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">name2</span><span class="p">,</span> <span class="n">axis_descr</span><span class="p">,</span>
            <span class="s1">&#39;Return the sum of the values for the requested axis&#39;</span><span class="p">,</span>
            <span class="n">nanops</span><span class="o">.</span><span class="n">nansum</span><span class="p">,</span> <span class="n">_sum_examples</span><span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">mean</span> <span class="o">=</span> <span class="n">_make_stat_function</span><span class="p">(</span>
            <span class="bp">cls</span><span class="p">,</span> <span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">name2</span><span class="p">,</span> <span class="n">axis_descr</span><span class="p">,</span>
            <span class="s1">&#39;Return the mean of the values for the requested axis&#39;</span><span class="p">,</span>
            <span class="n">nanops</span><span class="o">.</span><span class="n">nanmean</span><span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">skew</span> <span class="o">=</span> <span class="n">_make_stat_function</span><span class="p">(</span>
            <span class="bp">cls</span><span class="p">,</span> <span class="s1">&#39;skew&#39;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">name2</span><span class="p">,</span> <span class="n">axis_descr</span><span class="p">,</span>
            <span class="s1">&#39;Return unbiased skew over requested axis</span><span class="se">\n</span><span class="s1">Normalized by N-1&#39;</span><span class="p">,</span>
            <span class="n">nanops</span><span class="o">.</span><span class="n">nanskew</span><span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">kurt</span> <span class="o">=</span> <span class="n">_make_stat_function</span><span class="p">(</span>
            <span class="bp">cls</span><span class="p">,</span> <span class="s1">&#39;kurt&#39;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">name2</span><span class="p">,</span> <span class="n">axis_descr</span><span class="p">,</span>
            <span class="s2">&quot;Return unbiased kurtosis over requested axis using Fisher&#39;s &quot;</span>
            <span class="s2">&quot;definition of</span><span class="se">\n</span><span class="s2">kurtosis (kurtosis of normal == 0.0). Normalized &quot;</span>
            <span class="s2">&quot;by N-1</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="n">nanops</span><span class="o">.</span><span class="n">nankurt</span><span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">kurtosis</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">kurt</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">prod</span> <span class="o">=</span> <span class="n">_make_min_count_stat_function</span><span class="p">(</span>
            <span class="bp">cls</span><span class="p">,</span> <span class="s1">&#39;prod&#39;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">name2</span><span class="p">,</span> <span class="n">axis_descr</span><span class="p">,</span>
            <span class="s1">&#39;Return the product of the values for the requested axis&#39;</span><span class="p">,</span>
            <span class="n">nanops</span><span class="o">.</span><span class="n">nanprod</span><span class="p">,</span> <span class="n">_prod_examples</span><span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">product</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">prod</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">median</span> <span class="o">=</span> <span class="n">_make_stat_function</span><span class="p">(</span>
            <span class="bp">cls</span><span class="p">,</span> <span class="s1">&#39;median&#39;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">name2</span><span class="p">,</span> <span class="n">axis_descr</span><span class="p">,</span>
            <span class="s1">&#39;Return the median of the values for the requested axis&#39;</span><span class="p">,</span>
            <span class="n">nanops</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">max</span> <span class="o">=</span> <span class="n">_make_stat_function</span><span class="p">(</span>
            <span class="bp">cls</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">name2</span><span class="p">,</span> <span class="n">axis_descr</span><span class="p">,</span>
            <span class="sd">&quot;&quot;&quot;This method returns the maximum of the values in the object.</span>
<span class="sd">            If you want the *index* of the maximum, use ``idxmax``. This is</span>
<span class="sd">            the equivalent of the ``numpy.ndarray`` method ``argmax``.&quot;&quot;&quot;</span><span class="p">,</span>
            <span class="n">nanops</span><span class="o">.</span><span class="n">nanmax</span><span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">min</span> <span class="o">=</span> <span class="n">_make_stat_function</span><span class="p">(</span>
            <span class="bp">cls</span><span class="p">,</span> <span class="s1">&#39;min&#39;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">name2</span><span class="p">,</span> <span class="n">axis_descr</span><span class="p">,</span>
            <span class="sd">&quot;&quot;&quot;This method returns the minimum of the values in the object.</span>
<span class="sd">            If you want the *index* of the minimum, use ``idxmin``. This is</span>
<span class="sd">            the equivalent of the ``numpy.ndarray`` method ``argmin``.&quot;&quot;&quot;</span><span class="p">,</span>
            <span class="n">nanops</span><span class="o">.</span><span class="n">nanmin</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_add_series_only_operations</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add the series only operations to the cls; evaluate the doc</span>
<span class="sd">        strings again.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">axis_descr</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">name2</span> <span class="o">=</span> <span class="n">_doc_parms</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">nanptp</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="n">nmax</span> <span class="o">=</span> <span class="n">nanops</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">skipna</span><span class="p">)</span>
            <span class="n">nmin</span> <span class="o">=</span> <span class="n">nanops</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">skipna</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">nmax</span> <span class="o">-</span> <span class="n">nmin</span>

        <span class="bp">cls</span><span class="o">.</span><span class="n">ptp</span> <span class="o">=</span> <span class="n">_make_stat_function</span><span class="p">(</span>
            <span class="bp">cls</span><span class="p">,</span> <span class="s1">&#39;ptp&#39;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">name2</span><span class="p">,</span> <span class="n">axis_descr</span><span class="p">,</span>
            <span class="sd">&quot;&quot;&quot;Returns the difference between the maximum value and the</span>
<span class="sd">            minimum value in the object. This is the equivalent of the</span>
<span class="sd">            ``numpy.ndarray`` method ``ptp``.&quot;&quot;&quot;</span><span class="p">,</span>
            <span class="n">nanptp</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_add_series_or_dataframe_operations</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add the series or dataframe only operations to the cls; evaluate</span>
<span class="sd">        the doc strings again.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="kn">from</span> <span class="nn">pandas.core</span> <span class="k">import</span> <span class="n">window</span> <span class="k">as</span> <span class="n">rwindow</span>

        <span class="nd">@Appender</span><span class="p">(</span><span class="n">rwindow</span><span class="o">.</span><span class="n">rolling</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">rolling</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">window</span><span class="p">,</span> <span class="n">min_periods</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">win_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">closed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">rwindow</span><span class="o">.</span><span class="n">rolling</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span>
                                   <span class="n">min_periods</span><span class="o">=</span><span class="n">min_periods</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">,</span>
                                   <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span> <span class="n">win_type</span><span class="o">=</span><span class="n">win_type</span><span class="p">,</span>
                                   <span class="n">on</span><span class="o">=</span><span class="n">on</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">closed</span><span class="o">=</span><span class="n">closed</span><span class="p">)</span>

        <span class="bp">cls</span><span class="o">.</span><span class="n">rolling</span> <span class="o">=</span> <span class="n">rolling</span>

        <span class="nd">@Appender</span><span class="p">(</span><span class="n">rwindow</span><span class="o">.</span><span class="n">expanding</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">expanding</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">min_periods</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">rwindow</span><span class="o">.</span><span class="n">expanding</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">min_periods</span><span class="o">=</span><span class="n">min_periods</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">,</span>
                                     <span class="n">center</span><span class="o">=</span><span class="n">center</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

        <span class="bp">cls</span><span class="o">.</span><span class="n">expanding</span> <span class="o">=</span> <span class="n">expanding</span>

        <span class="nd">@Appender</span><span class="p">(</span><span class="n">rwindow</span><span class="o">.</span><span class="n">ewm</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">ewm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">com</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">span</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">halflife</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">min_periods</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">adjust</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ignore_na</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">rwindow</span><span class="o">.</span><span class="n">ewm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">com</span><span class="o">=</span><span class="n">com</span><span class="p">,</span> <span class="n">span</span><span class="o">=</span><span class="n">span</span><span class="p">,</span> <span class="n">halflife</span><span class="o">=</span><span class="n">halflife</span><span class="p">,</span>
                               <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">min_periods</span><span class="o">=</span><span class="n">min_periods</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">,</span>
                               <span class="n">adjust</span><span class="o">=</span><span class="n">adjust</span><span class="p">,</span> <span class="n">ignore_na</span><span class="o">=</span><span class="n">ignore_na</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

        <span class="bp">cls</span><span class="o">.</span><span class="n">ewm</span> <span class="o">=</span> <span class="n">ewm</span>

        <span class="nd">@Appender</span><span class="p">(</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s1">&#39;transform&#39;</span><span class="p">]</span> <span class="o">%</span> <span class="n">_shared_doc_kwargs</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">agg</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">is_scalar</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;transforms cannot produce &quot;</span>
                                 <span class="s2">&quot;aggregated results&quot;</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">result</span>

        <span class="bp">cls</span><span class="o">.</span><span class="n">transform</span> <span class="o">=</span> <span class="n">transform</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># Misc methods</span>

    <span class="n">_shared_docs</span><span class="p">[</span><span class="s1">&#39;valid_index&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        Return index for </span><span class="si">%(position)s</span><span class="s2"> non-NA/null value.</span>

<span class="s2">        Notes</span>
<span class="s2">        --------</span>
<span class="s2">        If all elements are non-NA/null, returns None.</span>
<span class="s2">        Also returns None for empty </span><span class="si">%(klass)s</span><span class="s2">.</span>

<span class="s2">        Returns</span>
<span class="s2">        --------</span>
<span class="s2">        scalar : type of index</span>
<span class="s2">        &quot;&quot;&quot;</span>


<span class="k">def</span> <span class="nf">_doc_parms</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a tuple of the doc parms.&quot;&quot;&quot;</span>
    <span class="n">axis_descr</span> <span class="o">=</span> <span class="s2">&quot;{</span><span class="si">%s</span><span class="s2">}&quot;</span> <span class="o">%</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s2">&quot;</span><span class="si">{0}</span><span class="s2"> (</span><span class="si">{1}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
                                     <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">_AXIS_ORDERS</span><span class="p">)])</span>
    <span class="n">name</span> <span class="o">=</span> <span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">_constructor_sliced</span><span class="o">.</span><span class="vm">__name__</span>
            <span class="k">if</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_AXIS_LEN</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="s1">&#39;scalar&#39;</span><span class="p">)</span>
    <span class="n">name2</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span>
    <span class="k">return</span> <span class="n">axis_descr</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">name2</span>


<span class="n">_num_doc</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>

<span class="si">%(desc)s</span><span class="s2"></span>

<span class="s2">Parameters</span>
<span class="s2">----------</span>
<span class="s2">axis : </span><span class="si">%(axis_descr)s</span><span class="s2"></span>
<span class="s2">skipna : boolean, default True</span>
<span class="s2">    Exclude NA/null values when computing the result.</span>
<span class="s2">level : int or level name, default None</span>
<span class="s2">    If the axis is a MultiIndex (hierarchical), count along a</span>
<span class="s2">    particular level, collapsing into a </span><span class="si">%(name1)s</span><span class="s2"></span>
<span class="s2">numeric_only : boolean, default None</span>
<span class="s2">    Include only float, int, boolean columns. If None, will attempt to use</span>
<span class="s2">    everything, then use only numeric data. Not implemented for Series.</span>
<span class="si">%(min_count)s</span><span class="se">\</span>

<span class="s2">Returns</span>
<span class="s2">-------</span>
<span class="si">%(outname)s</span><span class="s2"> : </span><span class="si">%(name1)s</span><span class="s2"> or </span><span class="si">%(name2)s</span><span class="s2"> (if level specified)</span>

<span class="si">%(examples)s</span><span class="s2">&quot;&quot;&quot;</span>

<span class="n">_num_ddof_doc</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>

<span class="si">%(desc)s</span><span class="s2"></span>

<span class="s2">Parameters</span>
<span class="s2">----------</span>
<span class="s2">axis : </span><span class="si">%(axis_descr)s</span><span class="s2"></span>
<span class="s2">skipna : boolean, default True</span>
<span class="s2">    Exclude NA/null values. If an entire row/column is NA, the result</span>
<span class="s2">    will be NA</span>
<span class="s2">level : int or level name, default None</span>
<span class="s2">    If the axis is a MultiIndex (hierarchical), count along a</span>
<span class="s2">    particular level, collapsing into a </span><span class="si">%(name1)s</span><span class="s2"></span>
<span class="s2">ddof : int, default 1</span>
<span class="s2">    degrees of freedom</span>
<span class="s2">numeric_only : boolean, default None</span>
<span class="s2">    Include only float, int, boolean columns. If None, will attempt to use</span>
<span class="s2">    everything, then use only numeric data. Not implemented for Series.</span>

<span class="s2">Returns</span>
<span class="s2">-------</span>
<span class="si">%(outname)s</span><span class="s2"> : </span><span class="si">%(name1)s</span><span class="s2"> or </span><span class="si">%(name2)s</span><span class="s2"> (if level specified)</span><span class="se">\n</span><span class="s2">&quot;&quot;&quot;</span>

<span class="n">_bool_doc</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>

<span class="si">%(desc)s</span><span class="s2"></span>

<span class="s2">Parameters</span>
<span class="s2">----------</span>
<span class="s2">axis : </span><span class="si">%(axis_descr)s</span><span class="s2"></span>
<span class="s2">skipna : boolean, default True</span>
<span class="s2">    Exclude NA/null values. If an entire row/column is NA, the result</span>
<span class="s2">    will be NA</span>
<span class="s2">level : int or level name, default None</span>
<span class="s2">    If the axis is a MultiIndex (hierarchical), count along a</span>
<span class="s2">    particular level, collapsing into a </span><span class="si">%(name1)s</span><span class="s2"></span>
<span class="s2">bool_only : boolean, default None</span>
<span class="s2">    Include only boolean columns. If None, will attempt to use everything,</span>
<span class="s2">    then use only boolean data. Not implemented for Series.</span>

<span class="s2">Returns</span>
<span class="s2">-------</span>
<span class="si">%(outname)s</span><span class="s2"> : </span><span class="si">%(name1)s</span><span class="s2"> or </span><span class="si">%(name2)s</span><span class="s2"> (if level specified)</span><span class="se">\n</span><span class="s2">&quot;&quot;&quot;</span>

<span class="n">_cnum_doc</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>

<span class="s2">Parameters</span>
<span class="s2">----------</span>
<span class="s2">axis : </span><span class="si">%(axis_descr)s</span><span class="s2"></span>
<span class="s2">skipna : boolean, default True</span>
<span class="s2">    Exclude NA/null values. If an entire row/column is NA, the result</span>
<span class="s2">    will be NA</span>

<span class="s2">Returns</span>
<span class="s2">-------</span>
<span class="si">%(outname)s</span><span class="s2"> : </span><span class="si">%(name1)s</span><span class="se">\n</span><span class="s2"></span>


<span class="s2">See also</span>
<span class="s2">--------</span>
<span class="s2">pandas.core.window.Expanding.</span><span class="si">%(accum_func_name)s</span><span class="s2"> : Similar functionality</span>
<span class="s2">    but ignores ``NaN`` values.</span>

<span class="s2">&quot;&quot;&quot;</span>


<span class="n">_sum_examples</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">Examples</span>
<span class="s2">--------</span>
<span class="s2">By default, the sum of an empty or all-NA Series is ``0``.</span>

<span class="s2">&gt;&gt;&gt; pd.Series([]).sum()  # min_count=0 is the default</span>
<span class="s2">0.0</span>

<span class="s2">This can be controlled with the ``min_count`` parameter. For example, if</span>
<span class="s2">you&#39;d like the sum of an empty series to be NaN, pass ``min_count=1``.</span>

<span class="s2">&gt;&gt;&gt; pd.Series([]).sum(min_count=1)</span>
<span class="s2">nan</span>

<span class="s2">Thanks to the ``skipna`` parameter, ``min_count`` handles all-NA and</span>
<span class="s2">empty series identically.</span>

<span class="s2">&gt;&gt;&gt; pd.Series([np.nan]).sum()</span>
<span class="s2">0.0</span>

<span class="s2">&gt;&gt;&gt; pd.Series([np.nan]).sum(min_count=1)</span>
<span class="s2">nan</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="n">_prod_examples</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">Examples</span>
<span class="s2">--------</span>
<span class="s2">By default, the product of an empty or all-NA Series is ``1``</span>

<span class="s2">&gt;&gt;&gt; pd.Series([]).prod()</span>
<span class="s2">1.0</span>

<span class="s2">This can be controlled with the ``min_count`` parameter</span>

<span class="s2">&gt;&gt;&gt; pd.Series([]).prod(min_count=1)</span>
<span class="s2">nan</span>

<span class="s2">Thanks to the ``skipna`` parameter, ``min_count`` handles all-NA and</span>
<span class="s2">empty series identically.</span>

<span class="s2">&gt;&gt;&gt; pd.Series([np.nan]).prod()</span>
<span class="s2">1.0</span>

<span class="s2">&gt;&gt;&gt; pd.Series([np.nan]).sum(min_count=1)</span>
<span class="s2">nan</span>
<span class="s2">&quot;&quot;&quot;</span>


<span class="n">_min_count_stub</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">min_count : int, default 0</span>
<span class="s2">    The required number of valid values to perform the operation. If fewer than</span>
<span class="s2">    ``min_count`` non-NA values are present the result will be NA.</span>

<span class="s2">    .. versionadded :: 0.22.0</span>

<span class="s2">       Added with the default being 1. This means the sum or product</span>
<span class="s2">       of an all-NA or empty series is ``NaN``.</span>
<span class="s2">&quot;&quot;&quot;</span>


<span class="k">def</span> <span class="nf">_make_min_count_stat_function</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">name1</span><span class="p">,</span> <span class="n">name2</span><span class="p">,</span> <span class="n">axis_descr</span><span class="p">,</span> <span class="n">desc</span><span class="p">,</span>
                                  <span class="n">f</span><span class="p">,</span> <span class="n">examples</span><span class="p">):</span>
    <span class="nd">@Substitution</span><span class="p">(</span><span class="n">outname</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="n">desc</span><span class="p">,</span> <span class="n">name1</span><span class="o">=</span><span class="n">name1</span><span class="p">,</span> <span class="n">name2</span><span class="o">=</span><span class="n">name2</span><span class="p">,</span>
                  <span class="n">axis_descr</span><span class="o">=</span><span class="n">axis_descr</span><span class="p">,</span> <span class="n">min_count</span><span class="o">=</span><span class="n">_min_count_stub</span><span class="p">,</span>
                  <span class="n">examples</span><span class="o">=</span><span class="n">examples</span><span class="p">)</span>
    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_num_doc</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">stat_func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">numeric_only</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                  <span class="n">min_count</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                  <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">nv</span><span class="o">.</span><span class="n">validate_stat_func</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(),</span> <span class="n">kwargs</span><span class="p">,</span> <span class="n">fname</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">skipna</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">skipna</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stat_axis_number</span>
        <span class="k">if</span> <span class="n">level</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_agg_by_level</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span>
                                      <span class="n">skipna</span><span class="o">=</span><span class="n">skipna</span><span class="p">,</span> <span class="n">min_count</span><span class="o">=</span><span class="n">min_count</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reduce</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="n">skipna</span><span class="p">,</span>
                            <span class="n">numeric_only</span><span class="o">=</span><span class="n">numeric_only</span><span class="p">,</span> <span class="n">min_count</span><span class="o">=</span><span class="n">min_count</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">set_function_name</span><span class="p">(</span><span class="n">stat_func</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_make_stat_function</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">name1</span><span class="p">,</span> <span class="n">name2</span><span class="p">,</span> <span class="n">axis_descr</span><span class="p">,</span> <span class="n">desc</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
    <span class="nd">@Substitution</span><span class="p">(</span><span class="n">outname</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="n">desc</span><span class="p">,</span> <span class="n">name1</span><span class="o">=</span><span class="n">name1</span><span class="p">,</span> <span class="n">name2</span><span class="o">=</span><span class="n">name2</span><span class="p">,</span>
                  <span class="n">axis_descr</span><span class="o">=</span><span class="n">axis_descr</span><span class="p">,</span> <span class="n">min_count</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">examples</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_num_doc</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">stat_func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">numeric_only</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                  <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">nv</span><span class="o">.</span><span class="n">validate_stat_func</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(),</span> <span class="n">kwargs</span><span class="p">,</span> <span class="n">fname</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">skipna</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">skipna</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stat_axis_number</span>
        <span class="k">if</span> <span class="n">level</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_agg_by_level</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span>
                                      <span class="n">skipna</span><span class="o">=</span><span class="n">skipna</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reduce</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="n">skipna</span><span class="p">,</span>
                            <span class="n">numeric_only</span><span class="o">=</span><span class="n">numeric_only</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">set_function_name</span><span class="p">(</span><span class="n">stat_func</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_make_stat_function_ddof</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">name1</span><span class="p">,</span> <span class="n">name2</span><span class="p">,</span> <span class="n">axis_descr</span><span class="p">,</span> <span class="n">desc</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
    <span class="nd">@Substitution</span><span class="p">(</span><span class="n">outname</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="n">desc</span><span class="p">,</span> <span class="n">name1</span><span class="o">=</span><span class="n">name1</span><span class="p">,</span> <span class="n">name2</span><span class="o">=</span><span class="n">name2</span><span class="p">,</span>
                  <span class="n">axis_descr</span><span class="o">=</span><span class="n">axis_descr</span><span class="p">)</span>
    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_num_ddof_doc</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">stat_func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                  <span class="n">numeric_only</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">nv</span><span class="o">.</span><span class="n">validate_stat_ddof_func</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(),</span> <span class="n">kwargs</span><span class="p">,</span> <span class="n">fname</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">skipna</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">skipna</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stat_axis_number</span>
        <span class="k">if</span> <span class="n">level</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_agg_by_level</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span>
                                      <span class="n">skipna</span><span class="o">=</span><span class="n">skipna</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="n">ddof</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reduce</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">numeric_only</span><span class="o">=</span><span class="n">numeric_only</span><span class="p">,</span>
                            <span class="n">skipna</span><span class="o">=</span><span class="n">skipna</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="n">ddof</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">set_function_name</span><span class="p">(</span><span class="n">stat_func</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_make_cum_function</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">name1</span><span class="p">,</span> <span class="n">name2</span><span class="p">,</span> <span class="n">axis_descr</span><span class="p">,</span> <span class="n">desc</span><span class="p">,</span>
                       <span class="n">accum_func</span><span class="p">,</span> <span class="n">accum_func_name</span><span class="p">,</span> <span class="n">mask_a</span><span class="p">,</span> <span class="n">mask_b</span><span class="p">):</span>
    <span class="nd">@Substitution</span><span class="p">(</span><span class="n">outname</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="n">desc</span><span class="p">,</span> <span class="n">name1</span><span class="o">=</span><span class="n">name1</span><span class="p">,</span> <span class="n">name2</span><span class="o">=</span><span class="n">name2</span><span class="p">,</span>
                  <span class="n">axis_descr</span><span class="o">=</span><span class="n">axis_descr</span><span class="p">,</span> <span class="n">accum_func_name</span><span class="o">=</span><span class="n">accum_func_name</span><span class="p">)</span>
    <span class="nd">@Appender</span><span class="p">(</span><span class="s2">&quot;Return </span><span class="si">{0}</span><span class="s2"> over requested axis.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span> <span class="o">+</span>
              <span class="n">_cnum_doc</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">cum_func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">skipna</span> <span class="o">=</span> <span class="n">nv</span><span class="o">.</span><span class="n">validate_cum_func_with_skipna</span><span class="p">(</span><span class="n">skipna</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stat_axis_number</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

        <span class="n">y</span> <span class="o">=</span> <span class="n">_values_from_object</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">skipna</span> <span class="ow">and</span>
                <span class="nb">issubclass</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">timedelta64</span><span class="p">))):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">accum_func</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">isna</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">putmask</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">tslib</span><span class="o">.</span><span class="n">iNaT</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">skipna</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">)):</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">isna</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">putmask</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">mask_a</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">accum_func</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">putmask</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">mask_b</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">accum_func</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_construct_axes_dict</span><span class="p">()</span>
        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;copy&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="o">**</span><span class="n">d</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">set_function_name</span><span class="p">(</span><span class="n">cum_func</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_make_logical_function</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">name1</span><span class="p">,</span> <span class="n">name2</span><span class="p">,</span> <span class="n">axis_descr</span><span class="p">,</span> <span class="n">desc</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
    <span class="nd">@Substitution</span><span class="p">(</span><span class="n">outname</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="n">desc</span><span class="p">,</span> <span class="n">name1</span><span class="o">=</span><span class="n">name1</span><span class="p">,</span> <span class="n">name2</span><span class="o">=</span><span class="n">name2</span><span class="p">,</span>
                  <span class="n">axis_descr</span><span class="o">=</span><span class="n">axis_descr</span><span class="p">)</span>
    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_bool_doc</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">logical_func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bool_only</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">nv</span><span class="o">.</span><span class="n">validate_logical_func</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(),</span> <span class="n">kwargs</span><span class="p">,</span> <span class="n">fname</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">skipna</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">skipna</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stat_axis_number</span>
        <span class="k">if</span> <span class="n">level</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">bool_only</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Option bool_only is not &quot;</span>
                                          <span class="s2">&quot;implemented with option level.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_agg_by_level</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span>
                                      <span class="n">skipna</span><span class="o">=</span><span class="n">skipna</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reduce</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="n">skipna</span><span class="p">,</span>
                            <span class="n">numeric_only</span><span class="o">=</span><span class="n">bool_only</span><span class="p">,</span> <span class="n">filter_type</span><span class="o">=</span><span class="s1">&#39;bool&#39;</span><span class="p">,</span>
                            <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">set_function_name</span><span class="p">(</span><span class="n">logical_func</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span>


<span class="c1"># install the indexes</span>
<span class="k">for</span> <span class="n">_name</span><span class="p">,</span> <span class="n">_indexer</span> <span class="ow">in</span> <span class="n">indexing</span><span class="o">.</span><span class="n">get_indexers_list</span><span class="p">():</span>
    <span class="n">NDFrame</span><span class="o">.</span><span class="n">_create_indexer</span><span class="p">(</span><span class="n">_name</span><span class="p">,</span> <span class="n">_indexer</span><span class="p">)</span>
</pre></div>

          </div>
        </div>
          </div>
        </div>
      </div>
    </div>

    <div class="container container-navbar-bottom">
      <div class="spc-navbar">
        
      </div>
    </div>
    <div class="container">
    <div class="footer">
    <div class="row-fluid">
    <ul class="inline pull-left">
      <li>
        &copy; Copyright 2018 - PySAT Developers.
      </li>
      <li>
      Last updated on Apr 20, 2018.
      </li>
      <li>
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.7.2.
      </li>
    </ul>
    </div>
    </div>
    </div>
  </body>
</html>