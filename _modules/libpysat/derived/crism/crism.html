<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8">
    
    <title>libpysat.derived.crism.crism &mdash; PySAT</title>
    
    <link rel="stylesheet" type="text/css" href="../../../../_static/css/spc-bootstrap.css">
    <link rel="stylesheet" type="text/css" href="../../../../_static/css/spc-extend.css">
    <link rel="stylesheet" href="../../../../_static/scipy.css" type="text/css" >
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" >
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../../',
        VERSION:     '0.1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../../../../_static/js/copybutton.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" >
    <link rel="search" title="Search" href="../../../../search.html" >
    <link rel="top" title="PySAT" href="../../../../index.html" >
    <link rel="up" title="Module code" href="../../../index.html" > 
  </head>
  <body>

  <div class="container">
    <div class="header">
    </div>
  </div>


    <div class="container">
      <div class="main">
        
	<div class="row-fluid">
	  <div class="span12">
	    <div class="spc-navbar">
              
    <ul class="nav nav-pills pull-left">
	
        <li class="active"><a href="../../../../index.html">PySAT</a></li>
	
          <li class="active"><a href="../../../index.html" accesskey="U">Module code</a></li> 
    </ul>
              
              
    <ul class="nav nav-pills pull-right">
      <li class="active">
        <a href="../../../../genindex.html" title="General Index"
           accesskey="I">index</a>
      </li>
      <li class="active">
        <a href="../../../../py-modindex.html" title="Python Module Index"
           >modules</a>
      </li>
    </ul>
              
	    </div>
	  </div>
	</div>
        

	<div class="row-fluid">
      <div class="spc-rightsidebar span3">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../../index.html">
              <img class="logo" src="../../../../_static/favicon.png" alt="Logo">
            </a></p>

        </div>
      </div>
          <div class="span9">
            
        <div class="bodywrapper">
          <div class="body" id="spc-section-body">
            
  <h1>Source code for libpysat.derived.crism.crism</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">crism_funcs</span> <span class="k">as</span> <span class="n">cf</span>
<span class="kn">from</span> <span class="nn">..utils</span> <span class="k">import</span> <span class="n">generic_func</span>


<div class="viewcode-block" id="r770"><a class="viewcode-back" href="../../../../library/derived/crism/cat.html#libpysat.derived.crism.crism.r770">[docs]</a><span class="k">def</span> <span class="nf">r770</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Name: R770</span>
<span class="sd">    Parameter: 0.77micron reflectance</span>
<span class="sd">    Formulation: R770</span>
<span class="sd">    Kernel Width:</span>
<span class="sd">      - R770: 5</span>
<span class="sd">    Rationale: Higher value more dusty or icy</span>
<span class="sd">    Caveats: Sensitive to slope effects, clouds</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : ndarray</span>
<span class="sd">           (n,m,p) array</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">     : ndarray</span>
<span class="sd">       the processed ndarray</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">wv</span> <span class="o">=</span> <span class="p">[</span><span class="mi">770</span><span class="p">]</span>
    <span class="n">kernels</span> <span class="o">=</span> <span class="p">{</span><span class="mi">770</span><span class="p">:</span><span class="mi">5</span><span class="p">}</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">generic_func</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">wv</span><span class="p">,</span> <span class="n">kernels</span><span class="o">=</span><span class="n">kernels</span><span class="p">,</span> <span class="n">func</span> <span class="o">=</span> <span class="n">cf</span><span class="o">.</span><span class="n">rockdust1_func</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">res</span></div>

<div class="viewcode-block" id="rbr"><a class="viewcode-back" href="../../../../library/derived/crism/cat.html#libpysat.derived.crism.crism.rbr">[docs]</a><span class="k">def</span> <span class="nf">rbr</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Name: RBR</span>
<span class="sd">    Parameter: Red/Blue Ratio</span>
<span class="sd">    Formulation: R770 / R440</span>
<span class="sd">    Kernel Width:</span>
<span class="sd">      - R440: 5</span>
<span class="sd">      - R770: 5</span>
<span class="sd">    Rationale: Higher value indicates more npFeOx</span>
<span class="sd">    Caveats: Sensitive to dust in atmosphere</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : ndarray</span>
<span class="sd">           (n,m,p) array</span>
<span class="sd">    wv_array : ndarray</span>
<span class="sd">               (n,1) array of wavelengths that correspond to the p</span>
<span class="sd">               dimension of the data array</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">     : ndarray</span>
<span class="sd">       the processed ndarray</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">wv</span> <span class="o">=</span> <span class="p">[</span><span class="mi">440</span><span class="p">,</span> <span class="mi">770</span><span class="p">]</span>
    <span class="n">kernels</span> <span class="o">=</span> <span class="p">{</span><span class="mi">440</span><span class="p">:</span><span class="mi">5</span><span class="p">,</span>
               <span class="mi">770</span><span class="p">:</span><span class="mi">5</span><span class="p">}</span>
    <span class="k">return</span><span class="p">(</span><span class="n">generic_func</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">wv</span><span class="p">,</span> <span class="n">kernels</span><span class="o">=</span><span class="n">kernels</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="n">cf</span><span class="o">.</span><span class="n">rockdust2_func</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span></div>

<span class="sd">&#39;&#39;&#39;def bd530(data, **kwargs):</span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    NAME: BD530</span>
<span class="sd">    PARAMETER: 0.53 micron band depth</span>
<span class="sd">    FORMULATION *: 1 - (R530/(a*R709+b*R440))</span>
<span class="sd">    RATIONALE: Crystalline ferric minerals</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : ndarray</span>
<span class="sd">           (n,m,p) array</span>
<span class="sd">    wv_array : ndarray</span>
<span class="sd">               (n,1) array of wavelengths that correspond to the p</span>
<span class="sd">               dimension of the data array</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">     : ndarray</span>
<span class="sd">       the processed ndarray</span>

<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    wv = [440,530,709]</span>
<span class="sd">    return(generic_func(data, wv, func = cf.bd530_func, **kwargs))</span>

<span class="sd">def sh600(data, **kwargs):</span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    NAME: SH600</span>
<span class="sd">    PARAMETER: 0.60 micron shoulder height</span>
<span class="sd">    FORMULATION *: R600/(a*R530+b*R709)</span>
<span class="sd">    RATIONALE: select ferric minerals</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : ndarray</span>
<span class="sd">           (n,m,p) array</span>
<span class="sd">    wv_array : ndarray</span>
<span class="sd">               (n,1) array of wavelengths that correspond to the p</span>
<span class="sd">               dimension of the data array</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">     : ndarray</span>
<span class="sd">       the processed ndarray</span>

<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    wv = [533,600,710]</span>
<span class="sd">    return(generic_func(data, wv, func=cf.sh600_func, **kwargs))</span>


<span class="sd">def bd640(data, **kwargs):</span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    NAME: BD640</span>
<span class="sd">    PARAMETER: 0.64 micron band depth</span>
<span class="sd">    FORMULATION *: 1 - (R648/(a*R600+b*R709))</span>
<span class="sd">    RATIONALE: select ferric minerals, especially maghemite</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : ndarray</span>
<span class="sd">           (n,m,p) array</span>
<span class="sd">    wv_array : ndarray</span>
<span class="sd">               (n,1) array of wavelengths that correspond to the p</span>
<span class="sd">               dimension of the data array</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">     : ndarray</span>
<span class="sd">       the processed ndarray</span>

<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    wv = [600,648,709]</span>
<span class="sd">    return(generic_func(data, wv, func = cf.bd640_func, **kwargs))</span>

<span class="sd">def bd860(data, **kwargs):</span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    NAME: BD860</span>
<span class="sd">    PARAMETER: 0.86 micron band depth</span>
<span class="sd">    FORMULATION *: 1 - (R860/(a*R800+b*R984))</span>
<span class="sd">    RATIONALE: select ferric minerals (&#39;hematite band&#39;)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : ndarray</span>
<span class="sd">           (n,m,p) array</span>
<span class="sd">    wv_array : ndarray</span>
<span class="sd">               (n,1) array of wavelengths that correspond to the p</span>
<span class="sd">               dimension of the data array</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">     : ndarray</span>
<span class="sd">       the processed ndarray</span>

<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    wv = [800,860,984]</span>
<span class="sd">    return(generic_func(data, wv, func = cf.bd860_func, **kwargs))</span>

<span class="sd">def bd920(data, **kwargs):</span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    NAME: BD920</span>
<span class="sd">    PARAMETER: 0.92 micron band depth</span>
<span class="sd">    FORMULATION *: 1 - ( R920 / (a*R800+b*R984) )</span>
<span class="sd">    RATIONALE: select ferric minerals (&#39;Pseudo BDI1000 VIS&#39;)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : ndarray</span>
<span class="sd">           (n,m,p) array</span>
<span class="sd">    wv_array : ndarray</span>
<span class="sd">               (n,1) array of wavelengths that correspond to the p</span>
<span class="sd">               dimension of the data array</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">     : ndarray</span>
<span class="sd">       the processed ndarray</span>

<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    wv = [800,920,984]</span>
<span class="sd">    return(generic_func(data, wv, func = cf.bd920_func, **kwargs))</span>


<span class="sd">#@@TODO rpeak1</span>
<span class="sd">def rpeak1(data, **kwargs):</span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    NAME: BDI1000VIS</span>
<span class="sd">    PARAMETER: 1 micron integrated band depth; VIS wavelengths</span>
<span class="sd">    FORMULATION *: divide R830, R860, R890, R915 by RPEAK1 then</span>
<span class="sd">      integrate over (1 -  normalized radiances)</span>
<span class="sd">    RATIONALE: crystalline Fe+2 or Fe+3 minerals</span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    raise NotImplementedError</span>

<span class="sd">#@@TODO bdi1000VIS</span>
<span class="sd">def bdi1000VIS(data, **kwargs):</span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    NAME: BDI1000VIS</span>
<span class="sd">    PARAMETER: 1 micron integrated band depth; VIS wavelengths</span>
<span class="sd">    FORMULATION *: divide R830, R860, R890, R915 by RPEAK1 then</span>
<span class="sd">      integrate over (1 -  normalized radiances)</span>
<span class="sd">    RATIONALE: crystalline Fe+2 or Fe+3 minerals</span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    raise NotImplementedError</span>

<span class="sd">#@@TODO bdi1000IR</span>
<span class="sd">def bdi1000IR(data, **kwargs):</span>
<span class="sd">   &quot;&quot;&quot;</span>
<span class="sd">   NAME: BDI1000IR</span>
<span class="sd">     PARAMETER: 1 micron integrated band depth; IR wavelengths</span>
<span class="sd">     FORMULATION *: divide R1030, R1050, R1080, R1150</span>
<span class="sd">       by linear fit from peak R  between 1.3 - 1.87 microns to R2530</span>
<span class="sd">       extrapolated backwards, then integrate over (1 -  normalized</span>
<span class="sd">       radiances)</span>
<span class="sd">     RATIONALE: crystalline Fe+2 minerals; corrected for overlying</span>
<span class="sd">       aerosol induced slope</span>
<span class="sd">   &quot;&quot;&quot;</span>
<span class="sd">   raise NotImplementedError</span>

<span class="sd">def ira(data, **kwargs):</span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    NAME: IRA</span>
<span class="sd">    PARAMETER: 1.3 micron reflectance</span>
<span class="sd">    FORMULATION *: R1330</span>
<span class="sd">    RATIONALE: IR albedo</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : ndarray</span>
<span class="sd">           (n,m,p) array</span>
<span class="sd">    wv_array : ndarray</span>
<span class="sd">               (n,1) array of wavelengths that correspond to the p</span>
<span class="sd">               dimension of the data array</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">     : ndarray</span>
<span class="sd">       the processed ndarray</span>

<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    wv = [1330]</span>
<span class="sd">    return(generic_func(data, wv, func = cf.ira_func, **kwargs))</span>

<span class="sd">def olivine_index(data, **kwargs):</span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    NAME: OLINDEX (prior to TRDR version 3)</span>
<span class="sd">    PARAMETER: olivine index</span>
<span class="sd">    FORMULATION *: (R1695 / (0.1*R1080 + 0.1*R1210 + 0.4*R1330 +</span>
<span class="sd">      0.4*R1470)) - 1</span>
<span class="sd">    RATIONALE: olivine will be strongly +; based on fayalite</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : ndarray</span>
<span class="sd">           (n,m,p) array</span>
<span class="sd">    wv_array : ndarray</span>
<span class="sd">               (n,1) array of wavelengths that correspond to the p</span>
<span class="sd">               dimension of the data array</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">     : ndarray</span>
<span class="sd">       the processed ndarray</span>

<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    wv = [1080,1210,1330,1470,1695]</span>
<span class="sd">    return(generic_func(data, wv, func = cf.olivine_index_func, **kwargs))</span>

<span class="sd">#@@TODO olivine_index2 (labeled olivine_index3 in JPL doc?</span>
<span class="sd">def olivine_index2(data, **kwargs):</span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    NAME: OLINDEX2 (beginning with TRDR version 3)</span>
<span class="sd">    PARAMETER: olivine index with less sensitivity to illumination</span>
<span class="sd">    FORMULATION *: (((RC1054 ? R1054)/RC1054) * 0.1)</span>
<span class="sd">      + (((RC1211 ? R1211)/(RC1211) * 0.1)</span>
<span class="sd">      + (((RC1329 ? R1329)/RC1329) * 0.4)</span>
<span class="sd">      + (((RC1474 ? R1474)/RC1474) * 0.4)</span>
<span class="sd">    RATIONALE: olivine will be strongly positive</span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    raise NotImplementedError</span>


<span class="sd">def hcp_index(data, **kwargs):</span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    NAME: HCPXINDEX</span>
<span class="sd">    PARAMETER: pyroxene index</span>
<span class="sd">    FORMULATION *: 100 * ((R1470 - R1080)/(R1470 + R1080)) *</span>
<span class="sd">                          ((R1470 - R2067)/(R1470+R2067))</span>
<span class="sd">    RATIONALE: pyroxene is strongly +; favors high-Ca pyroxene</span>
<span class="sd">    Algorithm differs from published - coded as per CAT</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : ndarray</span>
<span class="sd">           (n,m,p) array</span>
<span class="sd">    wv_array : ndarray</span>
<span class="sd">               (n,1) array of wavelengths that correspond to the p</span>
<span class="sd">               dimension of the data array</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">     : ndarray</span>
<span class="sd">       the processed ndarray</span>

<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    wv = [1080,1470,2067]</span>
<span class="sd">    return(generic_func(data, wv, func = cf.hcp_index_func, **kwargs))</span>


<span class="sd">def lcp_index(data, **kwargs):</span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">     NAME: LCPINDEX</span>
<span class="sd">    PARAMETER: pyroxene index</span>
<span class="sd">    FORMULATION *: 100 * ((R1330 - R1080)/(R1330 + R1080)) *</span>
<span class="sd">                          ((R1330 - R1815)/(R1330+R1815))</span>
<span class="sd">    RATIONALE: pyroxene is strongly +; favors low-Ca pyroxene</span>
<span class="sd">    Algorithm differs from published - coded as per CAT</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : ndarray</span>
<span class="sd">           (n,m,p) array</span>
<span class="sd">    wv_array : ndarray</span>
<span class="sd">               (n,1) array of wavelengths that correspond to the p</span>
<span class="sd">               dimension of the data array</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">     : ndarray</span>
<span class="sd">       the processed ndarray</span>

<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    wv = [1080,1330,1815]</span>
<span class="sd">    return(generic_func(data, wv, func = cf.lcp_index_func, **kwargs))</span>


<span class="sd">#@@TODO var</span>
<span class="sd">def var(data, **kwargs):</span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    NAME: VAR</span>
<span class="sd">    PARAMETER: spectral variance</span>
<span class="sd">    FORMULATION *: find variance from a line fit from 1 - 2.3 micron</span>
<span class="sd">      by summing in quadrature over the intervening wavelengths</span>
<span class="sd">    RATIONALE: Ol &amp; Px will have high values; Type 2 areas will have</span>
<span class="sd">      low values</span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    raise NotImplementedError</span>

<span class="sd">def islope1(data, **kwargs):</span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    NAME: ISLOPE1</span>
<span class="sd">    PARAMETER: -1 * spectral slope1</span>
<span class="sd">    FORMULATION *: (R1815-R2530) / (2530-1815)</span>
<span class="sd">    RATIONALE: ferric coating on dark rock</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : ndarray</span>
<span class="sd">           (n,m,p) array</span>
<span class="sd">    wv_array : ndarray</span>
<span class="sd">               (n,1) array of wavelengths that correspond to the p</span>
<span class="sd">               dimension of the data array</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">     : ndarray</span>
<span class="sd">       the processed ndarray</span>

<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    wv = [1815,2530]</span>
<span class="sd">    return(generic_func(data, wv, func = cf.islope1_func, **kwargs))</span>

<span class="sd">def bd1435(data, **kwargs):</span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    NAME: BD1435</span>
<span class="sd">    PARAMETER: 1.435 micron band depth</span>
<span class="sd">    FORMULATION *: 1 - ( R1430 / (a*R1370+b*R1470) )</span>
<span class="sd">    RATIONALE: CO2 surface ice</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : ndarray</span>
<span class="sd">           (n,m,p) array</span>
<span class="sd">    wv_array : ndarray</span>
<span class="sd">               (n,1) array of wavelengths that correspond to the p</span>
<span class="sd">               dimension of the data array</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">     : ndarray</span>
<span class="sd">       the processed ndarray</span>

<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    wv = [1370,1430,1470]</span>
<span class="sd">    return(generic_func(data, wv, func = cf.bd1435_func, **kwargs))</span>


<span class="sd">def bd1500(data, **kwargs):</span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    NAME: BD1500</span>
<span class="sd">    PARAMETER: 1.5 micron band depth</span>
<span class="sd">    FORMULATION *: 1.0 - ((R1558 + R1505)/(R1808 + R1367))</span>
<span class="sd">    RATIONALE: H2O surface ice</span>
<span class="sd">    Algorithm differs from published - coded as per CAT (reduced instrument noise)    </span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : ndarray</span>
<span class="sd">           (n,m,p) array</span>
<span class="sd">    wv_array : ndarray</span>
<span class="sd">               (n,1) array of wavelengths that correspond to the p</span>
<span class="sd">               dimension of the data array</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">     : ndarray</span>
<span class="sd">       the processed ndarray</span>

<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    wv = [1367,1505,1558,1808]</span>
<span class="sd">    return(generic_func(data, wv, func = cf.bd1500_func, **kwargs))</span>


<span class="sd">def icer1(data, **kwargs):</span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    NAME: ICER1</span>
<span class="sd">    PARAMETER: 1.5 micron and 1.43 micron band ratio</span>
<span class="sd">    FORMULATION *: R1510 / R1430</span>
<span class="sd">    RATIONALE: CO2, H20 ice mixtures</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : ndarray</span>
<span class="sd">           (n,m,p) array</span>
<span class="sd">    wv_array : ndarray</span>
<span class="sd">               (n,1) array of wavelengths that correspond to the p</span>
<span class="sd">               dimension of the data array</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">     : ndarray</span>
<span class="sd">       the processed ndarray</span>

<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    wv = [1430,1510]</span>
<span class="sd">    return(generic_func(data, wv, func = cf.icer1_func, **kwargs))</span>


<span class="sd">def bd1750(data, **kwargs):</span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    NAME: BD1750</span>
<span class="sd">    PARAMETER: 1.75 micron band depth</span>
<span class="sd">    FORMULATION *: 1 - ( R1750 / (a*R1660+b*R1815) )</span>
<span class="sd">    RATIONALE: gypsum</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : ndarray</span>
<span class="sd">           (n,m,p) array</span>
<span class="sd">    wv_array : ndarray</span>
<span class="sd">               (n,1) array of wavelengths that correspond to the p</span>
<span class="sd">               dimension of the data array</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">     : ndarray</span>
<span class="sd">       the processed ndarray</span>

<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    wv = [1557,1750,1815]</span>
<span class="sd">    return(generic_func(data, wv, func = cf.bd1750_func, **kwargs))</span>


<span class="sd">def bd1900(data, **kwargs):</span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    NAME: BD1900</span>
<span class="sd">    PARAMETER: 1.9 micron band depth</span>
<span class="sd">    FORMULATION *: 1.0 - ((R1972 + R1927)/(R2006 + R1874))</span>
<span class="sd">    RATIONALE: H2O, chemically bound or adsorbed</span>
<span class="sd">    Algorithm differs from published - coded as per CAT (reduced instrument noise)    </span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : ndarray</span>
<span class="sd">           (n,m,p) array</span>
<span class="sd">    wv_array : ndarray</span>
<span class="sd">               (n,1) array of wavelengths that correspond to the p</span>
<span class="sd">               dimension of the data array</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">     : ndarray</span>
<span class="sd">       the processed ndarray</span>

<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    wv = [1874,1927,1973,2006]</span>
<span class="sd">    return(generic_func(data, wv, func = cf.bd1900_func, **kwargs))</span>

<span class="sd">#@@TODO bdi2000</span>
<span class="sd">def bdi2000(data, **kwargs):</span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    NAME: BDI2000</span>
<span class="sd">    PARAMETER: 2 micron integrated band depth</span>
<span class="sd">    FORMULATION *: divide R1660, R1815, R2140, R2210, R2250, R2290,</span>
<span class="sd">      R2330, R2350, R2390, R2430, R2460 by linear fit from peak R</span>
<span class="sd">      between 1.3 - 1.87 microns to R2530, then integrate over</span>
<span class="sd">     (1 -  normalized radiances)</span>
<span class="sd">    RATIONALE: pyroxene abundance and particle size</span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    raise NotImplementedError</span>


<span class="sd">def bd2100(data, **kwargs):</span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    NAME: BD2100</span>
<span class="sd">    PARAMETER: 2.1 micron band depth</span>
<span class="sd">    FORMULATION *: 1 - ( ((R2120+R2140)*0.5) / (a*R1930+b*R2250) )</span>
<span class="sd">    RATIONALE: monohydrated minerals</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : ndarray</span>
<span class="sd">           (n,m,p) array</span>
<span class="sd">    wv_array : ndarray</span>
<span class="sd">               (n,1) array of wavelengths that correspond to the p</span>
<span class="sd">               dimension of the data array</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">     : ndarray</span>
<span class="sd">       the processed ndarray</span>

<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    wv = [1930,2120,2140,2250]</span>
<span class="sd">    return(generic_func(data, wv, func = cf.bd2100_func, **kwargs))</span>


<span class="sd">def bd2210(data, **kwargs):</span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    NAME: BD2210</span>
<span class="sd">    PARAMETER: 2.21 micron band depth</span>
<span class="sd">    FORMULATION *: 1 - ( R2210 / (a*R2140+b*R2250) )</span>
<span class="sd">    RATIONALE: Al-OH minerals: monohydrated minerals</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : ndarray</span>
<span class="sd">           (n,m,p) array</span>
<span class="sd">    wv_array : ndarray</span>
<span class="sd">               (n,1) array of wavelengths that correspond to the p</span>
<span class="sd">               dimension of the data array</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">     : ndarray</span>
<span class="sd">       the processed ndarray</span>

<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    wv = [2140,2210,2250]</span>
<span class="sd">    return(generic_func(data, wv, func = cf.bd2210_func, **kwargs))</span>

<span class="sd">def bd2290(data, **kwargs):</span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    NAME: BD2290</span>
<span class="sd">    PARAMETER: 2.29 micron band depth</span>
<span class="sd">    FORMULATION *: 1 - ( R2290 / (a*R2250+b*R2350) )</span>
<span class="sd">    RATIONALE: Mg,Fe-OH minerals (at 2.3); also CO2 ice</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : ndarray</span>
<span class="sd">           (n,m,p) array</span>
<span class="sd">    wv_array : ndarray</span>
<span class="sd">               (n,1) array of wavelengths that correspond to the p</span>
<span class="sd">               dimension of the data array</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">     : ndarray</span>
<span class="sd">       the processed ndarray</span>

<span class="sd">      (at 2.292  microns)</span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    wv = [2250,2290,2350]</span>
<span class="sd">    return(generic_func(data, wv, func = cf.bd2290_func, **kwargs))</span>


<span class="sd">def d2300(data, **kwargs):</span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    NAME: D2300</span>
<span class="sd">    PARAMETER: 2.3 micron drop</span>
<span class="sd">    FORMULATION *: 1 - ( (CR2290+CR2320+CR2330) /</span>
<span class="sd">      (CR2140+CR2170+CR2210) ) (CR values are observed R values</span>
<span class="sd">      divided by values fit along the slope as determined between 1.8</span>
<span class="sd">      and 2.53 microns - essentially continuum corrected))</span>
<span class="sd">    RATIONALE: hydrated minerals; particularly clays</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : ndarray</span>
<span class="sd">           (n,m,p) array</span>
<span class="sd">    wv_array : ndarray</span>
<span class="sd">               (n,1) array of wavelengths that correspond to the p</span>
<span class="sd">               dimension of the data array</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">     : ndarray</span>
<span class="sd">       the processed ndarray</span>

<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    wv = [1815, 2120, 2170, 2210, 2290, 2320, 2330, 2530]</span>
<span class="sd">    return(generic_func(data, wv, func = cf.d2300_func, **kwargs))</span>


<span class="sd">def sindex(data, **kwargs):</span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    NAME: SINDEX</span>
<span class="sd">    PARAMETER: Convexity at 2.29 microns  due to absorptions at</span>
<span class="sd">      1.9/2.1 microns and 2.4 microns</span>
<span class="sd">    FORMULATION *: 1 - (R2100 + R2400) / (2 * R2290) CR</span>
<span class="sd">      values are observed R values divided by values fit along the</span>
<span class="sd">      slope as determined between 1.8 - 2.53 microns (essentially</span>
<span class="sd">      continuum corrected))</span>
<span class="sd">    RATIONALE: hydrated minerals; particularly sulfates</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : ndarray</span>
<span class="sd">           (n,m,p) array</span>
<span class="sd">    wv_array : ndarray</span>
<span class="sd">               (n,1) array of wavelengths that correspond to the p</span>
<span class="sd">               dimension of the data array</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">     : ndarray</span>
<span class="sd">       the processed ndarray</span>

<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    wv = [2100,2400,2290]</span>
<span class="sd">    return(generic_func(data, wv, func = cf.sindex_func, **kwargs))</span>

<span class="sd">def icer2(data, **kwargs):</span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    NAME: ICER2</span>
<span class="sd">    PARAMETER: gauge 2.7 micron band</span>
<span class="sd">    FORMULATION *: R2530 / R2600</span>
<span class="sd">    RATIONALE: CO2 ice will be &gt;&gt;1, H2O ice and soil will be about 1</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : ndarray</span>
<span class="sd">           (n,m,p) array</span>
<span class="sd">    wv_array : ndarray</span>
<span class="sd">               (n,1) array of wavelengths that correspond to the p</span>
<span class="sd">               dimension of the data array</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">     : ndarray</span>
<span class="sd">       the processed ndarray</span>

<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    wv = [2530,2600]</span>
<span class="sd">    return(generic_func(data, wv, func = cf.icer2_func, **kwargs))</span>

<span class="sd">def bdcarb(data, **kwargs):</span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    NAME: BDCARB</span>
<span class="sd">    PARAMETER: overtone band depth</span>
<span class="sd">    FORMULATION *: 1 - ( sqrt [ ( R2330 / (a*R2230+b*R2390) ) *</span>
<span class="sd">      ( R2530/(c*R2390+d*R2600) ) ] )</span>
<span class="sd">    RATIONALE: carbonate overtones</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : ndarray</span>
<span class="sd">           (n,m,p) array</span>
<span class="sd">    wv_array : ndarray</span>
<span class="sd">               (n,1) array of wavelengths that correspond to the p</span>
<span class="sd">               dimension of the data array</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">     : ndarray</span>
<span class="sd">       the processed ndarray</span>

<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    wv = [2230,2330,2390,2530,2600]</span>
<span class="sd">    return(generic_func(data, wv, func = cf.bdcarb_func, **kwargs))</span>

<span class="sd">def bd3000(data, **kwargs):</span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    NAME: BD3000</span>
<span class="sd">    PARAMETER: 3 micron band depth</span>
<span class="sd">    FORMULATION *: 1 - ( R3000 / (R2530*(R2530/R2210)) )</span>
<span class="sd">    RATIONALE: H2O, chemically bound or adsorbed</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : ndarray</span>
<span class="sd">           (n,m,p) array</span>
<span class="sd">    wv_array : ndarray</span>
<span class="sd">               (n,1) array of wavelengths that correspond to the p</span>
<span class="sd">               dimension of the data array</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">     : ndarray</span>
<span class="sd">       the processed ndarray</span>

<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    wv = [2210,2530,3000]</span>
<span class="sd">    return(generic_func(data, wv, func = cf.bd3000_func, **kwargs))</span>

<span class="sd">def bd3100(data, **kwargs):</span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    NAME: BD3100</span>
<span class="sd">    PARAMETER: 3.1 micron band depth</span>
<span class="sd">    FORMULATION *: 1 - ( R3120 / (a*R3000+b*R3250) )</span>
<span class="sd">    RATIONALE: H2O ice</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : ndarray</span>
<span class="sd">           (n,m,p) array</span>
<span class="sd">    wv_array : ndarray</span>
<span class="sd">               (n,1) array of wavelengths that correspond to the p</span>
<span class="sd">               dimension of the data array</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">     : ndarray</span>
<span class="sd">       the processed ndarray</span>

<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    wv = [3000,3120,3250]</span>
<span class="sd">    return(generic_func(data, wv, func = cf.bd3100_func, **kwargs))</span>

<span class="sd">def bd3200(data, **kwargs):</span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    NAME: BD3200</span>
<span class="sd">    PARAMETER: 3.2 micron band depth</span>
<span class="sd">    FORMULATION *: 1 - ( R3320 / (a*R3250+b*R3390) )</span>
<span class="sd">    RATIONALE: CO2 ice</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : ndarray</span>
<span class="sd">           (n,m,p) array</span>
<span class="sd">    wv_array : ndarray</span>
<span class="sd">               (n,1) array of wavelengths that correspond to the p</span>
<span class="sd">               dimension of the data array</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">     : ndarray</span>
<span class="sd">       the processed ndarray</span>

<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    wv = [3250,3320,3390]</span>
<span class="sd">    return(generic_func(data, wv, func = cf.bd3200_func, **kwargs))</span>

<span class="sd">def bd3400(data, **kwargs):</span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    NAME: BD3400</span>
<span class="sd">    PARAMETER: 3.4 micron band depth</span>
<span class="sd">    FORMULATION *: 1 - ( (a*R3390+b*R3500) / (c*R3250+d*R3630) )</span>
<span class="sd">    RATIONALE: carbonates; organics</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : ndarray</span>
<span class="sd">           (n,m,p) array</span>
<span class="sd">    wv_array : ndarray</span>
<span class="sd">               (n,1) array of wavelengths that correspond to the p</span>
<span class="sd">               dimension of the data array</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">     : ndarray</span>
<span class="sd">       the processed ndarray</span>

<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    wv = [3250,3390,3500,3630]</span>
<span class="sd">    return(generic_func(data, wv, func = cf.bd3400_func, **kwargs))</span>

<span class="sd">def cindex(data, **kwargs):</span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    NAME: CINDEX</span>
<span class="sd">    PARAMETER: gauge 3.9 micron band</span>
<span class="sd">    FORMULATION *: ( R3750 + (R3750-R3630) / (3750-3630) *</span>
<span class="sd">      (3920-3750) ) / R3950 - 1</span>
<span class="sd">    RATIONALE: carbonates</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : ndarray</span>
<span class="sd">           (n,m,p) array</span>
<span class="sd">    wv_array : ndarray</span>
<span class="sd">               (n,1) array of wavelengths that correspond to the p</span>
<span class="sd">               dimension of the data array</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">     : ndarray</span>
<span class="sd">       the processed ndarray</span>

<span class="sd">    Algorithm differs from published - coded as per CAT</span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    wv = [3630,3750,3950]</span>
<span class="sd">    return(generic_func(data, wv, func = cf.cindex_func, **kwargs))&#39;&#39;&#39;</span>
</pre></div>

          </div>
        </div>
          </div>
        </div>
      </div>
    </div>

    <div class="container container-navbar-bottom">
      <div class="spc-navbar">
        
      </div>
    </div>
    <div class="container">
    <div class="footer">
    <div class="row-fluid">
    <ul class="inline pull-left">
      <li>
        &copy; Copyright 2018 - PySAT Developers.
      </li>
      <li>
      Last updated on Apr 20, 2018.
      </li>
      <li>
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.7.2.
      </li>
    </ul>
    </div>
    </div>
    </div>
  </body>
</html>